<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>markdown语法，由浅入深，最全攻略，笔记。</title>
    <url>/2020/02/24/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="一、markdown简介"><a href="#一、markdown简介" class="headerlink" title="一、markdown简介"></a>一、markdown简介</h1><p>（注：如果对markdown有一定了解。可以略过此处，第一章主要对markdown基础知识做个补充,摘自菜鸟教程<a href="https://www.runoob.com/markdown/md-tutorial.html">此处原文档</a> ）</p>
<h2 id="1-1-markdown背景"><a href="#1-1-markdown背景" class="headerlink" title="1.1 markdown背景"></a>1.1 markdown背景</h2><h3 id="1-markdown是一种轻量级标记语言，她与徐人们使用易读易写的纯文本格式编写文档。"><a href="#1-markdown是一种轻量级标记语言，她与徐人们使用易读易写的纯文本格式编写文档。" class="headerlink" title="1. markdown是一种轻量级标记语言，她与徐人们使用易读易写的纯文本格式编写文档。"></a>1. markdown是一种轻量级标记语言，她与徐人们使用易读易写的纯文本格式编写文档。</h3><h3 id="2-Markdown-语言在-2004-由约翰·格鲁伯（英语：John-Gruber）创建。"><a href="#2-Markdown-语言在-2004-由约翰·格鲁伯（英语：John-Gruber）创建。" class="headerlink" title="2. Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。"></a>2. Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</h3><h3 id="3-Markdown-编写的文档可以导出-HTML-、Word、图像、PDF、Epub-等多种格式的文档。"><a href="#3-Markdown-编写的文档可以导出-HTML-、Word、图像、PDF、Epub-等多种格式的文档。" class="headerlink" title="3. Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。"></a>3. Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</h3><h3 id="4-Markdown-编写的文档后缀为-md-markdown。"><a href="#4-Markdown-编写的文档后缀为-md-markdown。" class="headerlink" title="4. Markdown 编写的文档后缀为 .md, .markdown。"></a>4. Markdown 编写的文档后缀为 .md, .markdown。</h3><h2 id="1-2-markdown应用"><a href="#1-2-markdown应用" class="headerlink" title="1.2 markdown应用"></a>1.2 markdown应用</h2><h3 id="Markdown-能被使用来撰写电子书，如：Gitbook。"><a href="#Markdown-能被使用来撰写电子书，如：Gitbook。" class="headerlink" title="Markdown 能被使用来撰写电子书，如：Gitbook。"></a>Markdown 能被使用来撰写电子书，如：Gitbook。</h3><h3 id="当前许多网站都广泛使用-Markdown-来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack-Exchange、OpenStreetMap-、SourceForge等。"><a href="#当前许多网站都广泛使用-Markdown-来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack-Exchange、OpenStreetMap-、SourceForge等。" class="headerlink" title="当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。"></a>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</h3><h2 id="1-3-编辑器"><a href="#1-3-编辑器" class="headerlink" title="1.3 编辑器"></a>1.3 编辑器</h2><h3 id="编辑器有很多种，基本各大编辑器都可以编辑markdown格式文档。"><a href="#编辑器有很多种，基本各大编辑器都可以编辑markdown格式文档。" class="headerlink" title="编辑器有很多种，基本各大编辑器都可以编辑markdown格式文档。"></a>编辑器有很多种，基本各大编辑器都可以编辑markdown格式文档。</h3><h3 id="比如：Typora，sublime-Text-coderunner-印象笔记，vim等等等。具体的可以百度，都非常好用。"><a href="#比如：Typora，sublime-Text-coderunner-印象笔记，vim等等等。具体的可以百度，都非常好用。" class="headerlink" title="比如：Typora，sublime Text, coderunner,印象笔记，vim等等等。具体的可以百度，都非常好用。"></a>比如：Typora，sublime Text, coderunner,印象笔记，vim等等等。具体的可以百度，都非常好用。</h3><hr>
<h1 id="二、markdown基本操作"><a href="#二、markdown基本操作" class="headerlink" title="二、markdown基本操作"></a>二、markdown基本操作</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>使用#号标记，可以表示1-6级标题，随#个数递增。如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：最后一个#与文字间一定要有一个空格。</p>
<p>显示效果：</p>
<p><img src="https://i.loli.net/2020/02/17/wIWVKahMtmTLu4n.png" alt="显示效果"></p>
<h2 id="2-换行"><a href="#2-换行" class="headerlink" title="2.换行"></a>2.换行</h2><p>markdown换行方式有很多种</p>
<ul>
<li>直接在一句话后面敲两个空格</li>
<li>两句话之间加一个空行</li>
<li>如果你在编辑的时候，想让一行文字分成几段在显示的时候换行，就在中间加</li>
</ul>
<p><img src="https://i.loli.net/2020/02/18/UrtqpfeOPlDW5VT.png" alt="image.png"></p>
<p>此点是我想在表格里换行时get到的，也很实用,后面讲到表格我会展示。</p>
<h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h2><p>markdown支持几种字体：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="strong">__<span class="emphasis">_粗斜体文本<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"></span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<p>把你想修改的字段直接放在中间即可。显示效果如下：</p>
<p><img src="https://i.loli.net/2020/02/18/JNMP7tG4KdXaxoj.png" alt="image.png"></p>
<h2 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h2><p>markdown中分割线，能是你的文章结构更加清楚</p>
<p>几种分割线的写法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> <span class="emphasis">* *</span></span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">**</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">- - -</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">----------</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br></pre></td></tr></table></figure>
<p>这些都可以是分割线。如果你在你自己的博客网站加上美化，他可以看着更舒服哈哈哈。</p>
<h2 id="5-删除线，下划线。"><a href="#5-删除线，下划线。" class="headerlink" title="5.删除线，下划线。"></a>5.删除线，下划线。</h2><p>写法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">~~删除线~~</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<p><img src="https://i.loli.net/2020/02/18/O5K2AyjdYMRsLqN.png" alt="image.png"></p>
<h2 id="6-分点条列"><a href="#6-分点条列" class="headerlink" title="6.分点条列"></a>6.分点条列</h2><ol>
<li>无序</li>
</ol>
<p>markdown可以通过 * - + 开头作为列表标记。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">*</span> 第一行</span><br><span class="line"><span class="bullet">*</span> 第二行</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 第一行</span><br><span class="line"><span class="bullet">-</span> 第二行</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 第一行</span><br><span class="line"><span class="bullet">+</span> 第二行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<p><img src="https://i.loli.net/2020/02/18/e6z4iBGOrKhySF1.png" alt="image.png"></p>
<ol>
<li>有序</li>
</ol>
<p>有序的直接数字后面跟着一个点就可以了，和咱们平时写的一样。</p>
<ol>
<li>嵌套使用</li>
</ol>
<p>有序无序也可以嵌套使用 如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.第一行</span><br><span class="line"><span class="bullet">  -</span> 第一点</span><br><span class="line"><span class="bullet">  -</span> 第二点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="https://i.loli.net/2020/02/18/wg6JV1rRxzoEvAi.png" alt="image.png"></p>
<h2 id="7-区块"><a href="#7-区块" class="headerlink" title="7.区块"></a>7.区块</h2><p>markdown区块是在段落开头使用 “&gt;”，依然是紧跟空格</p>
<p>写法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="quote">&gt; markdown</span></span><br><span class="line"><span class="quote">&gt; 基础</span></span><br><span class="line"><span class="quote">&gt; 区块引用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<p>markdown<br>基础<br>区块引用</p>
</blockquote>
<ol>
<li>区块嵌套</li>
</ol>
<p>通过”&gt;” 个数展示分层差别：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="quote">&gt; markdown</span></span><br><span class="line">&gt;&gt; 基础</span><br><span class="line">&gt;&gt;&gt; 区块引用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<p>markdown</p>
<blockquote>
<p>基础</p>
<blockquote>
<p>区块引用</p>
</blockquote>
</blockquote>
</blockquote>
<ol>
<li>区块中使用列表</li>
</ol>
<p>实例如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="quote">&gt; 区块中使用列表</span></span><br><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt; 2. 第二项</span></span><br><span class="line">&gt;&gt; + 第一项</span><br><span class="line">&gt;&gt; + 第二项</span><br><span class="line">&gt;&gt; + 第三项</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项<blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>
<p>注：在列表中使用区块是同样的道理，这里不再赘述。</p>
<hr>
<h1 id="三、markdown进阶"><a href="#三、markdown进阶" class="headerlink" title="三、markdown进阶"></a>三、markdown进阶</h1><h2 id="1-markdown-插入代码"><a href="#1-markdown-插入代码" class="headerlink" title="1. markdown 插入代码"></a>1. markdown 插入代码</h2><ul>
<li>插入一行代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`int a = 0;`//英文版的数字1左边的那个符号。。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><code>int a = 0;</code></p>
<ul>
<li>插入代码块</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​```紧跟着可以写上用的什么语言，也可以不用写。</span><br><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line"></span><br><span class="line">​```结尾与开头一样</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-markdown插入链接"><a href="#2-markdown插入链接" class="headerlink" title="2.markdown插入链接"></a>2.markdown插入链接</h2><p>链接语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：符号全英文</p>
<p>比如：</p>
<p><code>[这是百度](https://www.baidu.com)</code></p>
<p>效果：</p>
<p><a href="https://www.baidu.com">这是百度</a></p>
<p>记着点完返回阿，或者新建页面打开，嘿嘿嘿</p>
<h2 id="3-markdown插入图片"><a href="#3-markdown插入图片" class="headerlink" title="3.markdown插入图片"></a>3.markdown插入图片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片描述，可写可不写，但是中括号要有](图片地址，本地链接或者URL地址。)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">比如我此文章的图片：</span><br><span class="line"></span><br><span class="line">![markdown](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1613194509,3683268681&amp;fm=26&amp;gp=0.jpg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后会显示出来，我就不做效果拉。</p>
<h2 id="4-markdown表格"><a href="#4-markdown表格" class="headerlink" title="4. markdown表格"></a>4. markdown表格</h2><p>每排单元格要用<kbd> |</kbd> 分开 表头与内容用 <kbd>—-</kbd> 分开</p>
<p>语法如下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">|  表头   | 表头  | 表头 | 表头 |</span><br><span class="line">| :---  | ---:  | :--: | ---- |</span><br><span class="line">| 单元格  | 单元格 |单元格|单元格|</span><br><span class="line">| 单元格  | 单元格 |单元格|单元格|</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表头</th>
<th style="text-align:right">表头</th>
<th style="text-align:center">表头</th>
<th>表头</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
<td>单元格</td>
</tr>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
<td>单元格</td>
</tr>
</tbody>
</table>
</div>
<p>加<kbd>:</kbd>可以实现左对齐，右对齐，居中。不加则默认为左对齐</p>
<h2 id="5-markdown支持HTML元素"><a href="#5-markdown支持HTML元素" class="headerlink" title="5.markdown支持HTML元素"></a>5.markdown支持HTML元素</h2><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/24/miegMwcH8aDWYtu.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>上课笔记</category>
      </categories>
      <tags>
        <tag>上课笔记</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>信息系统安全复习提纲</title>
    <url>/2021/06/18/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="信息系统安全复习提纲"><a href="#信息系统安全复习提纲" class="headerlink" title="信息系统安全复习提纲"></a>信息系统安全复习提纲</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h2 id="第四章-身份认证"><a href="#第四章-身份认证" class="headerlink" title="第四章 身份认证"></a>第四章 身份认证</h2><ul>
<li>概述：</li>
</ul>
<p>身份认证是信息系统的第一道安全防线，包括<mark class="hl-label default">标识</mark> 与<mark class="hl-label blue">鉴别</mark> 两个过程</p>
<ul>
<li>身份认证方式</li>
</ul>
<div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">基于口令的认证</button></li><li class="tab"><button type="button" data-href="#test4-2">基于智能卡的认证方式</button></li><li class="tab"><button type="button" data-href="#test4-3">基于生物特征的认证方式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>基于口令认证是我们最常用的一种认证方式，根据动态因素的不同，分为同步认证技术和异步认证技术。其中同步认证技术又分为基于时间同步认证技术和基于事件同步认证技术。异步认证技术即为挑战/应答认证技术</p>
<p>挑战应答是什么样的方式，大家要掌握</p>
<p>会区别是基于时间同步的还是挑战应答的</p>
<p>1）基于时间同步认证技术是把流逝的时间作为变动因子（60秒作为变化单位，用“滑动窗口”技术）。用户密钥卡和认证服务器所产生的密码在时间上必须同步。 具有操作简单，携带方便等优点，难点在于需要解决网络延迟等不确定因素带来的干扰。</p>
<p>动态令牌，手机令牌 （一次性口令）</p>
<p>2) 基于事件同步认证技术是把变动的数字序列（事件序列）作为密码产生器的一个运算因子与用户的私钥共同产生动态密码。用户密钥卡和认证服务器保持相同的事件序列。 </p>
<p>3) 挑战/应答方式的变动因子是由认证服务器产生的随机数字序列（Challenge），它也是密 码卡的密码生成的变动因子，由于每一个Challenge都是唯一的、不会重复使用，并且 Challenge是在同一个地方产生，不需要同步。</p>
<p>应用最广泛一次性口令实现方式</p>
<p>基本原理：每次认证时，服务器产生一个随机数（称为挑战）发送给客户端，客户端以该随机数作为不确定因素，用某种单向算法计算出结果作为应答，服务器通过验证应答的有效性来判断客户端身份的合法性。其最为经典的方案是S/Key协议 分为两个过程：注册过程和认证过程。注册过程只执行一次，而认证过程则在用户的每次登录时都要执行。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p>基于PKI技术体系的USB Key 认证原理</p>
<p>USB Key中预置了加密算法，摘要算法，秘钥生成算法等，可利用秘钥生成算法首先为用户生成一对公/私钥，私钥保存在USB Key中，公钥可以导出向CA申请生成数字证书，数字证书也保存在USB Key中。在进行客户端身份认证时，客户端向服务器发送数字证书，服务端利用CA的公钥验证数字证书的真实性，完后才能对客户端身份的认证，客户端可也要求服务端发送数字证书以验证服务端的真实身份</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p>这里无重点，但是要知道这种认证方式。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<ul>
<li>身份认证协议</li>
</ul>
<p>包括单向认证协议和双向认证协议</p>
<p>需要掌握双向认证协议，能够自己来设计实现一个基于对称密码体制实现双向认证或者公钥密码体制的双向认证，设计实现</p>
<p>113页 三个选择题</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>访问控制策略 </p>
<p>自主访问控制   </p>
<p>访问控制矩阵，访问控制列表 访问能力表 实现方式一定要掌握  到底是怎么实现的</p>
<p>强制访问控制</p>
<p>基于角色访问控制</p>
<p>自主访问控制的缺点 118页</p>
<p>强制访问控制</p>
<p>两种模型</p>
<p> BLP 两种基本原则 简单安全性，*特性 </p>
<p>图 写的话可以向上写，读的话只能向下读</p>
<p>防范特洛伊木马，下面那段119页 </p>
<p>Biba </p>
<p>数据完整性的保护， 策略 主体只能向下写 向上读 </p>
<p>4到选择题 125页</p>
<h2 id="操作系统安全-—了解"><a href="#操作系统安全-—了解" class="headerlink" title="操作系统安全 —了解"></a>操作系统安全 —了解</h2><p>进程，进程的状态和转换 135页</p>
<p>存储保护，涉及到地址越界和</p>
<p>最小特权管理 最小特权的思想</p>
<p>是系统不应赋予用户超过其执行任务所需特权以外的特权，或者说仅给用户赋予必不可少的特权，最小特权原则一方面赋予主体“必不可少”的特权以保证用户能完成承担的任务或操作，另一放面它仅给用户“必不可少的特权从而能限制用户所能进行的操作。</p>
<h2 id="数据库系统安全"><a href="#数据库系统安全" class="headerlink" title="数据库系统安全"></a>数据库系统安全</h2><p>数据库备份与恢复技术</p>
<p>备份技术：日志和数据备份 要知道数据备份分为静态备份和动态备份 是什么过程</p>
<p>数据库恢复技术</p>
<h2 id="信息系统安全评价标准和等级保护"><a href="#信息系统安全评价标准和等级保护" class="headerlink" title="信息系统安全评价标准和等级保护"></a>信息系统安全评价标准和等级保护</h2><p>两种标准 TCSEC和CC</p>
<p>TCSEC的首次引用在C2层</p>
<p>CC标准有三个部分组成 1. 2. 3. 部分</p>
<h2 id="信息系统安全风险评估"><a href="#信息系统安全风险评估" class="headerlink" title="信息系统安全风险评估"></a>信息系统安全风险评估</h2><p>风险评估方法：定量 定性 相结合 有一定认识</p>
<p>机密性 完整性 可控性？</p>
<p>风险评估的过程 流程图 258页</p>
<p>风险计算原理 三个计算环节 267页</p>
<p>风险值计算 两种常用方法 例子会</p>
<h2 id="恶意代码检测与防范技术"><a href="#恶意代码检测与防范技术" class="headerlink" title="恶意代码检测与防范技术"></a>恶意代码检测与防范技术</h2><p>计算机病毒一般特征 </p>
<p>277 页工作过程</p>
<p>计算机病毒检测</p>
<p>木马的功能 四个</p>
<p>木马的检测与防范 步骤</p>
<p>蠕虫 </p>
<p>病毒和蠕虫的区别</p>
<p>红色代码蠕虫</p>
<p>蠕虫的结构和工作机制</p>
<h2 id="应用系统安全"><a href="#应用系统安全" class="headerlink" title="应用系统安全"></a>应用系统安全</h2><p>冲击波 震荡波</p>
<p>缓冲区溢出原理 原因 构造一个缓冲区溢出的攻击过程  297页</p>
<p>web应用漏洞 sql注入 和跨站脚本 构造sql语句 原理</p>
<p>跨站脚本分为三类</p>
<p>安全审计 以及一般流程</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/06/16/%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div class="mermaid">pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5</div>
<div class="mermaid">
graph TD    

​			Start --&gt; Stop
</div>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<a class="btn-beautify button--animated larger" href="https://butterfly.js.org/" 
  title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify button--animated blue larger" href="https://butterfly.js.org/" 
  title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify button--animated pink larger" href="https://butterfly.js.org/" 
  title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify button--animated red larger" href="https://butterfly.js.org/" 
  title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify button--animated purple larger" href="https://butterfly.js.org/" 
  title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify button--animated orange larger" href="https://butterfly.js.org/" 
  title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify button--animated green larger" href="https://butterfly.js.org/" 
  title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<p>臣亮言：<mark class="hl-label default">先帝</mark> 创业未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此诚<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark> ，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</p>
<div class="note icon flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>
<div class="note pink icon flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>
<div class="note red icon flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>
<div class="note orange icon flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note purple icon flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>
<div class="note green icon flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/23/RSA%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="RSA密码"><a href="#RSA密码" class="headerlink" title="RSA密码"></a>RSA密码</h2><h3 id="一、什么是RSA算法"><a href="#一、什么是RSA算法" class="headerlink" title="一、什么是RSA算法"></a>一、什么是RSA算法</h3><ul>
<li><p>RSA算法是最常用的非对称加密算法，由三位麻省理工学院密码学者<a href="https://baike.baidu.com/item/罗纳德·李维斯特/700199">罗纳德·李维斯特</a>（Ron Rivest）、<a href="https://baike.baidu.com/item/阿迪·萨莫尔">阿迪·萨莫尔</a>（Adi Shamir）和<a href="https://baike.baidu.com/item/伦纳德·阿德曼/12575612">伦纳德·阿德曼</a>（Leonard Adleman）于1977年一起提出，RSA就是他们三人姓氏开头字母拼在一起组成的。</p>
</li>
<li><p>RSA被誉为是一种风格优雅的公开密钥密码。由于RSA密码即可用于加密，又可用于数字签名，通俗易懂，因此RSA密码已成为最广泛的公开密钥密码。</p>
</li>
</ul>
<h3 id="二、RSA的加密算法"><a href="#二、RSA的加密算法" class="headerlink" title="二、RSA的加密算法"></a>二、RSA的加密算法</h3><ol>
<li>随机地选取两个大素数$p$和$q$，而且保密。</li>
<li>计算$n = pq$，将$n$公开。</li>
<li>计算$\varphi(n) = (p-1)(q-1)$，对$\varphi(n)$保密。</li>
<li>随机地选取一个正整数e，$1&lt;e&lt;\varphi(n)$且$(e,\varphi(n)) = 1$，将e公开。</li>
<li>根据$ed = 1\,\,\ mod \,\,\,\varphi(n)$，求出d，对d保密。</li>
<li>加密运算：</li>
</ol>
<script type="math/tex; mode=display">
C = M^e \, mod \quad n</script><ol>
<li>解密运算：</li>
</ol>
<script type="math/tex; mode=display">
M = C^d\,mod \quad n</script><h4 id="示例（教材）："><a href="#示例（教材）：" class="headerlink" title="示例（教材）："></a>示例（教材）：</h4><ol>
<li><p>选择素数： $p=47$ 和 $q=71$。</p>
</li>
<li><p>计算$n$和$j (n)$：</p>
</li>
</ol>
<p>• $n = pq =47×71=3337$，</p>
<p>•$j (n)=(p–1)(q-1)=46×70=3220$。</p>
<ol>
<li><p>选择<em>e</em>：使 $gcd(e, 3220)=1$，选取<em>e</em>=79；</p>
</li>
<li><p>决定$d$：$de≡1 \,mod\quad3220$，得$d =1019$</p>
</li>
<li><p>公开公钥 {79, 3337}，</p>
</li>
<li><p>保存私钥 {1019, 3337}；</p>
</li>
</ol>
<p>令明文M（16位 三位一组）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">688</span> <span class="number">232</span> <span class="number">687</span> <span class="number">966</span> <span class="number">668</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>$M_1 = 688，M_2 = 232，M_3 = 687，M_4= 966，M_5= 668，M_6= 3$</p>
<p>$M_1$的密文$C_1 = 688^{79} \,\,mod \,\,3337 = 1570$</p>
<p>进行类似的计算，可的最终的密文：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1570</span> <span class="number">2756</span> <span class="number">2091</span> <span class="number">2276</span> <span class="number">2423</span> <span class="number">158</span></span><br></pre></td></tr></table></figure>
<p>如果解密，计算$M_1 = 1570^{1019} \,mod \,\,3337 = 688$，类似地还可以解密还原出其他明文。</p>
<p>由此可知，计算量是非常庞大的，下面我们用代码求解此问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">71</span>;</span><br><span class="line">    <span class="keyword">int</span> n = q*p;</span><br><span class="line">    <span class="comment">//int n_φ = (q-1)*(p-1);</span></span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">79</span>;</span><br><span class="line">    <span class="comment">//int d = 1019;</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">16</span>] = &#123;<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">6</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">        b[i] +=a[i*<span class="number">3</span>]*<span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">2</span>)+a[i*<span class="number">3</span>+<span class="number">1</span>]*<span class="number">10</span>+a[i*<span class="number">3</span>+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">5</span>] = a[<span class="number">15</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//最困扰的是幂运算，这里由于计算数据量庞大，超出了int类型的存储范围。</span></span><br><span class="line">  <span class="comment">//用M mod n 求出的余数在乘以M 然后在 mod n,依次类推重复e次。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;e; i++) &#123;</span><br><span class="line">        sum = sum * b[j];</span><br><span class="line">        sum = sum % n;</span><br><span class="line">    &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/Users/Yan/Library/Application Support/typora-user-images/image-20210425125008874.png" alt="image-20210425125008874"></p>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>这里附上问题及代码，大题思路一致，就不做详细解答。</p>
<h4 id="1-实验1：令p-3-q-11-d-7-M-5-编程计算密文C。"><a href="#1-实验1：令p-3-q-11-d-7-M-5-编程计算密文C。" class="headerlink" title="1. 实验1：令p = 3 ,q = 11,d = 7,M = 5 , 编程计算密文C。"></a>1. 实验1：令p = 3 ,q = 11,d = 7,M = 5 , 编程计算密文C。</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//实验1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> n = q*p;</span><br><span class="line">    <span class="keyword">int</span> n_φ = (q<span class="number">-1</span>)*(p<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i*d%n_φ ==<span class="number">1</span>) &#123;</span><br><span class="line">            e = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="keyword">int</span>)<span class="built_in">pow</span>(m,e)%n;</span><br><span class="line">    cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-实验2：设RSA密码的e-3-n-33-C-9-编程计算明文M。"><a href="#2-实验2：设RSA密码的e-3-n-33-C-9-编程计算明文M。" class="headerlink" title="2. 实验2：设RSA密码的e = 3, n = 33, C = 9,编程计算明文M。"></a>2. 实验2：设RSA密码的e = 3, n = 33, C = 9,编程计算明文M。</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  实验2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 闫子龙 on 2021/4/25.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;n ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j&lt;=i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%j == <span class="number">0</span> &amp;&amp; n%j == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) sum++;</span><br><span class="line">        <span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n_φ = sum;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i*e%n_φ ==<span class="number">1</span>) &#123;</span><br><span class="line">            d = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">pow</span>(C,d)%n;</span><br><span class="line">        cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-令-p-17-q-11-e-7-试计算RSA密码其余参数。进一步对于m-88-计算密文C"><a href="#3-令-p-17-q-11-e-7-试计算RSA密码其余参数。进一步对于m-88-计算密文C" class="headerlink" title="3. 令 p = 17, q = 11,e = 7,试计算RSA密码其余参数。进一步对于m = 88,计算密文C"></a>3. 令 p = 17, q = 11,e = 7,试计算RSA密码其余参数。进一步对于m = 88,计算密文C</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  实验3</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 闫子龙 on 2021/4/25.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//令 p=17,q=11, e=7,试计算 RSA 密码其余参数 。进一步对于 m=88, 计算密文 C 。</span></span><br><span class="line">    <span class="comment">//已知参数</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">88</span>;</span><br><span class="line">    <span class="comment">//其余参数</span></span><br><span class="line">    <span class="keyword">int</span> n = p*q;</span><br><span class="line">    <span class="keyword">int</span> n_φ = (q<span class="number">-1</span>)*(p<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i*e%n_φ ==<span class="number">1</span>) &#123;</span><br><span class="line">            d = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;e; i++) &#123;</span><br><span class="line">        sum = sum * m;</span><br><span class="line">        sum = sum % n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;n为：&quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;n_φ为：&quot;</span>&lt;&lt;n_φ&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;d为：&quot;</span>&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;密文：&quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>DES算法全解+C语言实现（加密和解密）</title>
    <url>/2021/04/17/DES%E7%AE%97%E6%B3%95%E5%85%A8%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="DES算法全解"><a href="#DES算法全解" class="headerlink" title="DES算法全解"></a>DES算法全解</h2><h3 id="一、什么是DES算法"><a href="#一、什么是DES算法" class="headerlink" title="一、什么是DES算法"></a>一、什么是DES算法</h3><ul>
<li><strong>DES</strong>是(Data Encryption Standard）的缩写，为密码体制中的对称密码体制，又被称为美国数据加密标准。</li>
<li>DES是一种分组密码。明文，密文，密钥的分组长度都是64位。</li>
<li>DES是面向二进制的密码算法。因而能够加解密任何形式的计算机数据。</li>
<li>DES是对合运算，因而加密和解密共用同一算法，从而使工程实现的工作量减半</li>
<li>DES的密码结构属于Feistel结构</li>
</ul>
<h3 id="二、DES的加密过程"><a href="#二、DES的加密过程" class="headerlink" title="二、DES的加密过程"></a>二、DES的加密过程</h3><ol>
<li>64位秘钥经子秘钥产生算法产生出16个子秘钥：$K<em>1,K_2,…,K</em>{16}$, 分别供第一次，第二次，… ，第十六次加密迭代使用。</li>
<li>64位明文首先经过初始置换$IP（Initial\quad permutation）$，将数据打乱重新排列并分成左右两半，左边32位构成$L_0$，右边32位构成$R_0$。</li>
<li>由加密函数$f$实现子密钥$K_1$对$R_0$的加密，结果为32位的数据组$f(R_0,K_1)$。$f(R_0,K_1)$再与$L_0$模2相加，又得到一个有32位的数据组$L_0\bigoplus f(R_0,K_1)$。以$L_0\bigoplus f(R_0,K_1)$作为第二次加密迭代的$R_1$，以$R_0$作为第二次加密迭代的$L_1$。至此，第一次加密迭代结束。</li>
<li>第二次加密迭代至第十六次加密迭代分别用子密钥$K<em>2，…，K</em>{16}$进行，其过程与第一次加密迭代相同。</li>
<li>第十六次加密迭代结束后，产生一个64位的数据组。以其左边32位作为$L<em>{16}$，以其右边32位作为$R</em>{16}$，两者合并在经过逆初始置换<strong>$\color{red}{IP^{-1} }$</strong>，将数据重新排列，便得到64位密文。至此加密过程全部结束。</li>
</ol>
<h3 id="三、DES的算法细节"><a href="#三、DES的算法细节" class="headerlink" title="三、DES的算法细节"></a>三、DES的算法细节</h3><p>下面我们详细的介绍算法细节。</p>
<h4 id="1-创建16个子秘钥，每个长48比特"><a href="#1-创建16个子秘钥，每个长48比特" class="headerlink" title="1.     创建16个子秘钥，每个长48比特"></a>1.     创建16个子秘钥，每个长48比特</h4><p>创建子密钥过程大致流程图如下：</p>
<p><img src="https://i.loli.net/2021/04/13/FkdKeIb3ylh7YnZ.jpg" alt="流程" style="zoom:70%;" /></p>
<p>64位秘钥我们已经给出，现在依次介绍置换选择1，，置换选择2，循环左移。</p>
<ol>
<li><p><strong>置换选择1</strong></p>
<ul>
<li><p>64位秘钥分为8个字节，每个字节的前7位是真正的秘钥位，第8位是奇偶校验位。奇偶校验位可以从前7位秘钥位计算得出，不是随机的，因而不起秘钥的作用。奇偶校验位的作用在于可检测秘钥中是否有错误，确保秘钥的完整性，因此，DES真正的秘钥只有56位。</p>
</li>
<li><p>置换选择1的作用，一是从64位秘钥中去掉8个奇偶校验位，二是把其余56位秘钥位打乱重新排，且将前28位作为$C_0$，后28位作为$D_0$。</p>
</li>
<li><p>置换选择1规定：$C_0$的各位依次为原秘钥中的第57，49，…，1，…，44，36位。$D_0$的各位依次为原秘钥中的第63，55，…，7，…，12，4位，具体矩阵如下：</p>
<p><img src="https://i.loli.net/2021/04/13/oDOfBns9UCNzHa4.jpg" alt="CBCEA409-810F-4561-8D56-F37A664CD81D.png"></p>
</li>
</ul>
</li>
</ol>
<p><strong>例：秘钥为12345678</strong></p>
<p>以ASCLL码的形式转化为二进制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00110001</span> <span class="number">00110010</span> <span class="number">00110011</span> <span class="number">00110100</span> <span class="number">00110101</span> <span class="number">00110110</span> <span class="number">00110111</span> <span class="number">00111000</span></span><br></pre></td></tr></table></figure>
<p>那么，此秘钥置换选择1后的结果为：</p>
<p><strong>置换选择1：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">11110110</span> <span class="number">01100111</span> <span class="number">1001000</span> <span class="number">00001111</span></span><br></pre></td></tr></table></figure>
<p>$C_0$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000000000111111111111</span></span><br></pre></td></tr></table></figure>
<p>$D_0$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0110011001111000100000001111</span></span><br></pre></td></tr></table></figure>
<ol>
<li>置换选择2<ul>
<li>将$C_i$和$D_i$合并成一个56位的中间数据，置换选择2从中选择出一个48位的子密钥$K_i$。置换选择2的矩阵如下图</li>
<li>置换选择2规定子密钥$K_i$中的第1，2，…，48位依次是这个56位中间数据中的第14，17，…，5，3，…，29，32位。</li>
</ul>
</li>
</ol>
<p><img src="https://i.loli.net/2021/04/13/UIjui52XOpSKMVG.jpg" alt="置换选择2" style="zoom:50%;" /></p>
<ol>
<li>循环左移：将密钥（除第一位）整体左移一位，将第一位移动至最后一位。循环左移位数表如下：<img src="https://i.loli.net/2021/04/13/A6mZS13PtH7VoMn.jpg" alt="循环左移位数表" style="zoom:80%;" /></li>
</ol>
<p>16轮子密钥生成结果如下：</p>
<h4 id="2-明文初始变换"><a href="#2-明文初始变换" class="headerlink" title="2. 明文初始变换"></a>2. 明文初始变换</h4><p>初始置换$IP$是DES的第一步密码变换，初始置换的作用在于将64位明文打乱重排，并陈诚左右两半，左边32位作为$L_0$,右边32位作为$R_0$。供后面的加密迭代使用。初始置换$IP$的矩阵如下：（道理同上）</p>
<p><img src="https://i.loli.net/2021/04/13/3hQYXmSt5iyRU6W.jpg" alt="初始置换IP" style="zoom:50%;" /></p>
<h4 id="3-加密函数"><a href="#3-加密函数" class="headerlink" title="3. 加密函数"></a>3. 加密函数</h4><p>加密函数是DES的核心部分。它的作用是在第$i$次加密迭代中用子密钥$K<em>i$对$R</em>{i-1}$进行加密。</p>
<p>在第$i$次迭代加密中选择运算$E$对32位的$R<em>{i-1}$的各位进行选择和排列，产生一个48位的结果，此结果与子密钥$K_i$模2相加，然后送入代替函数组$S$。代替函数组由8个代替函数（也称S盒子）组成，每个S盒子有6位输入，产生4位的输出。8个S盒子的输出合并，结果得到一个32位的数据组。此数据组在经过置换运算P，将其各位打乱重排，置换运算P的输出便是加密函数的输出$f(R</em>{i-1},K_i)$。</p>
<ol>
<li><p><strong>选择运算E</strong>对32位的数据组A的各位进行选择和排列，产生一个48位的结果。他是一种扩展运算，其矩阵如图：</p>
<p><img src="https://i.loli.net/2021/04/13/E7qNenOyYbIAPhK.jpg" alt="选择运算" style="zoom:30%;" /></p>
</li>
<li><p><strong>代替函数组S</strong>由8个代替函数（也称S盒子）组成，8个S盒分别记为，$S_1,S_2,…,S_8$。代替函数组的输入时一个48位的数据，从第一位到第48位依次加到8个S盒的输入端，每个S盒有一个代替矩阵，规定了其输出与输入的代替规则。代替矩阵有4行16列，每行都是0到15这16个数字，但每行的数字排列都不同，而且8个代替矩阵彼此也不同，每个S盒有6位输入，产生4位的输出。S盒运算的结果是用输出数据代替了输入数据，所以称其为代替函数。</p>
<p>​        <strong>S盒的代替规则：</strong>S盒的六位输入中，第一位和第六位组成二进制数并转化为十进制数代表选中的行号，其余四位组成二进制数并转化为十进制数代表选中的列号。那么被选中的那个数就是要输出的数（转化为二进制）。</p>
<p>​        以$S<em>1$为例，如果输入的是101011，第一位与第六位组成行号 $11</em>{(2)} = 3<em>{(10)}$ ，选中第三行，其余四位组成列号 $0101</em>{(2)} = 5_{(10)}$，选中第五列，交点数字是9，则$S_1$的输出是1001。</p>
</li>
<li><p><strong>置换运算$P$：</strong>置换运算吧S盒输出的32位数据打乱重排，得到32位的加密函数输出。用P置换来提供扩散，把S盒的混淆作用扩散开来。此时，$R<em>{i-1}$变成$L</em>{i}$，$L_i$再和置换运算P得出来的32位数据做$\bigoplus$运算，得到$R_i$。置换矩阵如图：</p>
</li>
<li><strong>逆初始置换$IP^{-1}$：</strong>是初始置换的逆置换，它把第十六次加密迭代的结果打乱重排（这里$R<em>{16}$与$L</em>{16}$互换），形成64位密文。至此，加密过程完全结束。</li>
</ol>
<p><img src="https://i.loli.net/2021/04/14/FqoekW3m52puVa8.jpg" alt="672C1E7DBC59E27A94DF29AF58498D4B.jpg" style="zoom:50%;" /></p>
<p><img src="https://i.loli.net/2021/04/14/dmfvIlgerVpCtOZ.jpg" alt="4C5C280892CC879204AC6F800285FC99.jpg" style="zoom:50%;" /></p>
<p><img src="https://i.loli.net/2021/04/14/bW1TgLGxdk7SpDm.jpg" alt="930EEC1CD39D6D844DFD3167F84CFBC4.jpg" style="zoom:50%;" /></p>
<p><img src="https://i.loli.net/2021/04/14/mLhfHUMIeXnO4rd.jpg" alt="3AF7BA7A091100A2732266480E846A0A.jpg" style="zoom:50%;" /></p>
<h4 id="4-解密过程"><a href="#4-解密过程" class="headerlink" title="4. 解密过程"></a>4. 解密过程</h4><p>​        由于DES是对合运算，所以解密和加密可共用同一个运算，只是子密钥使用的顺序不同。把64位密文当做明文输入，而且第一次解密迭代是用子密钥$K_{16}$，第十六次解密迭代使用子密钥$K_1$，最后的输出便是64位明文。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  DES算法</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by CharlesYan on 2021/4/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//16-wheel secret key structural body</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Secret_Key</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> subKey[<span class="number">56</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> C[<span class="number">28</span>];</span><br><span class="line">    <span class="keyword">int</span> D[<span class="number">28</span>];</span><br><span class="line">&#125;Secret_KeyOf16[<span class="number">17</span>];<span class="comment">//save the 16-wheel sercet key,and the zero flag in order to save the first substitution selection.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// save the process of encryption</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Encryption</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> select_Operation[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">int</span> secretKey_Operation[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">int</span> boxOf_S[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> L[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> R[<span class="number">32</span>];</span><br><span class="line">&#125;Encryption_Pro[<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result_Secret[<span class="number">64</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//substitution selection table 1(置换选择1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> subSelect_table1[<span class="number">56</span>] = &#123;</span><br><span class="line">    <span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>,<span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,</span><br><span class="line">    <span class="number">10</span>, <span class="number">2</span>,<span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>, <span class="number">3</span>,<span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,</span><br><span class="line">    <span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>, <span class="number">7</span>,<span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,</span><br><span class="line">    <span class="number">14</span>, <span class="number">6</span>,<span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>, <span class="number">5</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>, <span class="number">4</span></span><br><span class="line">   &#125;;</span><br><span class="line"><span class="comment">//substitution selection table 2(置换选择2)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> subSelect_table2[<span class="number">48</span>]=&#123;</span><br><span class="line"> <span class="number">14</span>,<span class="number">17</span>,<span class="number">11</span>,<span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">28</span>,<span class="number">15</span>, <span class="number">6</span>,<span class="number">21</span>,<span class="number">10</span>,</span><br><span class="line"> <span class="number">23</span>,<span class="number">19</span>,<span class="number">12</span>, <span class="number">4</span>,<span class="number">26</span>, <span class="number">8</span>,<span class="number">16</span>, <span class="number">7</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">13</span>, <span class="number">2</span>,</span><br><span class="line"> <span class="number">41</span>,<span class="number">52</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">55</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">51</span>,<span class="number">45</span>,<span class="number">33</span>,<span class="number">48</span>,</span><br><span class="line"> <span class="number">44</span>,<span class="number">49</span>,<span class="number">39</span>,<span class="number">56</span>,<span class="number">34</span>,<span class="number">53</span>,<span class="number">46</span>,<span class="number">42</span>,<span class="number">50</span>,<span class="number">36</span>,<span class="number">29</span>,<span class="number">32</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Move left shift bits table(循环左移位数表)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> moveLeft_table[<span class="number">17</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//initial substitution IP</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> init_subIP[<span class="number">64</span>] = &#123;</span><br><span class="line"><span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">10</span>, <span class="number">2</span>,<span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line"><span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">14</span>, <span class="number">6</span>,<span class="number">64</span>,<span class="number">56</span>,<span class="number">48</span>,<span class="number">40</span>,<span class="number">32</span>,<span class="number">24</span>,<span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line"><span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>,<span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>, <span class="number">5</span>,<span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>, <span class="number">7</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//selection operation E</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sel_E[<span class="number">48</span>] = &#123;</span><br><span class="line"><span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line"><span class="number">8</span>, <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,</span><br><span class="line"><span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,</span><br><span class="line"><span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">32</span>, <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Box of S 3D array</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> BoxOf_S[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>]=&#123;</span><br><span class="line"> <span class="comment">//S1</span></span><br><span class="line"> <span class="number">14</span>, <span class="number">4</span>,<span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>,<span class="number">10</span>, <span class="number">6</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>,</span><br><span class="line">  <span class="number">0</span>,<span class="number">15</span>, <span class="number">7</span>, <span class="number">4</span>,<span class="number">14</span>, <span class="number">2</span>,<span class="number">13</span>, <span class="number">1</span>,<span class="number">10</span>, <span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line">  <span class="number">4</span>, <span class="number">1</span>,<span class="number">14</span>, <span class="number">8</span>,<span class="number">13</span>, <span class="number">6</span>, <span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>,<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>,</span><br><span class="line"> <span class="number">15</span>,<span class="number">12</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>,<span class="number">11</span>, <span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>, <span class="number">0</span>, <span class="number">6</span>,<span class="number">13</span>,</span><br><span class="line"> <span class="comment">//S2</span></span><br><span class="line"> <span class="number">15</span>, <span class="number">1</span>, <span class="number">8</span>,<span class="number">14</span>, <span class="number">6</span>,<span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>,<span class="number">10</span>,</span><br><span class="line">  <span class="number">3</span>,<span class="number">13</span>, <span class="number">4</span>, <span class="number">7</span>,<span class="number">15</span>, <span class="number">2</span>, <span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>, <span class="number">0</span>, <span class="number">1</span>,<span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>,<span class="number">11</span>, <span class="number">5</span>,</span><br><span class="line">  <span class="number">0</span>,<span class="number">14</span>, <span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>, <span class="number">4</span>,<span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>,<span class="number">12</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>,<span class="number">15</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">8</span>,<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>,<span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>,<span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>,<span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>,<span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line"> <span class="comment">//S3</span></span><br><span class="line"> <span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>,<span class="number">14</span>, <span class="number">6</span>, <span class="number">3</span>,<span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>, <span class="number">7</span>,<span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>,<span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>, <span class="number">1</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>,<span class="number">15</span>, <span class="number">3</span>, <span class="number">0</span>,<span class="number">11</span>, <span class="number">1</span>, <span class="number">2</span>,<span class="number">12</span>, <span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>, <span class="number">7</span>,</span><br><span class="line">  <span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>, <span class="number">3</span>,<span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>,<span class="number">12</span>,</span><br><span class="line"> <span class="comment">//S4</span></span><br><span class="line">  <span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>,<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>, <span class="number">4</span>,<span class="number">15</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">8</span>,<span class="number">11</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">15</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>,<span class="number">12</span>, <span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line"> <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>, <span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>, <span class="number">1</span>, <span class="number">3</span>,<span class="number">14</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>,</span><br><span class="line">  <span class="number">3</span>,<span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>,<span class="number">10</span>, <span class="number">1</span>,<span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>, <span class="number">7</span>, <span class="number">2</span>,<span class="number">14</span>,</span><br><span class="line"> <span class="comment">//S5</span></span><br><span class="line">  <span class="number">2</span>,<span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>, <span class="number">0</span>,<span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line"> <span class="number">14</span>,<span class="number">11</span>, <span class="number">2</span>,<span class="number">12</span>, <span class="number">4</span>, <span class="number">7</span>,<span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line">  <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>,<span class="number">15</span>, <span class="number">9</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>,<span class="number">14</span>,</span><br><span class="line"> <span class="number">11</span>, <span class="number">8</span>,<span class="number">12</span>, <span class="number">7</span>, <span class="number">1</span>,<span class="number">14</span>, <span class="number">2</span>,<span class="number">13</span>, <span class="number">6</span>,<span class="number">15</span>, <span class="number">0</span>, <span class="number">9</span>,<span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>,</span><br><span class="line"> <span class="comment">//S6</span></span><br><span class="line"> <span class="number">12</span>, <span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>,<span class="number">13</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">14</span>, <span class="number">7</span>, <span class="number">5</span>,<span class="number">11</span>,</span><br><span class="line"> <span class="number">10</span>,<span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>,<span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>, <span class="number">0</span>,<span class="number">11</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line">  <span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>,<span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>,<span class="number">10</span>, <span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>, <span class="number">6</span>,</span><br><span class="line">     <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>,<span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>,<span class="number">13</span>,</span><br><span class="line"> <span class="comment">//S7</span></span><br><span class="line">  <span class="number">4</span>,<span class="number">11</span>, <span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>, <span class="number">0</span>, <span class="number">8</span>,<span class="number">13</span>, <span class="number">3</span>,<span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>,<span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">0</span>,<span class="number">11</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>, <span class="number">3</span>, <span class="number">5</span>,<span class="number">12</span>, <span class="number">2</span>,<span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line">  <span class="number">1</span>, <span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line">  <span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>,<span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">12</span>,</span><br><span class="line"> <span class="comment">//S8</span></span><br><span class="line"> <span class="number">13</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>, <span class="number">1</span>,<span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>,<span class="number">14</span>, <span class="number">5</span>, <span class="number">0</span>,<span class="number">12</span>, <span class="number">7</span>,</span><br><span class="line">  <span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>, <span class="number">8</span>,<span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">11</span>, <span class="number">0</span>,<span class="number">14</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line">  <span class="number">7</span>,<span class="number">11</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">  <span class="number">2</span>, <span class="number">1</span>,<span class="number">14</span>, <span class="number">7</span>, <span class="number">4</span>,<span class="number">10</span>, <span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">11</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//substitution IP</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> P_Table[<span class="number">32</span>]=&#123;</span><br><span class="line"> <span class="number">16</span>, <span class="number">7</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">29</span>,<span class="number">12</span>,<span class="number">28</span>,<span class="number">17</span>, <span class="number">1</span>,<span class="number">15</span>,<span class="number">23</span>,<span class="number">26</span>, <span class="number">5</span>,<span class="number">18</span>,<span class="number">31</span>,<span class="number">10</span>,</span><br><span class="line">  <span class="number">2</span>, <span class="number">8</span>,<span class="number">24</span>,<span class="number">14</span>,<span class="number">32</span>,<span class="number">27</span>, <span class="number">3</span>, <span class="number">9</span>,<span class="number">19</span>,<span class="number">13</span>,<span class="number">30</span>, <span class="number">6</span>,<span class="number">22</span>,<span class="number">11</span>, <span class="number">4</span>,<span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> IPR_Table[<span class="number">64</span>]=&#123;</span><br><span class="line"> <span class="number">40</span>, <span class="number">8</span>,<span class="number">48</span>,<span class="number">16</span>,<span class="number">56</span>,<span class="number">24</span>,<span class="number">64</span>,<span class="number">32</span>,<span class="number">39</span>, <span class="number">7</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">55</span>,<span class="number">23</span>,<span class="number">63</span>,<span class="number">31</span>,</span><br><span class="line"> <span class="number">38</span>, <span class="number">6</span>,<span class="number">46</span>,<span class="number">14</span>,<span class="number">54</span>,<span class="number">22</span>,<span class="number">62</span>,<span class="number">30</span>,<span class="number">37</span>, <span class="number">5</span>,<span class="number">45</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">21</span>,<span class="number">61</span>,<span class="number">29</span>,</span><br><span class="line"> <span class="number">36</span>, <span class="number">4</span>,<span class="number">44</span>,<span class="number">12</span>,<span class="number">52</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">28</span>,<span class="number">35</span>, <span class="number">3</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">19</span>,<span class="number">59</span>,<span class="number">27</span>,</span><br><span class="line"> <span class="number">34</span>, <span class="number">2</span>,<span class="number">42</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">18</span>,<span class="number">58</span>,<span class="number">26</span>,<span class="number">33</span>, <span class="number">1</span>,<span class="number">41</span>, <span class="number">9</span>,<span class="number">49</span>,<span class="number">17</span>,<span class="number">57</span>,<span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Convert an 8-byte key or plaintext to 64-bit binary</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">ChangeToBit</span><span class="params">(<span class="keyword">char</span> code[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//Subfunction：change Byte to 8-bit binary</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">Change_bit</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="comment">//create 16-wheel secret key and save them to Secret_KeyOf16</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_16wheelKey</span><span class="params">(<span class="keyword">int</span> *bit_SecretKey)</span></span>;</span><br><span class="line"><span class="comment">//the first step of encryption,set R0, as we know, we will not need L0 later.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first_StepEncryption</span><span class="params">(<span class="keyword">int</span> *bit_PlainText)</span></span>;</span><br><span class="line"><span class="comment">//encryption, return the result of encryption</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_StepEncrtption</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//Box of S operation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Box_operation</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// Box of S change byte to bit</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">Change_bit_S</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="comment">//IPR_table operation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPR_Operation</span><span class="params">(<span class="keyword">int</span> result[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pri_ChangeToByte</span><span class="params">(<span class="keyword">int</span> secretKey[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> my_Plaintext[<span class="number">9</span>] = &#123;&#125;;<span class="comment">//save plaintext and the last one is &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> my_SecretKey[<span class="number">9</span>] = &#123;&#125;;<span class="comment">//save secretkey</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input the plaintext of 8 byte:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin.<span class="built_in">get</span>(my_Plaintext,<span class="number">9</span>);</span><br><span class="line">    cin.<span class="built_in">get</span>();<span class="comment">// getchar();</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input the secret key of 8 byte&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin.<span class="built_in">get</span>(my_SecretKey,<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//8-byte SecretKey turn into 64-bit binary</span></span><br><span class="line">    <span class="keyword">int</span> *bit_SecretKey = <span class="built_in">ChangeToBit</span>(my_SecretKey, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">//create 16-wheel secret key.</span></span><br><span class="line">    <span class="built_in">set_16wheelKey</span>(bit_SecretKey);</span><br><span class="line">    <span class="comment">//8-byte SecretKey turn into 64-bit binary</span></span><br><span class="line">    <span class="keyword">int</span> *bit_Plaintext = <span class="built_in">ChangeToBit</span>(my_Plaintext, <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Encryption</span></span><br><span class="line">    <span class="built_in">first_StepEncryption</span>(bit_Plaintext);</span><br><span class="line">    <span class="built_in">other_StepEncrtption</span>(<span class="number">0</span>);<span class="comment">//the 0 is meant encryption</span></span><br><span class="line">    <span class="built_in">IPR_Operation</span>(result_Secret);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Decryption</span></span><br><span class="line">    <span class="built_in">first_StepEncryption</span>(result_Secret);</span><br><span class="line">    <span class="built_in">other_StepEncrtption</span>(<span class="number">1</span>);<span class="comment">//the 1 is meant decryption.</span></span><br><span class="line">    <span class="built_in">IPR_Operation</span>(result_Secret);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Pri_ChangeToByte</span>(result_Secret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">ChangeToBit</span><span class="params">(<span class="keyword">char</span> code[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> BinaryText[<span class="number">64</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> *temp =<span class="built_in">Change_bit</span>(code[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            BinaryText[k++] = temp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BinaryText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">Change_bit</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> flag[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">while</span> (a/<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">        flag[k--] = a % <span class="number">2</span>;</span><br><span class="line">        a = a / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">Change_bit_S</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> flag[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a/<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">        flag[k++] = a % <span class="number">2</span>;</span><br><span class="line">        a = a / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">    flag[k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_16wheelKey</span><span class="params">(<span class="keyword">int</span> *bit_SecretKey)</span></span>&#123;</span><br><span class="line">    <span class="comment">//substitution selection 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">56</span>; i++) &#123;</span><br><span class="line">        Secret_KeyOf16[<span class="number">0</span>].subKey[i] = bit_SecretKey[subSelect_table1[i]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//C0 D0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">28</span>; i++) &#123;</span><br><span class="line">        Secret_KeyOf16[<span class="number">0</span>].C[i] = Secret_KeyOf16[<span class="number">0</span>].subKey[i];</span><br><span class="line">        Secret_KeyOf16[<span class="number">0</span>].D[i] = Secret_KeyOf16[<span class="number">0</span>].subKey[i+<span class="number">28</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;<span class="number">17</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(moveLeft_table[i] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">27</span>; j++) &#123;</span><br><span class="line">            Secret_KeyOf16[i].C[j] = Secret_KeyOf16[i<span class="number">-1</span>].C[j+<span class="number">1</span>];</span><br><span class="line">            Secret_KeyOf16[i].D[j] = Secret_KeyOf16[i<span class="number">-1</span>].D[j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Secret_KeyOf16[i].C[<span class="number">27</span>] = Secret_KeyOf16[i<span class="number">-1</span>].C[<span class="number">0</span>];</span><br><span class="line">        Secret_KeyOf16[i].D[<span class="number">27</span>] = Secret_KeyOf16[i<span class="number">-1</span>].D[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">26</span>; j++) &#123;</span><br><span class="line">                Secret_KeyOf16[i].C[j] = Secret_KeyOf16[i<span class="number">-1</span>].C[j+<span class="number">2</span>];</span><br><span class="line">                Secret_KeyOf16[i].D[j] = Secret_KeyOf16[i<span class="number">-1</span>].D[j+<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            Secret_KeyOf16[i].C[<span class="number">26</span>] = Secret_KeyOf16[i<span class="number">-1</span>].C[<span class="number">0</span>];</span><br><span class="line">            Secret_KeyOf16[i].C[<span class="number">27</span>] = Secret_KeyOf16[i<span class="number">-1</span>].C[<span class="number">1</span>];</span><br><span class="line">            Secret_KeyOf16[i].D[<span class="number">26</span>] = Secret_KeyOf16[i<span class="number">-1</span>].D[<span class="number">0</span>];</span><br><span class="line">            Secret_KeyOf16[i].D[<span class="number">27</span>] = Secret_KeyOf16[i<span class="number">-1</span>].D[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//subKey1 ... subKey16</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">17</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag[<span class="number">56</span>] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">28</span>; j++) &#123;</span><br><span class="line">            flag[j] = Secret_KeyOf16[i].C[j];</span><br><span class="line">            flag[j+<span class="number">28</span>] = Secret_KeyOf16[i].D[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">48</span>; j++) &#123;</span><br><span class="line">            Secret_KeyOf16[i].subKey[j] = flag[subSelect_table2[j]<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print the result of secret key.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">17</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;N = %d\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C%d：&quot;</span>,i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">28</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Secret_KeyOf16[i].C[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;D%d：&quot;</span>,i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">28</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Secret_KeyOf16[i].D[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子密钥%d：&quot;</span>,i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">48</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">8</span> == <span class="number">0</span> &amp;&amp; j) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Secret_KeyOf16[i].subKey[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first_StepEncryption</span><span class="params">(<span class="keyword">int</span> *bit_PlainText)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">        Encryption_Pro[<span class="number">0</span>].L[i] = bit_PlainText[init_subIP[i]<span class="number">-1</span>];</span><br><span class="line">        Encryption_Pro[<span class="number">0</span>].R[i] = bit_PlainText[init_subIP[i+<span class="number">32</span>]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_StepEncrtption</span><span class="params">(<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">17</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">48</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//selection</span></span><br><span class="line">            Encryption_Pro[i].select_Operation[j] = Encryption_Pro[i<span class="number">-1</span>].R[sel_E[j]<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//secretion operation</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">            Encryption_Pro[i].secretKey_Operation[j] =Secret_KeyOf16[i].subKey[j]^Encryption_Pro[i].select_Operation[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Encryption_Pro[i].secretKey_Operation[j] =Secret_KeyOf16[<span class="number">17</span>-i].subKey[j]^Encryption_Pro[i].select_Operation[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Box of S</span></span><br><span class="line">        <span class="built_in">Box_operation</span>(Encryption_Pro[i].secretKey_Operation,i);</span><br><span class="line">        <span class="comment">// XOR operation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">32</span>; j++) &#123;</span><br><span class="line">            Encryption_Pro[i].L[j] = Encryption_Pro[i<span class="number">-1</span>].R[j];</span><br><span class="line">            Encryption_Pro[i].R[j] = Encryption_Pro[i<span class="number">-1</span>].L[j]^Encryption_Pro[i].boxOf_S[P_Table[j]<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Box_operation</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">48</span>; i += <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag1 = BoxOf_S[i/<span class="number">6</span>][a[i]*<span class="number">2</span>+a[i+<span class="number">5</span>]][a[i+<span class="number">1</span>]*<span class="number">8</span>+a[i+<span class="number">2</span>]*<span class="number">4</span>+a[i+<span class="number">3</span>]*<span class="number">2</span>+a[i+<span class="number">4</span>]];</span><br><span class="line">        <span class="keyword">int</span> flag[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag1/<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            flag[k++] = flag1 % <span class="number">2</span>;</span><br><span class="line">            flag1 = flag1 / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1 == <span class="number">1</span>)</span><br><span class="line">        flag[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            Encryption_Pro[n].boxOf_S[sum++] = flag[j];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPR_Operation</span><span class="params">(<span class="keyword">int</span> result[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">64</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span> ; i++) &#123;</span><br><span class="line">        temp[i] = Encryption_Pro[<span class="number">16</span>].R[i];</span><br><span class="line">        temp[<span class="number">32</span>+i] = Encryption_Pro[<span class="number">16</span>].L[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        result[i] = temp[IPR_Table[i]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">17</span> ; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nN = %d\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;选择运算：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">48</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">8</span> == <span class="number">0</span> &amp;&amp; j) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Encryption_Pro[i].select_Operation[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n子密钥加：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">48</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">8</span> == <span class="number">0</span> &amp;&amp; j) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Encryption_Pro[i].secretKey_Operation[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nS盒：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">32</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">8</span> == <span class="number">0</span> &amp;&amp; j) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Encryption_Pro[i].boxOf_S[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nL：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">32</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">8</span> == <span class="number">0</span> &amp;&amp; j) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Encryption_Pro[i].L[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nR：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">32</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">8</span> == <span class="number">0</span> &amp;&amp; j) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Encryption_Pro[i].R[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;the result of secret text: &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;the result of plain text: &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">8</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result_Secret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pri_ChangeToByte</span><span class="params">(<span class="keyword">int</span> secretKey[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">64</span>; i+=<span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j&lt;i+<span class="number">8</span>; j++) &#123;</span><br><span class="line">            sum += secretKey[j] * <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">7</span>-j%<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        temp[k++] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the plaintext of 8 byte is :&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,temp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>密码学实验</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/27/%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><p><strong>问题描述：</strong>假设有n个任务由k个可并行工作的机器完成。完成任务i需要的时间为ti ,试设计一个算法找出完成这n个任务的最佳调度，使得完成全部任务的时间最早；</p>
<p><strong>数据输入：</strong>第一行有2个正整数n和k，第二行的n个正整数是完成n个任务需要的</p>
<p>时间；</p>
<p><strong>数据输出：</strong>将计算的完成全部任务的最早时间输出；</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">14</span> <span class="number">4</span> <span class="number">16</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>
<p><strong>题解：</strong>n个任务，分配给k台机器，总需要的时间最短，分支限界法其实是穷举法加剪枝函数，我们的函数用到递归，层层返回。一共七层，每层的除去叶子节点都有三个孩子，每搜索到叶子节点就更新一次maxnum值（小于maxnum则更新）（初值为一个较大的数），是用一次搜索结束后三个机器中花费时间最长的机器的所用时间作为此次分配的所用时间。</p>
<p>一个任务存在n种状态，即选择被哪台机器所完成，程序分为两部分，上半部分是赋值，下半部分是剪枝，不断把符合条件的值往优先队列里整，并且通过循环，不断优化结果。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">100</span>];<span class="comment">//机器</span></span><br><span class="line"><span class="keyword">int</span> x1[<span class="number">100</span>];<span class="comment">//作业</span></span><br><span class="line"><span class="keyword">int</span> maxnum=<span class="number">1000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level&gt;n)&#123;</span><br><span class="line">     <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]&gt;temp)&#123;</span><br><span class="line">            temp=x[i];</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(temp&lt;maxnum)&#123;</span><br><span class="line">        maxnum=temp;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            x[i]+=x1[level];</span><br><span class="line">            <span class="built_in">task</span>(level+<span class="number">1</span>);</span><br><span class="line">            x[i]-=x1[level];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt;x1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; maxnum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/30/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><h3 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h3><h4 id="1-什么是回溯法"><a href="#1-什么是回溯法" class="headerlink" title="1. 什么是回溯法"></a>1. 什么是回溯法</h4><ul>
<li>可以系统的搜索一个问题的所有解或者任意解，他是一个既带有系统性又带有跳跃性的搜索算法。</li>
<li>回溯法求问题的一个解时，只要搜索到问题的一个解就可以结束。</li>
</ul>
<h4 id="2-回溯法思想"><a href="#2-回溯法思想" class="headerlink" title="2. 回溯法思想"></a>2. 回溯法思想</h4><ul>
<li>针对所给问题，定义问题的解空间。</li>
<li>确定易于搜索的解空间结构</li>
<li>以深度有线方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索（<strong>剪枝函数：</strong> 用约束函数在扩展节点处减去不满足约束的子树，用限界函数剪去得不到最优解的子树。）</li>
</ul>
<h4 id="3-回溯设计策略"><a href="#3-回溯设计策略" class="headerlink" title="3. 回溯设计策略"></a>3. 回溯设计策略</h4><div class="table-container">
<table>
<thead>
<tr>
<th>装载问题</th>
<th>批处理作业调度</th>
</tr>
</thead>
<tbody>
<tr>
<td>符号三角形问题</td>
<td>n后问题</td>
</tr>
<tr>
<td>0-1背包问题</td>
<td>图的m着色问题</td>
</tr>
<tr>
<td>最大团问题</td>
<td>旅行售货员问题</td>
</tr>
<tr>
<td>电路板排列问题</td>
<td>圆排列问题</td>
</tr>
<tr>
<td>电路板排列问题</td>
<td>连续邮资问题</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-算法框架"><a href="#4-算法框架" class="headerlink" title="4. 算法框架"></a>4. 算法框架</h4><ul>
<li>递归回溯</li>
<li>迭代回溯</li>
<li>子集树算法框架</li>
<li>排列树算法框架</li>
</ul>
<h4 id="1-装载问题"><a href="#1-装载问题" class="headerlink" title="1. 装载问题"></a>1. 装载问题</h4><p>当前载重量cw+剩余集装箱的重量r小于等于点前最优载重量bestw</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="comment">//搜索第i层结点</span></span><br><span class="line">  <span class="keyword">if</span>(i&lt;n)<span class="comment">//到达叶结点 </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//更新最优解</span></span><br><span class="line">  r -=w[i];</span><br><span class="line">  <span class="keyword">if</span>(cw + w[i] &lt;= c)&#123;<span class="comment">//搜索左子树</span></span><br><span class="line">    x[i] = <span class="number">1</span>;</span><br><span class="line">    cw += w[i];</span><br><span class="line">    <span class="built_in">backtrcak</span>(i+<span class="number">1</span>);</span><br><span class="line">    cw -= w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cw + r &gt;bestw)&#123;</span><br><span class="line">    x[i] = <span class="number">0</span>;<span class="comment">//搜索右子树</span></span><br><span class="line">    <span class="built_in">backtrack</span>(i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  r += w[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bestx 目前得到的最优解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maxloading</span><span class="params">(<span class="keyword">int</span> w[],<span class="keyword">int</span> c,<span class="keyword">int</span> n,<span class="keyword">int</span> bestx[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//当前层 x[1:x-1]为当前路径</span></span><br><span class="line">  <span class="keyword">int</span> *x = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> bestw = <span class="number">0</span>,cw = <span class="number">0</span>,r = <span class="number">0</span>;<span class="comment">//当前最优值放在cw</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    r+=w[j];<span class="comment">//求所有的集装箱总和</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n &amp;&amp; cw + w[i]&lt;=c)&#123;</span><br><span class="line">      r -= w[i];</span><br><span class="line">      cw += w[i];</span><br><span class="line">      x[i] = <span class="number">1</span>;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        bestx[j] = x[j];</span><br><span class="line">      bestw = cw;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r -= w[i];</span><br><span class="line">      x[i] = <span class="number">0</span>;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cw+r &lt;= bestw)&#123;</span><br><span class="line">      i--;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; !x[i])&#123;<span class="comment">//从右子树返回</span></span><br><span class="line">        r += w[i];</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> []x;</span><br><span class="line">        <span class="keyword">return</span> bestw;</span><br><span class="line">      &#125;</span><br><span class="line">      x[i] = <span class="number">0</span>;</span><br><span class="line">      cw -= w[i];<span class="comment">//进入右子树</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、批处理作业调度"><a href="#2、批处理作业调度" class="headerlink" title="2、批处理作业调度"></a>2、批处理作业调度</h4><p><strong>问题描述：</strong>给定n个作业集合</p>
<p><strong>5-1 子集合问题：</strong> 子集合问题的一个实例为$<S,t>$。其中$S = {x<em>1,x_2,…,x_n}$是一个正整数的集合，c是一个正整数。子集合问题判定是否存在S的一个子集$S_1$，使得$\sum</em>{x\in{S1}}x = c$。试设计一个解子集和问题的回溯法。</p>
<p><strong>数据输入：</strong>第一行有两个正整数$n,c$，n表示S的大小，c是子集和的目标值。接下来的一行中，有n个正整数，表示集合S中的元素。</p>
<p><strong>结果输出：</strong> 将子集和问题的解输出，当问题无解时，输出“No Solution!”。</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">6</span> </span><br></pre></td></tr></table></figure>
<p><strong>题解：</strong></p>
<p>5-3 </p>
<p>5-6</p>
<p>5-13</p>
]]></content>
  </entry>
  <entry>
    <title>算法设计与分析之贪心算法</title>
    <url>/2020/11/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%E5%8A%A0%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="贪心算法（算法理解加经典例题解析）"><a href="#贪心算法（算法理解加经典例题解析）" class="headerlink" title="贪心算法（算法理解加经典例题解析）"></a>贪心算法（算法理解加经典例题解析）</h3><h3 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h3><h4 id="1-什么是贪心算法？"><a href="#1-什么是贪心算法？" class="headerlink" title="1. 什么是贪心算法？"></a>1. 什么是贪心算法？</h4><ul>
<li><p>顾名思义，总是在作出当前看来最好的选择。</p>
</li>
<li><p>并不从整体最优考虑，只是某种程度上的局部最优选择。</p>
</li>
<li><p>不一定是最优解，但往往是最接近最优解的。</p>
</li>
</ul>
<h4 id="2-贪心设计策略"><a href="#2-贪心设计策略" class="headerlink" title="2. 贪心设计策略"></a>2. 贪心设计策略</h4><ol>
<li>活动安排问题</li>
<li>最优装载问题</li>
<li>哈夫曼编码</li>
<li>单源最短路径</li>
<li>最小生成树</li>
<li>多机调度问题</li>
</ol>
<h4 id="3-贪心选择性质"><a href="#3-贪心选择性质" class="headerlink" title="3. 贪心选择性质"></a>3. 贪心选择性质</h4><ol>
<li><p>贪心算法通常自顶向下的方式进行</p>
</li>
<li><p>最优子结构性质</p>
</li>
</ol>
<h3 id="二、习题解析"><a href="#二、习题解析" class="headerlink" title="二、习题解析"></a>二、习题解析</h3><h4 id="1-会场安排问题"><a href="#1-会场安排问题" class="headerlink" title="1. 会场安排问题"></a>1. 会场安排问题</h4><p><strong>题目：</strong> 假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。设计一个有效的贪心算法进行安排。（这个问题实际上是著名的图着色问题。若将每个活动作为一个图的顶点，不相容活动间用边相连。使相邻顶点着有不同颜色的最小着色数，相当于要找的最小会场数。）</p>
<p><strong>数据输入：</strong> 第一行有一个正整数$k$ ，表示有$k$ 个待安排的活动，接下来的$k$ 行中，每行有2个正整数，分别表示$k$ 个待安排的活动屁那个的开始时间和结束时间。时间以0点开始的分钟计。</p>
<p><strong>结果输出：</strong> 将计算的最少会场数输出</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">23</span></span><br><span class="line"><span class="number">12</span> <span class="number">28</span></span><br><span class="line"><span class="number">25</span> <span class="number">35</span></span><br><span class="line"><span class="number">27</span> <span class="number">80</span></span><br><span class="line"><span class="number">36</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>1.题解：</strong> 这里采用贪心策略，每一步最优，即下一个会议的开始时间大于等于之前任意一个会议的结束时间，那么这两个会议可以安排在同一个会议室。如果该会议开始了，但是之前的会议都还没有结束，那么就另起一个会议室。</p>
<p>需要注意的是，当两个会议安排在同一个会议室时，那么下次判断时间的时候要以后者的会议结束时间为准，要将前者的会议时间覆盖。</p>
<p>在这里，用到的会议室总数用$num$记录，$flag$记录的是第$i$个会议用在哪个会议室（更新）</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//会场安排问题，贪心策略，每一步最优</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meeting</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> start;</span><br><span class="line">	<span class="keyword">int</span> end;</span><br><span class="line">&#125;m[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//记录会场个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin&gt;&gt;m[i].start;</span><br><span class="line">		cin&gt;&gt;m[i].end;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">1</span>;<span class="comment">//会场个数</span></span><br><span class="line">	flag[start] = num;<span class="comment">//在哪个会场开会</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = start;j&lt;i;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (m[j].end&lt;=m[i].start &amp;&amp; flag[j]) &#123;</span><br><span class="line">			flag[i] = flag[j];</span><br><span class="line">			flag[j] = <span class="number">0</span>;</span><br><span class="line">			temp = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">			num++;</span><br><span class="line">			flag[i] = num;</span><br><span class="line">		&#125;<span class="keyword">else</span> temp = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-最优合并问题"><a href="#2-最优合并问题" class="headerlink" title="2. 最优合并问题"></a>2. 最优合并问题</h4><p><strong>题目：</strong> 给定$k$个排好序的序列$s1,s2,…,sk$，用$2$路合并算法将这$k$个序列合并成一个序列。假设所采用的2路合并算法合并两个长度分别为$m$和$n$的序列需要$m+n-1$次比较。试设计一个算法确定合并这个序列的最优合并顺序，使所需要的总比较次数最少。 </p>
<p><strong>数据输入：</strong> 第一行有一个正整数$k$，表示有$k$个待合并序列。接下来的一行中，有$k$个正整数，表示个待合并序列的长度。</p>
<p><strong>数据输出：</strong> 将计算的最多比较次数和最少比较次数输出</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">12</span> <span class="number">11</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">78</span> <span class="number">52</span></span><br></pre></td></tr></table></figure>
<p><strong>2.题解：</strong> 贪心策略，局部最优考虑。比较一次需要$m+n-1$次，那么对于最少比较次数 ，每一个都使m，n是最小的两个值，对于例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>当前序列</th>
<th>合并</th>
<th>总和</th>
<th>剩余序列</th>
</tr>
</thead>
<tbody>
<tr>
<td>2,5,11,12</td>
<td>2+5 = 7</td>
<td>2+5-1 = 6</td>
<td>7,11,12</td>
</tr>
<tr>
<td>7,11,12</td>
<td>7+11 = 18</td>
<td>6+18-1 = 23</td>
<td>12,18</td>
</tr>
<tr>
<td>12,18</td>
<td>12+18 = 30</td>
<td>23+30-1 = 52</td>
<td>30</td>
</tr>
</tbody>
</table>
</div>
<p>同理最大比较次数与之相反。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 最优升序比较</span></span><br><span class="line"><span class="comment">2. 最差降序比较</span></span><br><span class="line"><span class="comment">贪心策略，每一步最优</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//序列个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;<span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Huffman</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">		a[i+<span class="number">1</span>] = a[i]+a[i+<span class="number">1</span>];</span><br><span class="line">		sum += a[i+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1000</span>] = &#123;&#125;;<span class="comment">//升序</span></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">1000</span>] = &#123;&#125;;<span class="comment">//降序</span></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123; </span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		b[i] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//排序---最优</span></span><br><span class="line">	<span class="built_in">sort</span>(a, a+n);<span class="comment">//升序</span></span><br><span class="line">	<span class="built_in">sort</span>(b, b+n,cmp);</span><br><span class="line">	cout&lt;&lt;<span class="built_in">Huffman</span>(a, n)-n+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">Huffman</span>(b, n)-n+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-最优服务次序问题"><a href="#3-最优服务次序问题" class="headerlink" title="3. 最优服务次序问题"></a>3. 最优服务次序问题</h4><p><strong>题目：</strong> 设有$n$个顾客同时等待一项服务，顾客$i$需要的服务时间为$t_i(1\leq i \leq n  )$。应该如何安排n个顾客的服务次序才能使平均等待时间达到最小？平均等待时间是n个顾客等待服务时间的总和除以$n$。</p>
<p><strong>数据输入：</strong> 第一行正整数$n$，表示有$n$个顾客。接下来的1行中，有$n$个正整数，表示n个顾客需要的服务时间。</p>
<p><strong>结果输出：</strong> 将计算的最小平均等待时间输出。</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">56</span> <span class="number">12</span> <span class="number">1</span> <span class="number">99</span> <span class="number">1000</span> <span class="number">234</span> <span class="number">33</span> <span class="number">55</span> <span class="number">99</span> <span class="number">812</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">532.00</span></span><br></pre></td></tr></table></figure>
<p><strong>3.题解：</strong> 贪心策略，最短服务时间优先，在人数一定时，总的等待时间越短，平均时间也就越短，因此，现将所有顾客等待时间进行升序排列，然后求和。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//最优服务次序问题，贪心策略，即最短服务时间优先，类似于最优合并排序</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Huffman</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) a[i] += a[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">double</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) t += a[i];</span><br><span class="line">	t /= n;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n);<span class="comment">//升序排列</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">Huffman</span>(a, n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-虚拟汽车加油站问题"><a href="#4-虚拟汽车加油站问题" class="headerlink" title="4. 虚拟汽车加油站问题"></a>4. 虚拟汽车加油站问题</h4><p><strong>问题描述：</strong> 一辆虚拟汽车加满油后可行驶$nkm$。旅途中有若干加油站。设计一个有效算法，指出应在哪些加油站停靠加油，使沿途加油次数最少。并证明算法能产生一个最优解。</p>
<p><strong>数据输入：</strong> 第一行有2个正整数$n$和$k$，表示汽车加满油后可行驶$nkm$，且旅途中有$k$个加油站。接下来的1行中有$k+1$个整数，表示第$k$个加油站与第$k-1$个加油站之间的距离。第0个加油站表示出发地，汽车已加满油。第$k+1$个加油站表示目的地。</p>
<p><strong>数据输出：</strong> 将计算的最少加油次数输出。</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>4.题解：</strong> 贪心策略，最远加油站优先，从前往后走，每一次都计算出最远能到达的加油站。由局部最优解最终算出全局最优解</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//贪心策略，最远加油站优先</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>,s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=k;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; n) &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;ERROR!&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; k;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&gt;= a[i]+a[i+<span class="number">1</span>]) &#123;</span><br><span class="line">			a[i+<span class="number">1</span>] += a[i];</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			sum++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1000</span>] = &#123;&#125;;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	cout&lt;&lt;<span class="built_in">greedy</span>(a,n,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-最优分解问题"><a href="#5-最优分解问题" class="headerlink" title="5. 最优分解问题"></a>5. 最优分解问题</h4><p><strong>问题描述：</strong> 设n是一个正整数。现要求将n分解为若干互不相同的自然数的和，且使这些自然数的乘积最大。</p>
<p><strong>数据输入：</strong> 第一行正整数n</p>
<p><strong>结果输出：</strong> 将计算的最大乘积输出</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<p><strong>5.题解：</strong> 将n分成从2开始的连续自然数的和，如果最后剩下一个数，将此数在后项优先的方式下均匀的地分给前面各项。对于10，可以分成2，3，4最后还剩1，以后项优先的方式分配，所以就是2，3，5。结果就是$(2\times3\times5 = 30)$  </p>
<p>原理：在固定总和数的情况下，两个数相差越小，乘积越大，因数越多，乘积越大。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//最优分解问题</span></span><br><span class="line"><span class="comment">//贪心算法：将n分解为以2开始连续自然数之和</span></span><br><span class="line"><span class="comment">//原理：在固定总和数的情况下，两个数相差越小，乘积越大，因数越多，乘积越大。</span></span><br><span class="line"><span class="comment">//几何意义解释：固定周长，正方形面积大于长方形</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1000</span>] = &#123;&#125;;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	n -= a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; ;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n &gt;= a[i]+<span class="number">1</span>)&#123;</span><br><span class="line">		a[i+<span class="number">1</span>] = a[i]+<span class="number">1</span>;</span><br><span class="line">		n = n - a[i+<span class="number">1</span>];</span><br><span class="line">	  &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">int</span> t = i;<span class="comment">//保存最后一位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = n;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(t) a[t--] += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			a[t] += <span class="number">1</span>;</span><br><span class="line">			t = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//求乘积</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=i;j++) sum = sum * a[j];</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">maxArea</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法分析与设计</category>
      </categories>
      <tags>
        <tag>上课笔记 - 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析之动态规划</title>
    <url>/2020/11/14/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="算法设计与分析之动态规划"><a href="#算法设计与分析之动态规划" class="headerlink" title="算法设计与分析之动态规划"></a>算法设计与分析之动态规划</h2><h3 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h3><h4 id="1-什么是动态规划算法"><a href="#1-什么是动态规划算法" class="headerlink" title="1. 什么是动态规划算法"></a>1. 什么是动态规划算法</h4><p>动态规划算法与分治法类似，其基本思想是将待求问题分解成若干个子问题，先求子问题，再结合这些子问题的解得到原问题的解，与分治法不同的是，动态规划会将前面求得的子问题的解保存在一个表中，在需要时用到以求得的答案，这样避免了重复的大量计算。</p>
<h4 id="2-动态规划的步骤"><a href="#2-动态规划的步骤" class="headerlink" title="2. 动态规划的步骤"></a>2. 动态规划的步骤</h4><ol>
<li>找出最优解的性质，并刻画其结构特征。</li>
<li>递归的定义最优值。</li>
<li><p>自底向上的方式计算最优值。</p>
</li>
<li><p>根据计算最优值时得到的信息，构造最优解。</p>
</li>
</ol>
<h4 id="3-动态规划算法的基本要素"><a href="#3-动态规划算法的基本要素" class="headerlink" title="3. 动态规划算法的基本要素"></a>3. 动态规划算法的基本要素</h4><ol>
<li><strong>最优子结构性质</strong>：问题的最优解包含子问题的最优解，反过来说，我们可以通过子问题的最优解求出问题的最优解。也可以理解为，后面的状态可以通过前面的状态推到出来。</li>
<li><strong>重叠子问题性质</strong>：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态</li>
</ol>
<h3 id="二、习题以及解析"><a href="#二、习题以及解析" class="headerlink" title="二、习题以及解析"></a>二、习题以及解析</h3><h4 id="1-独立任务最优调度问题"><a href="#1-独立任务最优调度问题" class="headerlink" title="1. 独立任务最优调度问题"></a>1. 独立任务最优调度问题</h4><p><strong>题目：</strong> 用2台处理机$A$和$B$处理$n$个作业。设第i个作业交给机器A处理时需要时间$a_i$,若由机器B来处理，则需要时间$b_i$。由于各作业的特点和机器的性能关系，很可能对于某些$i$ ,有$a_i\geq b_i$ ，而对于某些$j$ ，$j\neq i$ 有$a_j&gt;b_j$ 。既不能将一个作业分开由两台机器处理，也没有一台机器能同时处理2个作业。设计一个动态规划算法，使得这2台机器处理完这$n$个作业时间最短（从任何一台机器开弓到最后一台机器停工的总时间）。研究一个实例：$(a_1,a_2,a_3,a_4,a_6) = (2,5,7,10,5,2),(b_1,b_2,b_3,b_4,b_5,b_6) = (3,8,4,11,3,4)$。</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">7</span> <span class="number">10</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">11</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p><strong>1.题解：</strong>利用dp存储每个状态的结果，最后选出最优的一个解。转换方程：$dp[i][j]=min(dp[i-1][j]+b[i],dp[i-1][j-a[i]]);dp[i][j]$代表做完前i个任务，A机器花几分钟情况下，B机器所花的时间，也就是说$dp[i][j]$就是表示B机器所花时间。</p>
<p>$dp[i][j] = dp[i-1][j]+b[i]$代表第i个任务交给B来做，所以做完前i个任务的时候,A机器和前$i - 1$的任务一样，还是花了j分钟，而B机器则花$dp[i-1][j]+b[i]$分钟；</p>
<p>$dp[i][j] = dp[i-1][j-a[i]]$代表第i个任务交给A来做，现在的A机器花费时间是j，所以在前$i - 1$个任务完成的时候，A机器是花了$j-a[i]$分钟的，所以现在B机器还是花了$dp[i-1][j-a[i]]$分钟；</p>
<p>一直到$dp[n][i]$:代表所有的任务都做完了，B机器所花费的时间，那么最迟的时间就是B的时间和A的时间求最大值；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=sum; i++)</span><br><span class="line">  ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(dp[n][i],i));<span class="comment">//max(dp[n][i],i)</span></span><br></pre></td></tr></table></figure>
<p>表示完成前n个作业A机器花i分钟 B机器花$dp[n][i]$分钟情况下，最迟完工时间 </p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">201</span>], b[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">202</span>][<span class="number">10000</span>];<span class="comment">//dp[i][j] 表示前i个作业中A机器花j分钟的时候 B机器所花时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin&gt;&gt;b[i];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=sum; j++) &#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+b[i];<span class="comment">//dp[i-1][j]中对a的时间分配已经分配好，无需在判断a，直接添加b[i]的时间。</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=a[i]) dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+b[i],dp[i<span class="number">-1</span>][j-a[i]]);<span class="comment">//当时间超过当前a[i] 就需要判断是否需要更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">999999</span>;</span><br><span class="line">    <span class="comment">//max(dp[n][i],i) 表示完成前n个作业A机器花i分钟 B机器花dp[n][i]分钟情况下，最迟完工时间，最后一个机器完成才算最终完成。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=sum; i++)ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(dp[n][i],i));</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-最优批处理问题"><a href="#2-最优批处理问题" class="headerlink" title="2. 最优批处理问题"></a>2. 最优批处理问题</h4><p><strong>问题描述：</strong> 在一台超级计算机上，编号为1、2、3…、n的n个作业等待批处理，批处理的任务就是将这n个作业分成若干批，每批包含相邻的若干作业。从时刻0开始，分批加工这些作业。在每批作业开始前，机器需要启动时间S而完成这批作业所需的时间是单独完成批中各个作业需要时间的总和。单独完成第$i$个作业所需要的时间是$t_i$，所需的费用是它的完成时刻乘以一个费用系数$f_i$</p>
<p><strong>题解：</strong></p>
<p>设$z_i$是</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">153</span></span><br></pre></td></tr></table></figure>
<p><strong>2.题解</strong></p>
<p><img src="/Users/Yan/Library/Application Support/typora-user-images/image-20201123112546597.png" alt="image-20201123112546597"></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> z[<span class="number">1000</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> S,n;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">1000</span>] = &#123;&#125;,sw[<span class="number">1000</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">1000</span>] = &#123;&#125;,w[<span class="number">1000</span>] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dyna</span><span class="params">()</span></span>&#123;</span><br><span class="line">    z[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--) &#123;</span><br><span class="line">        <span class="comment">//倒序累加</span></span><br><span class="line">        st[i] = st[i+<span class="number">1</span>]+t[i];<span class="comment">//</span></span><br><span class="line">        sw[i] = sw[i+<span class="number">1</span>]+w[i];<span class="comment">//</span></span><br><span class="line">        z[i] = (st[i]+S)*sw[i];<span class="comment">//初始化每一个任务各一个组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">        z[i] = <span class="built_in">min</span>(z[i],z[j]+sw[i]*(S+st[i]-st[j]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        cin&gt;&gt;t[i];</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dyna</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-石子合并问题"><a href="#3-石子合并问题" class="headerlink" title="3. 石子合并问题"></a>3. 石子合并问题</h4><p><strong>问题描述：</strong> 在一个圆形操场摆放着$n$堆石子。现将石子有次序的合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。设计一个算法，计算出将n堆石子合并成一堆最小得分和最大得分。</p>
<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">54</span></span><br></pre></td></tr></table></figure>
<p><strong>3.题解：</strong></p>
<p>首先，我们对这两个结果进行解释。对于这四堆石子，我们可以先从左到右合并，那它的得分就是：</p>
<script type="math/tex; mode=display">
 (4+4)+(4+4+5)+(4+4+5+9) = 43</script><p>会发现最小得分是优先合并石子数少的两堆，相反，最大得分就是优先合并石子数多的两堆，也就有：</p>
<script type="math/tex; mode=display">
(9+5)+(9+5+4)+(9+5+4+4) = 54</script><p>注意并不是所有测试案例都是有一定顺序的，如 9，4，4，5 的结果与上述一致，因此每一次都需要进行判断相邻两堆相加的值是当前得分最小或最大的。</p>
<p>难点在于把环形当做直线型</p>
<p>4 4 5 9 5 4 4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> Arr[<span class="number">300</span>],Sum[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">int</span> Min[<span class="number">300</span>][<span class="number">300</span>], Max[<span class="number">300</span>][<span class="number">300</span>];<span class="comment">//第i到第j堆求和分数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; Arr[i];</span><br><span class="line">        Arr[i + n] = Arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最大和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        Sum[i] = Sum[i - <span class="number">1</span>] + Arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始递归循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; i + n; j++) &#123;</span><br><span class="line">            Min[i][j] = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                Min[i][j] = <span class="built_in">min</span>(Min[i][j], Min[i][k] + Min[k + <span class="number">1</span>][j] + Sum[j] - Sum[i - <span class="number">1</span>]);</span><br><span class="line">                Max[i][j] = <span class="built_in">max</span>(Max[i][j], Max[i][k] + Max[k + <span class="number">1</span>][j] + Sum[j] - Sum[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历找到最大与最小值</span></span><br><span class="line">    <span class="keyword">int</span> MaxValue = <span class="number">0</span>, MinValue = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        MaxValue = <span class="built_in">max</span>(MaxValue, Max[i][i + n - <span class="number">1</span>]);</span><br><span class="line">        MinValue = <span class="built_in">min</span>(MinValue, Min[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; MinValue &lt;&lt; endl &lt;&lt; MaxValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-最小m段和问题"><a href="#4-最小m段和问题" class="headerlink" title="4. 最小m段和问题"></a>4. 最小m段和问题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>] = &#123;&#125;;<span class="comment">//i长度 j段数。</span></span><br><span class="line"><span class="keyword">int</span> min1,max1,temp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j&lt;=m; j++) &#123;</span><br><span class="line">            min1 = <span class="number">99999</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k&lt;i; k++) &#123;</span><br><span class="line">                min1 = <span class="built_in">min</span>(min1,<span class="built_in">max</span>(dp[k][j<span class="number">-1</span>],dp[i][<span class="number">1</span>]-dp[k][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = min1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++) cin&gt;&gt;a[i];</span><br><span class="line">    cout&lt;&lt;<span class="built_in">solve</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法分析与设计</category>
      </categories>
      <tags>
        <tag>上课笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>向水学习</title>
    <url>/2020/09/08/2020-09-08-%E5%90%91%E6%B0%B4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h3 id="向水学习"><a href="#向水学习" class="headerlink" title="向水学习"></a><strong>向水学习</strong></h3><h4 id="黄永武"><a href="#黄永武" class="headerlink" title="黄永武"></a><strong>黄永武</strong></h4><p>地水火风，水是构成大千世界的要素之一，随处展现在眼前，又是水流动，有时水停蓄，老子看了就说：“最美妙的就是水，它简直就是道！”孔子看水也激动地大叫：“水载，水载。”表示他内心美妙得难以形容的赞叹！</p>
<p>古人对水为什么如此崇拜？是发现水有哪些德行？望着天天见面的水，该学习哪些方面呢？</p>
<p>水供应万物是普遍而无私的，有了水，万物才能生长；有了水，国家才安宁。水，有利于万物，却不与万物争利，最有德行。</p>
<p>水处在大家厌恶的地下，一切污秽丢向它，它的默默接受，尽管是废水污水，他总是要努力净化污秽成为洁美，他像善于教化的老师。</p>
<p>水有“去盈就备”的性格，水愈大，处的地位愈地，海处在最卑下的位置，百川都归向它，它像一个有道而修养深厚的哲人，也像最重义气的老大。</p>
<p>水载悬崖绝壁上奔腾而下，踩落再深的坑谷，也不回顾，像果决赴难的英雄，不畏粉神碎骨，真勇敢。</p>
<p>水流过去，不管有坑洞，有高坡，最后汪洋万里都安于一律平等，像法律。</p>
<p>水最柔弱，但持之以恒，竟滴水穿石。水源着一定的理走，再小的地方也不放过，何处有缝隙，水就浸润透达，它明察秋毫，像一个智者。</p>
<p>千缨万折的水，不改变东向的决心，历险致远，就像不可劫夺的志向。水遇到地方障碍，就安于规范，即可把自己清净下来，仿佛随遇而安，像一个乐知天命的人。</p>
<p>滚滚的水是先流满一个坑洞再前进的，所谓盈科而后进，就像君子要循序渐进，不愿邋第。</p>
<p>水要有源头才不枯竭，盗一时嘘声浮名的人，想大雨满集在沟中的水，没多久就枯竭了。</p>
<p>水是最清澈，最能辨别美丑，然而它广照万物，不分美丑，无物不照，心胸是十分宽广的。</p>
<p>水动的时候，有喷薄的景观，有汹涌的形势。凝凝然净下来又可以水天一色，波平如镜。无论动或静，水绝不止于外表的美观。而有君子殿可乐的内涵，它那“周流无滞”的作风，想一个通达事理的智者，所以说智者乐水。</p>
<p>综合而言：沐浴众生，泽及万物，谁最仁慈；疏通江河，自截盈满，而流于谦卑，水最智慧。水的德行如此，能不向水学习？</p>
<hr>
<p>孔子在川上，忽然有所领悟，说了一句：“逝者如斯夫，不舍昼夜。”孔子在想什么，丢下一个谜团给人猜。</p>
<p>有人说：“水洸洸然就像‘道’的无穷无尽！”</p>
<p>有人说：“流水一刻不停地逝去，如同时间的流逝，时间虽然无穷，但是人生是有涯的，生命只是一个泡影，所以要早就自己，孝顺父母，都要及时呀！”</p>
<p>有人又说：“孔子是在唤醒君子自强不息，昼夜不能稍息，像水不达到海，就绝不改变。‘万折而比东’的志向，不要像沼泽的水，无法行远；不要像涂潦之水，无法持久；不要像横流的水，失其所归，要学习不舍昼夜的川流。</p>
<hr>
]]></content>
      <categories>
        <category>散文集</category>
      </categories>
      <tags>
        <tag>散文</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>考研体验营----英语试讲</title>
    <url>/2020/08/30/2020-08-30-%E8%80%83%E7%A0%94%E4%BD%93%E9%AA%8C%E8%90%A5----%E8%8B%B1%E8%AF%AD%E8%AF%95%E8%AE%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="领航体验营——英语"><a href="#领航体验营——英语" class="headerlink" title="领航体验营——英语"></a>领航体验营——英语</h2><h3 id="一、考研英语基本常识："><a href="#一、考研英语基本常识：" class="headerlink" title="一、考研英语基本常识："></a>一、考研英语基本常识：</h3><h4 id="1-考研英语考什么"><a href="#1-考研英语考什么" class="headerlink" title="1. 考研英语考什么"></a>1. 考研英语考什么</h4><div class="table-container">
<table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>题数</th>
<th>分数占比</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>完形填空</td>
<td>20个空</td>
<td>共十分</td>
</tr>
<tr>
<td>2</td>
<td>阅读</td>
<td>20个题</td>
<td>共四十分</td>
</tr>
<tr>
<td>3</td>
<td>新题型</td>
<td>5个题</td>
<td>共十分</td>
</tr>
<tr>
<td>4</td>
<td>翻译（英译汉）</td>
<td>5个题（一卷）一段话（二卷）</td>
<td>10（一）15（二）</td>
</tr>
<tr>
<td>5</td>
<td>作文</td>
<td>小作文</td>
<td>10分</td>
</tr>
<tr>
<td>6</td>
<td>作文</td>
<td>大作文</td>
<td>20分（二）15分（一）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-英语基本功："><a href="#2-英语基本功：" class="headerlink" title="2. 英语基本功："></a>2. 英语基本功：</h4><ul>
<li><p>单词：考试掌握5500词汇以及相关短语，除此之外，还应掌握词汇之间词义意思：同义词，近义词，反义词，掌握词汇之间的搭配关系，如动词与介词，形容词与介词，形容词与名字。掌握词汇生成的基本知识，如词源，词根，词缀等。</p>
<p>另外，大纲中许多单词特殊形式未在词汇表中直接出现，但作为派生词而不是生词。</p>
</li>
<li><p>语法：语法知识尤为重要，长难句解析。</p>
</li>
<li><p>思维：出题规律，解题方法以及个人思维。注：阅读题大多出自外国著名<strong>期刊</strong>，但出题人却是中国人，因此思维逻辑很重要。</p>
</li>
</ul>
<h3 id="二、课上笔记"><a href="#二、课上笔记" class="headerlink" title="二、课上笔记"></a>二、课上笔记</h3><h4 id="1、如何背单词"><a href="#1、如何背单词" class="headerlink" title="1、如何背单词"></a>1、如何背单词</h4><ul>
<li><p>词根词缀法：</p>
<p>| 词根或词缀 | 意思            | 例                       | 解释                  |<br>| ————— | ———————- | ———————————— | ——————————- |<br>| a~         | 代表否定        | amorphous                | 无形状的              |<br>| ~ous       | 词缀形容词      | ponderous                | 笨重的                |<br>| re~        | 重复，往回      | review                   | 复习                  |<br>| dis~       | 否定<br/>分离   |dissolved<br/>dispersed   | 溶解<br/>分散，扩散   |<br>| com~       | 共同，一起      | compel                   | 强迫，迫使            |<br>| pre~       | 之间            | 1                        | 1                     |</p>
</li>
<li><p>反复背诵</p>
</li>
<li>谐音联想法：ponderous 胖的要死 ——笨重的</li>
<li>语境记忆：真题</li>
</ul>
<h4 id="2-单词词组特殊记："><a href="#2-单词词组特殊记：" class="headerlink" title="2. 单词词组特殊记："></a>2. 单词词组特殊记：</h4><ul>
<li>单词</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>单词</th>
<th>词性</th>
<th>词义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>distinguishing</td>
<td>n</td>
<td>区分</td>
</tr>
<tr>
<td>2</td>
<td>detect</td>
<td>v</td>
<td>侦查</td>
</tr>
<tr>
<td>3</td>
<td>diffuse</td>
<td>v</td>
<td>驱散</td>
</tr>
<tr>
<td>4</td>
<td>even</td>
<td>adv</td>
<td>甚至，<strong>即使</strong></td>
</tr>
<tr>
<td>5</td>
<td>solid</td>
<td>n</td>
<td>固体</td>
</tr>
<tr>
<td>6</td>
<td>liquid</td>
<td>n</td>
<td>液体</td>
</tr>
<tr>
<td>7</td>
<td>depression</td>
<td>n</td>
<td>抑郁症</td>
</tr>
<tr>
<td>8</td>
<td>differentiate</td>
<td>v</td>
<td>区别</td>
</tr>
<tr>
<td>9</td>
<td>distinct<br/>distinctive</td>
<td>adj</td>
<td>不同的</td>
</tr>
<tr>
<td>10</td>
<td>draw</td>
<td>v</td>
<td>得到，得出</td>
</tr>
<tr>
<td>11</td>
<td>means</td>
<td>n</td>
<td>方式方法（单复同形）</td>
</tr>
<tr>
<td>12</td>
<td>medium（media）</td>
<td>n</td>
<td>媒体，媒介</td>
</tr>
<tr>
<td>13</td>
<td>domiant</td>
<td>adj</td>
<td>主要的</td>
</tr>
<tr>
<td>14</td>
<td>company</td>
<td>n</td>
<td>公司；陪伴</td>
</tr>
<tr>
<td>15</td>
<td>hitherto</td>
<td>n</td>
<td>到目前为止</td>
</tr>
<tr>
<td>16</td>
<td>comparative</td>
<td>adj</td>
<td>相对的</td>
</tr>
<tr>
<td>17</td>
<td>respectable</td>
<td>adj</td>
<td>令人尊重的</td>
</tr>
<tr>
<td>18</td>
<td>formidable</td>
<td>adj</td>
<td>令人敬畏的</td>
</tr>
<tr>
<td>19</td>
<td>faint</td>
<td>adj</td>
<td>微弱的</td>
</tr>
<tr>
<td>20</td>
<td>municipal</td>
<td>adj</td>
<td>市政的</td>
</tr>
<tr>
<td>21</td>
<td>detach</td>
<td>v</td>
<td>分开；使—-分开</td>
</tr>
<tr>
<td>22</td>
<td>manipulation</td>
<td>n</td>
<td>操纵</td>
</tr>
<tr>
<td>23</td>
<td>class</td>
<td>n</td>
<td>等级；阶级</td>
</tr>
<tr>
<td>24</td>
<td>emergence</td>
<td>n</td>
<td>出现</td>
</tr>
<tr>
<td>25</td>
<td>raise</td>
<td>v</td>
<td>提升；<strong>抚养</strong>；<strong>筹集</strong></td>
</tr>
<tr>
<td>26</td>
<td>couple</td>
<td>n/v</td>
<td>夫妇；<strong>与—-联合一起</strong></td>
</tr>
<tr>
<td>27</td>
<td>quality</td>
<td>n</td>
<td>品质；特征</td>
</tr>
<tr>
<td>28</td>
<td>evolve</td>
<td>v</td>
<td>进化</td>
</tr>
<tr>
<td>29</td>
<td>involve</td>
<td>v</td>
<td>涉及</td>
</tr>
<tr>
<td>30</td>
<td>species</td>
<td>n</td>
<td>物种</td>
</tr>
<tr>
<td>31</td>
<td>establishment</td>
<td>n</td>
<td>建立</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>词组<ol>
<li>2038（十万）—— 203.8 million</li>
<li>one part in ten——十分之一</li>
<li>A of B——B的A</li>
<li>in the wake of——紧随——之后</li>
<li>but与yet 词义一致，但是。</li>
<li>in the light of 根据</li>
<li>result in 导致</li>
<li>in the company of 在—-陪伴之下</li>
</ol>
</li>
</ul>
<h4 id="3-语法知识"><a href="#3-语法知识" class="headerlink" title="3.语法知识"></a>3.语法知识</h4><ul>
<li><p>强调句： It is/was + 强调内容+that+剩余内容。</p>
<p>It was <strong>not until the 19th century</strong> that the newspaper became the dominant pre-electronic medium.</p>
</li>
<li><p>倒装句：否定意义的词位于句首+情态动词、助动词+主+谓。</p>
</li>
<li><p>定语从句：先行词，连词，连词省略，关系代词做宾语。</p>
</li>
<li><p>同位语从句：一句话解释一个宾语。</p>
</li>
</ul>
<p>The main problem <strong>people may encounter today</strong> arises from the <strong>fact</strong> that they have difficulty obtaining the needed information readily.</p>
<p>（判断句子个数，找谓语动词）</p>
<p>今天人们可能遇到的主要问题是他们很难轻易获得所需的信息。</p>
]]></content>
      <categories>
        <category>考研类</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上好用的敲代码软件CodeRunner外加破解</title>
    <url>/2020/08/13/Mac%E4%B8%8A%E5%A5%BD%E7%94%A8%E7%9A%84%E6%95%B2%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6CodeRunner/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Powerful-IDE-level-code-completion-for-most-languages"><a href="#Powerful-IDE-level-code-completion-for-most-languages" class="headerlink" title="Powerful IDE level code completion for most languages"></a>Powerful IDE level code completion for most languages</h1><h2 id="有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS-Code-，但是插件的下载与安装也是比较麻烦的。"><a href="#有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS-Code-，但是插件的下载与安装也是比较麻烦的。" class="headerlink" title="有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS Code ，但是插件的下载与安装也是比较麻烦的。"></a>有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS Code ，但是插件的下载与安装也是比较麻烦的。</h2><h2 id="我介绍一个万能IDE—————-gt-Code-Runner"><a href="#我介绍一个万能IDE—————-gt-Code-Runner" class="headerlink" title="我介绍一个万能IDE—————-&gt; Code Runner"></a>我介绍一个万能IDE—————-&gt; Code Runner</h2><p><img src="https://img-blog.csdnimg.cn/20200117085038328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>他几乎支持的了所有语言，如果没有你想要的，你也可以手动添加。<br>他的界面如xcode一样，非常的美观，清楚。支持代码自动补全，同样也支持很多主题。</p>
<p>运行之后还会显示运行时间。。</p>
<h3 id="功能强大-仅有270多MB-是不是心动了呢"><a href="#功能强大-仅有270多MB-是不是心动了呢" class="headerlink" title="功能强大 仅有270多MB 是不是心动了呢?"></a>功能强大 仅有270多MB 是不是心动了呢?</h3><h1 id="然而"><a href="#然而" class="headerlink" title="然而"></a>然而</h1><p><img src="https://img-blog.csdnimg.cn/20200117085414258.png" alt="在这里插入图片描述"><br>没错它是需要付费的。</p>
<h1 id="然而-1"><a href="#然而-1" class="headerlink" title="然而"></a>然而</h1><p>不废话—-</p>
<h2 id="1-直接登录官网下载"><a href="#1-直接登录官网下载" class="headerlink" title="1. 直接登录官网下载"></a>1. 直接登录官网下载</h2><h2 id="2-断网激活："><a href="#2-断网激活：" class="headerlink" title="2. 断网激活："></a>2. 断网激活：</h2><p>安装成功后，选择输入激活码。并断网。激活码网上都有，我就不找啦。几乎是随便一个就可以。成功后会有一个successfully</p>
<h2 id="3-修改hosts文件："><a href="#3-修改hosts文件：" class="headerlink" title="3. 修改hosts文件："></a>3. 修改hosts文件：</h2><p>打开<br>终端，开启root权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su </span><br></pre></td></tr></table></figure>
<p>输入密码后，打开hosts文件位置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /private/etc </span><br></pre></td></tr></table></figure>
<p>然后用vim打开 hosts文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim hosts</span><br></pre></td></tr></table></figure>
<p>进入此文件后，在后面加上一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1       coderunnerapp.com</span><br></pre></td></tr></table></figure>
<p>然后保存退出。。。<br>（这块需要用到vim的一些简单操作，不会的话百度一下就OK，非常简单）<br>（注：修改成功以后他的官网就会进不去）</p>
<h3 id="重启coderunner-就可以使用啦。"><a href="#重启coderunner-就可以使用啦。" class="headerlink" title="重启coderunner 就可以使用啦。"></a>重启coderunner 就可以使用啦。</h3>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 基础操作 + 配置文件设置 基础版 for mac</title>
    <url>/2020/07/04/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C+%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="vim-模式"><a href="#vim-模式" class="headerlink" title="vim 模式"></a>vim 模式</h2><h3 id="1-normal模式"><a href="#1-normal模式" class="headerlink" title="1.normal模式"></a>1.normal模式</h3><p>当我们用vim创建或者打开一个文件的时候，就是normal模式，然后我们可以输入一些指令，更加方便的操作文件。</p>
<h3 id="2-insert模式"><a href="#2-insert模式" class="headerlink" title="2.insert模式"></a>2.insert模式</h3><p>顾名思义就是可以进行编辑自己的文件内容了，从normal模式到insert模式有很多种快捷键，稍后一一说明。但是从insert模式到normal模式需要按esc键，没错，当我们常用到vim进行编辑的时候，会非常频繁的使用esc，但是他的位置却不是很让我们提高效率，在这里我们可以吧caps lock 修改为esc ，毕竟caps lock 真的没什么用，却处于一个非常方便的位置。</p>
<p>==具体修改可以看这篇博客，这里不再赘述==</p>
<p><a href="https://blog.csdn.net/VistorsYan/article/details/104036840">Mac修改键盘之 将 caps lock修改为esc</a></p>
<h2 id="基本操作命令（增删改查-保存退出）"><a href="#基本操作命令（增删改查-保存退出）" class="headerlink" title="基本操作命令（增删改查+保存退出）"></a>基本操作命令（增删改查+保存退出）</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>在光标前写入</td>
</tr>
<tr>
<td>a</td>
<td>在光标后插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标所在行下一行插入一新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标所在行上一行插入一新行</td>
</tr>
<tr>
<td>shift+i</td>
<td>行前插入</td>
</tr>
<tr>
<td>shift + a</td>
<td>行尾插入</td>
</tr>
<tr>
<td>h j k l</td>
<td>光标移动：←↓↑→   上下左右键也可移动</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除当前光标所在的字符</td>
</tr>
<tr>
<td>:wq然后回车</td>
<td>保存并退出</td>
</tr>
<tr>
<td>dd</td>
<td>剪切当前行</td>
</tr>
<tr>
<td>p/P</td>
<td>粘贴 前者是在光标之前，后者是在光标之后</td>
</tr>
<tr>
<td>yy</td>
<td>拷贝当前行</td>
</tr>
<tr>
<td>/+要输入的字符串</td>
<td>在文本中查找改字符串</td>
</tr>
</tbody>
</table>
</div>
<h1 id="配置文件设置"><a href="#配置文件设置" class="headerlink" title="配置文件设置"></a>配置文件设置</h1><h2 id="创建vim配置文件"><a href="#创建vim配置文件" class="headerlink" title="创建vim配置文件"></a>创建vim配置文件</h2><h3 id="在根目录下找到-vim文件夹并打开"><a href="#在根目录下找到-vim文件夹并打开" class="headerlink" title="在根目录下找到 .vim文件夹并打开"></a>在根目录下找到 .vim文件夹并打开</h3><p>注：如果没有就新建一个.vim文件夹并打开即可。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"><span class="built_in">cd</span> .vim</span><br></pre></td></tr></table></figure></p>
<h3 id="然后-在当前路径下："><a href="#然后-在当前路径下：" class="headerlink" title="然后 在当前路径下："></a>然后 在当前路径下：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim vimrc</span><br></pre></td></tr></table></figure>
<p>这样就有打开了一个新的文件，这就是配置文件，你可以在这里进行“肆意的”修改</p>
<h2 id="键位修改"><a href="#键位修改" class="headerlink" title="键位修改"></a>键位修改</h2><p>有时vim的一些快捷键很不合你的口味，比如方向键，所以可以把方向键的位置改为符合方向的键。</p>
<h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>我想把h 键改为 i：（直接在vimrc里面写）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">noremap i h</span><br></pre></td></tr></table></figure><br>此时i键有着和h一样的功能，但是i键本来是有功能的（插入），因此==切记==不要忘了把i给改为别的键，如果你还想用这个功能的话。</p>
<h2 id="指令快捷化"><a href="#指令快捷化" class="headerlink" title="指令快捷化"></a>指令快捷化</h2><p>vim 保存命令是在normal模式下输入 :w 然后回车，虽然很方便了，但是可以更快：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> S :<span class="keyword">w</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><br>现在直接用S即可保存，（w后的不用我说也清楚是回车的意思）<br>以此类推：举几个常用的例子<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> s <span class="symbol">&lt;nop&gt;</span></span><br></pre></td></tr></table></figure><br>nop(no operation) ==取消s的功能==</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> Q :q<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>
<p>退出<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> R :<span class="keyword">source</span> $MYVIMRC<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><br>刷新（应用的意思）<br>注：这些都需要保存退出以后才能生效，如果刷新，即刻生效<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">synatx <span class="keyword">on</span></span><br></pre></td></tr></table></figure><br>代码高亮</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="keyword">set</span> cursorline</span><br><span class="line"><span class="keyword">set</span> wrap</span><br><span class="line"><span class="keyword">set</span> wildmenu</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打开行号<br>添加下划线<br>如果该行已满 自动换行<br>命令自动补全 tab 同bash</p>
<h4 id="有关查找的指令"><a href="#有关查找的指令" class="headerlink" title="有关查找的指令"></a>有关查找的指令</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hlsearch</span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line">exec <span class="string">&quot;nohlsearch&quot;</span></span><br><span class="line"><span class="keyword">set</span> ignorecase</span><br><span class="line"><span class="keyword">set</span> smartcase</span><br></pre></td></tr></table></figure>
<p>查找时高亮显示<br>边输入边高亮<br>当再次进入文件时不显示高亮，否则还会显示上次查找的高亮<br>忽视高亮<br>忽略大小写<br>智能大小写</p>
<p>==注：查找完后会依然显示高亮，去除高亮的命令是==</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nohlsearch</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以根据自己的意愿，按上边的方式修改一下快捷键去除查找后的高亮</p>
<p>以上仅提供了一些基础常用的设置，还不是全部。。。。<br>有什么更好的指令欢迎下方留言，嘻嘻😬</p>
]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Datagrip的基本使用方法。</title>
    <url>/2020/04/18/Datagrip%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Datagrip-的基本使用方法"><a href="#Datagrip-的基本使用方法" class="headerlink" title="Datagrip 的基本使用方法"></a>Datagrip 的基本使用方法</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​    我使用的是MySQL，并安装成功且可以正常使用，这里不再介绍如何安装，有需求的可以自行百度。。😬</p>
<h2 id="1-新建MySQL"><a href="#1-新建MySQL" class="headerlink" title="1.新建MySQL"></a>1.新建MySQL</h2><ul>
<li>按如下图示操作，选中MySQL选项：</li>
</ul>
<p><img src="https://i.loli.net/2020/04/18/tkmlcHWUQO7wZdV.png" alt="image.png"></p>
<ul>
<li>在安装MySQL会注册自己的User和Password，填在下方：</li>
</ul>
<p><img src="https://i.loli.net/2020/04/18/IfCoDwKLeXl2kjy.png" alt="image.png"></p>
<p>之后就会在左侧栏中出现了</p>
<h2 id="2-建立数据库"><a href="#2-建立数据库" class="headerlink" title="2.建立数据库"></a>2.建立数据库</h2><ul>
<li>如下图操作，选择后，创建名字即可</li>
</ul>
<p><img src="https://i.loli.net/2020/04/18/r6EG2AqNHSXwUxg.png" alt="image.png"></p>
<h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><ul>
<li><p>在你新建的数据库下，右击选择 new 选择 table ： </p>
<p><img src="https://i.loli.net/2020/04/18/ehHfkmrxVDnaFQZ.png" alt="image.png"></p>
</li>
</ul>
<p>第一个为表的名字，第二项是备注，下面加号可以手动添加表格内列名，也可以设置主键和特征，下面对应生成SQL语句。</p>
<h2 id="4-使用查询分析器"><a href="#4-使用查询分析器" class="headerlink" title="4. 使用查询分析器"></a>4. 使用查询分析器</h2><p>右击数据库，选择 Jump to Console ,选择当下MySQL的Console即可。就可以在上面书写SQL语句了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>sql数据查询之---嵌套查询</title>
    <url>/2020/04/02/sql%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2---%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="sql数据查询之———嵌套查询"><a href="#sql数据查询之———嵌套查询" class="headerlink" title="sql数据查询之———嵌套查询"></a>sql数据查询之———嵌套查询</h1><h2 id="一、嵌套查询概述"><a href="#一、嵌套查询概述" class="headerlink" title="一、嵌套查询概述"></a>一、嵌套查询概述</h2><ul>
<li>一个 SELECT-FROM-WHERE 语句称为一个查询块。</li>
<li>将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为 嵌套查询。</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname	                           <span class="comment">/*外层查询/父查询*/</span></span><br><span class="line">     <span class="keyword">FROM</span> Student</span><br><span class="line">     <span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">                        ( <span class="keyword">SELECT</span> Sno        <span class="comment">/*内层查询/子查询*/</span></span><br><span class="line">                          <span class="keyword">FROM</span> SC</span><br><span class="line">                          <span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">&#x27; 2 &#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意：子查询的SELECT语句中不能使用 ORDER BY 子句，因为 ORDER BY 子句只能对最终查询结果排序。</strong></p>
<ul>
<li>不相关子查询：<strong>子查询的查询条件不依赖于父查询</strong></li>
<li>相关子查询：<strong>子查询的查询条件依赖于父查询</strong></li>
</ul>
<p>（后续在对二者详细解释）</p>
<h2 id="二、嵌套查询"><a href="#二、嵌套查询" class="headerlink" title="二、嵌套查询"></a>二、嵌套查询</h2><h3 id="1-带有in谓词的子查询"><a href="#1-带有in谓词的子查询" class="headerlink" title="1.带有in谓词的子查询"></a>1.带有in谓词的子查询</h3><h4 id="例1：查询与“刘晨”在同一个系学习的学生。"><a href="#例1：查询与“刘晨”在同一个系学习的学生。" class="headerlink" title="例1：查询与“刘晨”在同一个系学习的学生。"></a>例1：<strong>查询与“刘晨”在同一个系学习的学生。</strong></h4><p>分部完成：</p>
<p><strong>①</strong> 确定“刘晨”所在系名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Sdept  </span><br><span class="line">         <span class="keyword">FROM</span>     Student                            </span><br><span class="line">         <span class="keyword">WHERE</span>  Sname<span class="operator">=</span> <span class="string">&#x27; 刘晨 &#x27;</span>;</span><br><span class="line">				</span><br></pre></td></tr></table></figure>
<p>假设结果为CS</p>
<p><strong>②</strong> 查找所有在CS系学习的学生。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   Sno, Sname, Sdept     </span><br><span class="line">        <span class="keyword">FROM</span>      Student                 </span><br><span class="line">        <span class="keyword">WHERE</span>   Sdept<span class="operator">=</span> <span class="string">&#x27; CS &#x27;</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一部就是子查询，第二步为父查询</p>
<p>那么可以写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Sdept</span><br><span class="line">    	<span class="keyword">FROM</span> Student</span><br><span class="line">   	<span class="keyword">WHERE</span> Sdept  <span class="keyword">IN</span></span><br><span class="line">                  (<span class="keyword">SELECT</span> Sdept</span><br><span class="line">                   <span class="keyword">FROM</span> Student</span><br><span class="line">                   <span class="keyword">WHERE</span> Sname<span class="operator">=</span> <span class="string">&#x27; 刘晨 &#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：这是不相关查询，即子查询条件与父查询条件无关</p>
<h4 id="例2：查询选修了课程名为“信息系统”的学生学号和姓名"><a href="#例2：查询选修了课程名为“信息系统”的学生学号和姓名" class="headerlink" title="例2：查询选修了课程名为“信息系统”的学生学号和姓名"></a>例2：<strong>查询选修了课程名为“信息系统”的学生学号和姓名</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname                 ③ 最后在Student关系中</span><br><span class="line">  	<span class="keyword">FROM</span>    Student                          取出Sno和Sname</span><br><span class="line"> 	<span class="keyword">WHERE</span> Sno  <span class="keyword">IN</span></span><br><span class="line">             (<span class="keyword">SELECT</span> Sno                     ② 然后在SC关系中找出选</span><br><span class="line">              <span class="keyword">FROM</span>    SC                         修了<span class="number">3</span>号课程的学生学号</span><br><span class="line">              <span class="keyword">WHERE</span>  Cno <span class="keyword">IN</span></span><br><span class="line">                     (<span class="keyword">SELECT</span> Cno             ① 首先在Course关系中找出</span><br><span class="line">                       <span class="keyword">FROM</span> Course           “信息系统”的课程号，为<span class="number">3</span>号</span><br><span class="line">                       <span class="keyword">WHERE</span> Cname<span class="operator">=</span> <span class="string">&#x27;信息系统&#x27;</span>                      </span><br><span class="line">		          )</span><br><span class="line">        );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然也可以用连接查询实现:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname</span><br><span class="line"><span class="keyword">FROM</span> Student,SC,Course</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span></span><br><span class="line">    SC.Cno<span class="operator">=</span>Course.Cno <span class="keyword">AND</span></span><br><span class="line">    Course.Cname<span class="operator">=</span><span class="string">&#x27;信息系统&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-带有比较运算符的子查询"><a href="#2-带有比较运算符的子查询" class="headerlink" title="2.带有比较运算符的子查询"></a>2.<strong>带有比较运算符的子查询</strong></h3><p>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt; &gt;）。</p>
<p>对于第一个例子来说，由于一个学生只可能在一个系里学习，所以可以用 = 代替 in</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Sdept</span><br><span class="line">    	<span class="keyword">FROM</span> Student</span><br><span class="line">   	<span class="keyword">WHERE</span> Sdept  <span class="operator">=</span></span><br><span class="line">                  (<span class="keyword">SELECT</span> Sdept</span><br><span class="line">                   <span class="keyword">FROM</span> Student</span><br><span class="line">                   <span class="keyword">WHERE</span> Sname<span class="operator">=</span> <span class="string">&#x27; 刘晨 &#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-带有ANY-SOME-或ALL谓词的子查询"><a href="#3-带有ANY-SOME-或ALL谓词的子查询" class="headerlink" title="3.带有ANY(SOME)或ALL谓词的子查询"></a>3.带有ANY(SOME)或ALL谓词的子查询</h3><p><strong>子查询返回单值时可以用比较运算符，但返回多值时要用ANY（有的系统用SOME）或ALL谓词修饰符。而使用ANY或ALL谓词时则必须同时使用比较运算符。</strong>其语义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>&gt;ANY</th>
<th>大于子查询结果中的某个值</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;ALL</td>
<td>大于子查询结果中的所有值</td>
</tr>
<tr>
<td>&lt;ANY</td>
<td>小于子查询结果中的某个值</td>
</tr>
<tr>
<td>&lt;ALL</td>
<td>小于子查询结果中的所有值</td>
</tr>
<tr>
<td>&gt;=ANY</td>
<td>大于等于子查询结果中的某个值</td>
</tr>
<tr>
<td>&gt;=ALL</td>
<td>大于等于子查询结果中的所有值</td>
</tr>
<tr>
<td>&lt;=ALL</td>
<td>小于等于子查询结果中的所有值</td>
</tr>
<tr>
<td>&lt;=ANY</td>
<td>大于等于子查询结果中的某个值</td>
</tr>
<tr>
<td>=ANY</td>
<td>等于子查询结果中的某个值</td>
</tr>
<tr>
<td>=ALL</td>
<td>等于子查询结果中的所有值（通常没有实际意义）</td>
</tr>
<tr>
<td>!=（或&lt;&gt;）ANY</td>
<td>不等于子查询结果中的某个值</td>
</tr>
<tr>
<td>!=（或&lt;&gt;）ALL</td>
<td>不等于子查询结果中的任何一个值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="例1：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄"><a href="#例1：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄" class="headerlink" title="例1：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄"></a>例1：<strong>查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<span class="operator">&lt;</span><span class="keyword">ANY</span> (<span class="keyword">SELECT</span> Sage</span><br><span class="line">                <span class="keyword">FROM</span> Student</span><br><span class="line">                <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="例2：查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄"><a href="#例2：查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄" class="headerlink" title="例2：查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄"></a>例2：查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<span class="operator">&lt;</span><span class="keyword">ALL</span></span><br><span class="line">          (<span class="keyword">SELECT</span> Sage</span><br><span class="line">           <span class="keyword">FROM</span> Student</span><br><span class="line">           <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>提示：本查询同样可以用<strong>聚集函数</strong>实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(Sage)</span><br><span class="line">     <span class="keyword">FROM</span> Student</span><br><span class="line">     <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span><span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/04/02/pa3jZ8t5SCVIAHy.png" alt="截屏2020-04-02下午9.25.09.png"></p>
<h3 id="4-带有EXISTS谓词的子查询"><a href="#4-带有EXISTS谓词的子查询" class="headerlink" title="4.带有EXISTS谓词的子查询"></a>4.带有EXISTS谓词的子查询</h3><p><strong>带有EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。</strong></p>
<h4 id="例1：-查询所有选修了1号课程的学生姓名"><a href="#例1：-查询所有选修了1号课程的学生姓名" class="headerlink" title="例1： 查询所有选修了1号课程的学生姓名"></a>例1： 查询所有选修了1号课程的学生姓名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">FROM</span> SC</span><br><span class="line">     <span class="keyword">WHERE</span> Sno<span class="operator">=</span>Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>本查询涉及Student和SC关系</strong></li>
<li><strong>在Student中依次取每个元组的Sno值，用此值去检查SC表</strong></li>
<li><strong>若SC中存在这样的元组，其Sno值等于此Student.Sno值，并且其Cno= ‘1’，则取此Student.Sname送入结果表</strong></li>
</ul>
<h4 id="例2：查询没有选修1号课程的学生姓名"><a href="#例2：查询没有选修1号课程的学生姓名" class="headerlink" title="例2：查询没有选修1号课程的学生姓名"></a>例2：查询没有选修1号课程的学生姓名</h4><p>直接在<strong>EXISTS</strong>前加<strong>NOT</strong></p>
<p><strong>重难点</strong>：</p>
<h4 id="例3：查询选修了全部课程的学生姓名"><a href="#例3：查询选修了全部课程的学生姓名" class="headerlink" title="例3：查询选修了全部课程的学生姓名"></a>例3：查询选修了全部课程的学生姓名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">FROM</span> Course</span><br><span class="line">     <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">         <span class="keyword">FROM</span> SC</span><br><span class="line">         <span class="keyword">WHERE</span> Sno<span class="operator">=</span>Student.Sno</span><br><span class="line">            <span class="keyword">AND</span> Cno<span class="operator">=</span>Course.Cno));</span><br></pre></td></tr></table></figure>
<p><strong>用EXISTS/NOT EXISTS实现全称量词（难点）</strong></p>
<ul>
<li>SQL语言中没有全称量词$\forall$（For all）</li>
<li>可以把带有全称量词的谓词转换为等价的带有存在量词的谓词：$ (\forall x)P = ﹁(\exist x(﹁P))$</li>
</ul>
<h4 id="例4-：查询至少选修了学生201215122选修的全部课程的学生号码"><a href="#例4-：查询至少选修了学生201215122选修的全部课程的学生号码" class="headerlink" title="例4 ：查询至少选修了学生201215122选修的全部课程的学生号码"></a>例4 ：查询至少选修了学生201215122选修的全部课程的学生号码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC SCX</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">FROM</span> SC SCY</span><br><span class="line">     <span class="keyword">WHERE</span> SCY.Sno<span class="operator">=</span><span class="string">&#x27;201215122&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">        <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">         <span class="keyword">FROM</span> SC SCZ</span><br><span class="line">         <span class="keyword">WHERE</span> SCZ.Sno<span class="operator">=</span>SCX.Sno <span class="keyword">AND</span></span><br><span class="line">         SCZ.Cno<span class="operator">=</span>SCY.Cno));</span><br></pre></td></tr></table></figure>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><strong>不同形式的查询间的替换</strong></p>
<p>一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换</p>
<p>所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带<strong>EXISTS</strong>谓词的子查询等价替换</p>
]]></content>
      <categories>
        <category>上课笔记</category>
      </categories>
      <tags>
        <tag>上课笔记</tag>
        <tag>sql语句</tag>
      </tags>
  </entry>
  <entry>
    <title>word中如何加入带√的□ ?</title>
    <url>/2020/02/12/word%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8A%A0%E5%85%A5%E5%B8%A6%E2%88%9A%E7%9A%84%E5%B0%8F%E6%96%B9%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="打出有勾的方括号"><a href="#打出有勾的方括号" class="headerlink" title="打出有勾的方括号"></a>打出有勾的方括号</h2><p>输入一个大写R，之后选中，把字体改为：wingdings 2 就OK了，然后自己试了试在这个字体下输入了一些别的字，发现有许多图形，还很不错。</p>
<hr>
<p>于是就百度了一下对照表</p>
<h2 id="如下："><a href="#如下：" class="headerlink" title="如下："></a>如下：</h2><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1176238582,3363171188&amp;fm=26&amp;gp=0.jpg" alt="对照表"></p>
<p>在这个字体下，对应输入，就会有这么些不同的图标，不错不错，长知识。</p>
]]></content>
      <categories>
        <category>Microsoft技能</category>
      </categories>
      <tags>
        <tag>word技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>UIKit与swiftUI 交互</title>
    <url>/2020/02/09/swiftui%E4%B8%8Euikit%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="UIKit与swiftUI-交互"><a href="#UIKit与swiftUI-交互" class="headerlink" title="UIKit与swiftUI 交互"></a>UIKit与swiftUI 交互</h1><p>运用swiftUI写界面非常迅速且酷炫。大大减少了曾经在UIKit中的代码量。<br>不过有时候可能你还会需要用到UIKit，但是你又想用swiftUI做界面，此时就考虑到二者交互的问题了。</p>
<h2 id="UIViewControllerRepresentable"><a href="#UIViewControllerRepresentable" class="headerlink" title="UIViewControllerRepresentable"></a>UIViewControllerRepresentable</h2><p><strong>在swiftUI中提供了一个UIViewControllerRepresentable协议</strong><br><strong>我们可以用它作为UIKit 与swiftUI的桥接</strong><br><img src="https://img-blog.csdnimg.cn/20200113121716232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h1><h2 id="你依然可以像往常一样，新建一个swift文件，把他命名为viewController-然后导入UiKit-，然后再让它继承UIViewController-重写父类的viewDidLoad-方法，你也可以往里面随便添点东西，为后面验证做准备，just-like-this"><a href="#你依然可以像往常一样，新建一个swift文件，把他命名为viewController-然后导入UiKit-，然后再让它继承UIViewController-重写父类的viewDidLoad-方法，你也可以往里面随便添点东西，为后面验证做准备，just-like-this" class="headerlink" title="你依然可以像往常一样，新建一个swift文件，把他命名为viewController 然后导入UiKit ，然后再让它继承UIViewController 重写父类的viewDidLoad()方法，你也可以往里面随便添点东西，为后面验证做准备，just like this.."></a>你依然可以像往常一样，新建一个swift文件，把他命名为viewController 然后导入UiKit ，然后再让它继承UIViewController 重写父类的viewDidLoad()方法，你也可以往里面随便添点东西，为后面验证做准备，just like this..<img src="https://img-blog.csdnimg.cn/20200113122152672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><h1 id="第二步-桥接"><a href="#第二步-桥接" class="headerlink" title="第二步 桥接"></a>第二步 桥接</h1><h2 id="第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController-他需要遵循并实现UIViewControllerRepresentable这个协议"><a href="#第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController-他需要遵循并实现UIViewControllerRepresentable这个协议" class="headerlink" title="第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController 他需要遵循并实现UIViewControllerRepresentable这个协议"></a>第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController 他需要遵循并实现UIViewControllerRepresentable这个协议</h2><h1 id="第三步-应用"><a href="#第三步-应用" class="headerlink" title="第三步 应用"></a>第三步 应用</h1><h2 id="接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了"><a href="#接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了" class="headerlink" title="接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了"></a>接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了<img src="https://img-blog.csdnimg.cn/20200113125213490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="第二步与第三步"></h2><h1 id="显示效果如图"><a href="#显示效果如图" class="headerlink" title="显示效果如图"></a>显示效果如图</h1><p><img src="https://img-blog.csdnimg.cn/20200113130421611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h1><p>viewController.swift 文件中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">viewController</span>: <span class="title">UIViewController</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor <span class="operator">=</span> .brown</span><br><span class="line">        <span class="keyword">let</span> viewDemo <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">        viewDemo.backgroundColor <span class="operator">=</span> .green</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(viewDemo)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ConventView.swift 文件中</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UIKit 桥接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UIBridging</span>: <span class="title">UIViewControllerRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个UIViewControllerType你要接哪个就是哪个，在这里就是viewController</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">UIViewControllerType</span> <span class="operator">=</span> viewController</span><br><span class="line">    <span class="comment">//必须实现的方法，当swiftUI要显示view时，会调用这个方法。返回值就是当前需要显示的类</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIViewController</span>(<span class="params">context</span>: <span class="type">UIViewControllerRepresentableContext</span>&lt;<span class="type">UIBridging</span>&gt;)</span> -&gt; <span class="type">UIBridging</span>.<span class="type">UIViewControllerType</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> viewController()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新UIViewController时会调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIViewController</span>(<span class="keyword">_</span> <span class="params">uiViewController</span>: viewController, <span class="params">context</span>: <span class="type">UIViewControllerRepresentableContext</span>&lt;<span class="type">UIBridging</span>&gt;)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">UIBridging</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ContentView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些"><a href="#注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些" class="headerlink" title="注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些"></a>注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些</h2>]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>swiftUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeblocks中文乱码解决方法</title>
    <url>/2020/02/07/Codeblocks%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Codeblocks中文乱码解决方法：</p>
<p>特别提示：出现中文乱码情况才执行以下操作，未出现请勿随意修改！！！！</p>
<p>打开Codeblocks -&gt; 设置 -&gt; 编辑器：</p>
<p><img src="https://img-blog.csdnimg.cn/20191205172416635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后点击 Encoding settings -&gt; 选择编码 -&gt; 选择UTF-8 -&gt; 确定：</p>
<p><img src="https://img-blog.csdnimg.cn/20191205172454640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20191205172512827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>点击设置 -&gt; 编译器：</p>
<p><img src="https://img-blog.csdnimg.cn/20191205172528406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>点击Other compiler options-&gt;在空白处输入</p>
<p> -finput-charset=UTF-8</p>
<p>-fexec-charset=GBK</p>
<p>点击确定 -&gt; 随意修改下代码 -&gt;重新生成。</p>
<p><img src="https://img-blog.csdnimg.cn/2019120517254235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>即可解决乱码问题。</p>
]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>mac与windows兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac修改键盘之 将 caps lock修改为esc</title>
    <url>/2020/02/05/Mac%E4%BF%AE%E6%94%B9%E9%94%AE%E7%9B%98%E4%B9%8B%E5%B0%86%E5%A4%A7%E5%B0%8F%E5%86%99%E9%94%81%E5%AE%9A%E4%BF%AE%E6%94%B9esc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。"><a href="#想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。" class="headerlink" title="想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。"></a>想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。</h3><h3 id="大多数的人都是将caps-lock-修改为esc。"><a href="#大多数的人都是将caps-lock-修改为esc。" class="headerlink" title="大多数的人都是将caps lock 修改为esc。"></a>大多数的人都是将caps lock 修改为esc。</h3><p>因为caps lock 处在了最重要的位置却几乎不怎么使用他，如果用大写直接按住shift就可以了。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>之前在网上查到了关于此类的问题，说需要下载一个第三方软件，我推荐一个非常简单的方法，就在mac的设置里：</p>
<h4 id="找到系统偏好设置———-gt-键盘———-gt-左下角有一个修饰键"><a href="#找到系统偏好设置———-gt-键盘———-gt-左下角有一个修饰键" class="headerlink" title="找到系统偏好设置———&gt;键盘———-&gt;左下角有一个修饰键"></a>找到系统偏好设置———&gt;键盘———-&gt;左下角有一个修饰键</h4><p><img src="https://img-blog.csdnimg.cn/20200119094846166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>把第一个改成Escape就好啦</p>
<h1 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h1><p>实际上如图所示，mac已经提供了部分功能的修改，如果还想修改别的键，直接修改就好了</p>
]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>C指针问题之不同类型指针之间的区别</title>
    <url>/2020/02/02/C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E4%B9%8B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="会想这样的一个问题："><a href="#会想这样的一个问题：" class="headerlink" title="会想这样的一个问题："></a>会想这样的一个问题：</h1><h3 id="指针就是地址吧，那么指向int-的指针也好，指向double的指针也好，他们有什么不同么"><a href="#指针就是地址吧，那么指向int-的指针也好，指向double的指针也好，他们有什么不同么" class="headerlink" title="== 指针就是地址吧，那么指向int 的指针也好，指向double的指针也好，他们有什么不同么=="></a>== 指针就是地址吧，那么指向int 的指针也好，指向double的指针也好，他们有什么不同么==</h3><p>emmmm<br>貌似也有一定道理。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>既然我们无法从正面解释，那我们就先设定一个“万能指针”<br>看我接下来这段操作：</p>
<p><img src="https://img-blog.csdnimg.cn/20200119212651514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在这里我创建了一个“可以指向任何类型的指针类型”——void*类型</p>
<p>但是当我运行的时候，出现了一个错误：</p>
<p><img src="https://img-blog.csdnimg.cn/20200119212816978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>仔细想一下，如果仅仅知道了地址，但是不知道保存的数据类型，也是无法取出值的。<br>也就是说，上边的错误和下边的错误是一样的</p>
<p><img src="https://img-blog.csdnimg.cn/20200119213119242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>也会报同样的错误。</p>
<p>如果我们把第一个做法中printf函数稍作更改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(<span class="keyword">int</span>*)hoge_p);</span><br></pre></td></tr></table></figure>
<p>成功！</p>
<p>因此，与其写成这样，还不如刚开始就定义他的类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *hoge_p;</span><br></pre></td></tr></table></figure>
<p>这样编译器会记住 hoge_p是指向int的指针<br>这也就是为什么指针要定义他的类型。</p>
<p>关于这一点，还有一个地方需要用到他的类型：<br>==指针运算==</p>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>书写如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hoge;</span><br><span class="line">	<span class="keyword">int</span>* hoge_p;</span><br><span class="line">	hoge_p = &amp;hoge;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hoge_p 的初始地址为：%p\n&quot;</span>,hoge_p);</span><br><span class="line">	hoge_p++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hoge_p 加一后：%p\n&quot;</span>,hoge_p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hoge_p 加一之后再加三后：%p\n&quot;</span>,hoge_p + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现运行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200119214650997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>我们知道c语言地址是以16进制的方式存储的。</p>
<p>发现：</p>
<h4 id="第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12"><a href="#第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12" class="headerlink" title="第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12."></a>第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12.</h4><p>不难看出：：</p>
<h2 id="对指针加N，指针前进“当前指针指向的数据类型的长度×N”"><a href="#对指针加N，指针前进“当前指针指向的数据类型的长度×N”" class="headerlink" title="对指针加N，指针前进“当前指针指向的数据类型的长度×N”"></a>对指针加N，指针前进“当前指针指向的数据类型的长度×N”</h2>]]></content>
      <categories>
        <category>征服C指针</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上自定义各个应用快捷键</title>
    <url>/2020/02/01/Mac%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%84%E4%B8%AA%E5%BA%94%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="进入系统偏好设置"><a href="#进入系统偏好设置" class="headerlink" title="进入系统偏好设置"></a>进入系统偏好设置</h1><h2 id="键盘选项"><a href="#键盘选项" class="headerlink" title="键盘选项"></a>键盘选项</h2><h3 id="快捷键："><a href="#快捷键：" class="headerlink" title="快捷键："></a>快捷键：</h3><p><img src="https://img-blog.csdnimg.cn/20200121123450810.png" alt="在这里插入图片描述"></p>
<h3 id="选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。"><a href="#选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。" class="headerlink" title="选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。"></a>选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。</h3><p><img src="https://img-blog.csdnimg.cn/20200121123525851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>点击添加，完成！</p>
]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>swift之基本运算符</title>
    <url>/2020/01/30/swift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="本章大致介绍一些swift特别的运算符"><a href="#本章大致介绍一些swift特别的运算符" class="headerlink" title="本章大致介绍一些swift特别的运算符"></a><strong><em>本章大致介绍一些swift特别的运算符</em></strong></h2><h1 id="元组比较"><a href="#元组比较" class="headerlink" title="元组比较"></a>元组比较</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">元组比较：</span></span><br><span class="line"><span class="comment">1.从左到右比较，一旦比出结果，即大于或小于，就是整体的比较结果</span></span><br><span class="line"><span class="comment">2.如果每个对应的元祖相等，则整体的结果就是相等</span></span><br><span class="line"><span class="comment">3.要比较7个或者更多的元素的元祖，必须实现比较运算符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>,<span class="string">&quot;zebra&quot;</span>)<span class="operator">&lt;</span>(<span class="number">2</span>,<span class="string">&quot;apple&quot;</span>)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;the second win&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">3</span>,<span class="string">&quot;apple&quot;</span>)<span class="operator">&lt;</span>(<span class="number">3</span>,<span class="string">&quot;bird&quot;</span>)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;the second win&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">4</span>,<span class="string">&quot;dog&quot;</span>) <span class="operator">==</span> (<span class="number">4</span>,<span class="string">&quot;dog&quot;</span>)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;sample&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a>三元条件运算符</h1><p>与C语言中差不太多，直接上例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三元条件运算符</span></span><br><span class="line"><span class="keyword">let</span> contentHeight <span class="operator">=</span> <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight <span class="operator">=</span> contentHeight <span class="operator">+</span> (hasHeader <span class="operator">?</span> <span class="number">50</span> : <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(rowHeight)</span><br></pre></td></tr></table></figure>
<h1 id="关于-与-重点"><a href="#关于-与-重点" class="headerlink" title="关于 ? 与 !  //重点"></a>关于 ? 与 !  //重点</h1><p>swift语言中，如果不对变量进行初始化是不会自动给他一个初值的<img src="https://img-blog.csdnimg.cn/20200112143559495.png" alt="此处报错"><br>此处报错的原因就是未初始化number就对他进行了使用</p>
<p>swift中有一种可选类型。（Optionals）</p>
<h4 id="？"><a href="#？" class="headerlink" title="？"></a>？</h4><p>在定义变量时添加一个问号。以为此变量为可选类型，如果后面，给该变量赋值x。那么他就是x，如果没有赋值，他就是nil。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int</span>?</span><br><span class="line"><span class="built_in">print</span>(optionalInt)</span><br><span class="line"><span class="comment">// 此时结果是nil</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int</span>?</span><br><span class="line">optionalInt <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt)</span><br><span class="line"><span class="comment">//此时输出是Optional(1)</span></span><br></pre></td></tr></table></figure>
<p>但是现在会出现警告，就是虽然现在有值，（不管是不是nil都认为有值）。但是她现在是可选类型，应给他确定类型。</p>
<h4 id=""><a href="#" class="headerlink" title="!"></a>!</h4><p>此时 ！就是用来强制解析：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int</span>?</span><br><span class="line">optionalInt <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt<span class="operator">!</span>)</span><br><span class="line"><span class="comment">//此时输出是1</span></span><br></pre></td></tr></table></figure>
<p>此时optionalInt 是Int 类型。<br>所以有时候我们可以直接这么写：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int</span>!</span><br><span class="line">optionalInt <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt)</span><br><span class="line"><span class="comment">//此时输出是1</span></span><br></pre></td></tr></table></figure><br>==注：使用!来获取一个不存在的可选值会导致运行时错误。使用!来强制解析值之前，一定要确定可选包含一个非nil的值。==<br>也就是说如果没有第二句赋值，此程序会崩掉。<br>所以使用！时要注意这点</p>
]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C指针——和指针的第一次亲密接触</title>
    <url>/2020/01/30/%E5%85%B3%E4%BA%8EC%E6%8C%87%E9%92%88%E2%80%94%E2%80%94%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="先看代码："><a href="#先看代码：" class="headerlink" title="先看代码："></a>先看代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出每个变量的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的地址是 %p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b的地址是 %p\n&quot;</span>,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c的地址是 %p\n&quot;</span>,&amp;c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将a的地址赋予c*/</span></span><br><span class="line">    c = &amp;a;<span class="comment">//此处需用到  ”&amp;“来得到a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c修改后的地址为 %p\n&quot;</span>,c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c输出a的内容*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*c ----&gt;%d\n&quot;</span>,*c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c修改a的内容*/</span></span><br><span class="line">    *c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a----&gt;%d\n&quot;</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="然后我们看运行结果"><a href="#然后我们看运行结果" class="headerlink" title="然后我们看运行结果"></a>然后我们看运行结果</h2><p><img src="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c"><a href="#我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c" class="headerlink" title="我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c"></a>我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c</h2><p>==我们暂且先将c理解为指向int 的指针==</p>
<h2 id="再看初始化完后内存中保存的样子"><a href="#再看初始化完后内存中保存的样子" class="headerlink" title="再看初始化完后内存中保存的样子"></a>再看初始化完后内存中保存的样子<img src="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><p>在c语言中，会存在 int类型，double类型，等。。同样，c语言中也存在指针类型这样的类型。<br>指针类型并不是单独存在的，而是由其他类型派生出来的。。</p>
<p>==由引用类型T派生的指针类型有时候称为’（指向）T的指针‘==</p>
<p>因为指针类型是类型，所以他也像其他类型一样，有“指针类型的值和指针类型变量”，但有时，我们将“指针类型”，“指针类型变量”，“指针类型的值”简单统称为—-指针</p>
<p>因此 c就是一个指针类型变量——-指向int的指针，但此时并为对它赋值。</p>
<p>接下来我们将a的地址赋予了c，此时c的值就是a的地址<img src="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="接下来："><a href="#接下来：" class="headerlink" title="接下来："></a>接下来：</h2><p>在指针前面加<em>，可以表示指针指向的变量，因为现在c指向a，所以</em>c就等同于a。同理，修改*c就相当于修改了a的值。</p>
<p>==这是对后两行输出做的解释==</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>如果说c是 指向int的指针，但我们声明变量时一般要遵循：</p>
<h2 id="类型-变量名"><a href="#类型-变量名" class="headerlink" title="类型 变量名"></a>类型 变量名</h2><p>因此，我们似乎声明了一个名为*c的变量。</p>
<p>所以我们可以写成 ==int* c==的形式。这样更符合  ==类型 变量名==  的形式。</p>
<p>但之后就会出现问题：<br>数组也是C语言的一种类型。。如果按上述所说的话。<br>C语言声明数组时应该是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure>
<p>很明显，会报错。这就产生了矛盾。。</p>
<p>反而，Java中可以这么写，但是Java为了让C程序员更好的转向Java。也兼容了c语言定义数组的写法。。</p>
<p>在这里需要插一句：</p>
<h2 id="C语言的语法本来就是不自然的，奇怪的而又变态的。"><a href="#C语言的语法本来就是不自然的，奇怪的而又变态的。" class="headerlink" title="C语言的语法本来就是不自然的，奇怪的而又变态的。"></a>C语言的语法本来就是不自然的，奇怪的而又变态的。</h2><p>之后我会出一篇关于C语法的博客专门研究这“变态的”c语法。。。</p>
<p>欢迎吐槽评论</p>
]]></content>
      <categories>
        <category>征服C指针</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6-1 邻接矩阵存储图的深度优先遍历 (20 分)</title>
    <url>/2020/01/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>试实现邻接矩阵存储图的深度优先遍历。</p>
</blockquote>
<p>函数接口定义：<br>void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );<br>其中MGraph是邻接矩阵存储的图，定义如下：</p>
<p>typedef struct GNode <em>PtrToGNode;<br>struct GNode{<br>    int Nv;  /</em> 顶点数 <em>/<br>    int Ne;  /</em> 边数   <em>/<br>    WeightType G[MaxVertexNum][MaxVertexNum]; /</em> 邻接矩阵 <em>/<br>};<br>typedef PtrToGNode MGraph; /</em> 以邻接矩阵存储的图类型 */<br>函数DFS应从第V个顶点出发递归地深度优先遍历图Graph，遍历时用裁判定义的函数Visit访问每个顶点。当访问邻接点时，要求按序号递增的顺序。题目保证V是图中的合法顶点。</p>
<p>裁判测试程序样例：</p>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdio.h></h1><p>typedef enum {false, true} bool;</p>
<h1 id="define-MaxVertexNum-10-最大顶点数设为10"><a href="#define-MaxVertexNum-10-最大顶点数设为10" class="headerlink" title="define MaxVertexNum 10  / 最大顶点数设为10 /"></a>define MaxVertexNum 10  /<em> 最大顶点数设为10 </em>/</h1><h1 id="define-INFINITY-65535-∞设为双字节无符号整数的最大值65535"><a href="#define-INFINITY-65535-∞设为双字节无符号整数的最大值65535" class="headerlink" title="define INFINITY 65535   / ∞设为双字节无符号整数的最大值65535/"></a>define INFINITY 65535   /<em> ∞设为双字节无符号整数的最大值65535</em>/</h1><p>typedef int Vertex;      /<em> 用顶点下标表示顶点,为整型 </em>/<br>typedef int WeightType;  /<em> 边的权值设为整型 </em>/</p>
<p>typedef struct GNode <em>PtrToGNode;<br>struct GNode{<br>    int Nv;  /</em> 顶点数 <em>/<br>    int Ne;  /</em> 边数   <em>/<br>    WeightType G[MaxVertexNum][MaxVertexNum]; /</em> 邻接矩阵 <em>/<br>};<br>typedef PtrToGNode MGraph; /</em> 以邻接矩阵存储的图类型 <em>/<br>bool Visited[MaxVertexNum]; /</em> 顶点的访问标记 */</p>
<p>MGraph CreateGraph(); /<em> 创建图并且将Visited初始化为false；裁判实现，细节不表 </em>/</p>
<p>void Visit( Vertex V )<br>{<br>    printf(“ %d”, V);<br>}</p>
<p>void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );</p>
<p>int main()<br>{<br>    MGraph G;<br>    Vertex V;</p>
<pre><code>G = CreateGraph();
scanf(&quot;%d&quot;, &amp;V);
printf(&quot;DFS from %d:&quot;, V);
DFS(G, V, Visit);

return 0;
</code></pre><p>}</p>
<p>/<em> 你的代码将被嵌在这里 </em>/<br>输入样例：给定图如下</p>
<p>5<br>输出样例：<br>DFS from 5: 5 1 3 0 2 4 6<br>作者: DS课程组<br>单位: 浙江大学<br>时间限制: 400 ms<br>内存限制: 64 MB</p>
<h2 id="很明显这个用递归就可以了"><a href="#很明显这个用递归就可以了" class="headerlink" title="很明显这个用递归就可以了"></a>很明显这个用递归就可以了</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( MGraph Graph, Vertex V, <span class="keyword">void</span> (*Visit)(Vertex) )</span></span>&#123;</span><br><span class="line">    Visited[V] = <span class="literal">true</span>;</span><br><span class="line">    Visit(V);</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;MaxVertexNum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Graph-&gt;G[V][i] == <span class="number">1</span> &amp;&amp; !Visited[i]) &#123;</span><br><span class="line">            DFS(Graph,i,Visit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据提要求访问过的节点需要true<br>所以在此访问还应判断该节点是不是false</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔非递归实现 C语言版</title>
    <url>/2020/01/21/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0c%E8%AF%AD%E8%A8%80%E7%89%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="汉诺塔非递归实现-C语言版"><a href="#汉诺塔非递归实现-C语言版" class="headerlink" title="汉诺塔非递归实现 C语言版"></a><strong><em>汉诺塔非递归实现 C语言版</em></strong></h1><p>我上一篇博客是汉诺塔C语言递归实现，非递归和递归想法一样。这里不再赘述，直接链接转到：</p>
<p><a href="https://blog.csdn.net/VistorsYan/article/details/102765478">汉诺塔递归实现 C语言版</a></p>
<p>   递归实现固然好理解，但是n的值越大，空间和时间上都是极大的消耗，最终可能导致程序直接崩溃。<br>在以后的做题或者是面试中，不推荐用递归方法做，所以要写出对应的非递归方法。</p>
<p>  某次上课无意间听到老师说了这样一句话：任何递归法都可以用循环的方法进行非递归实现，然后回头找了找汉诺塔非递归的资料，整理整理，搞出了一个c实现的非递归方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#define MaxSize 100</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">     int N;</span><br><span class="line">     char A;        //起始柱</span><br><span class="line">     char B;        //借助柱</span><br><span class="line">     char C;        //目标柱</span><br><span class="line">&#125;ElementType;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    int top;</span><br><span class="line">&#125;Stack;//汉诺塔问题的结构类型</span><br><span class="line">void Push(Stack *PtrS, ElementType item)&#123;</span><br><span class="line">     //入栈操作</span><br><span class="line">     <span class="keyword">if</span> (PtrS-&gt;top == MaxSize)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;The stack is full!\n&quot;</span>);</span><br><span class="line">         <span class="built_in">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         PtrS-&gt;Data[++(PtrS-&gt;top)] = item;</span><br><span class="line">         <span class="built_in">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">ElementType Pop(Stack *PtrS)&#123;</span><br><span class="line">    <span class="keyword">if</span> (PtrS-&gt;top == -1)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;The stack is empty!\n&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(1);   //直接终止程序，一般不会出现这个错误</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          PtrS-&gt;top--;</span><br><span class="line">         <span class="built_in">return</span> (PtrS-&gt;Data[PtrS-&gt;top + 1]);        //或者是<span class="built_in">return</span> PtrS-&gt;Data[PtrS-&gt;top--];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">//借助栈的非递归实现</span><br><span class="line"> void Hanoi(int n)&#123;</span><br><span class="line">    ElementType P, toPush;</span><br><span class="line">    Stack S;</span><br><span class="line"></span><br><span class="line">    P.N = n; P.A = <span class="string">&#x27;a&#x27;</span>; P.B = <span class="string">&#x27;b&#x27;</span>; P.C = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    S.top = -1;</span><br><span class="line"></span><br><span class="line">     Push(&amp;S, P);</span><br><span class="line">     <span class="keyword">while</span> (S.top != -1)        //当堆栈不为空时</span><br><span class="line">     &#123;</span><br><span class="line">         P = Pop(&amp;S);//出栈</span><br><span class="line">         <span class="keyword">if</span> (P.N == 1)//当只剩一个盘子时，直接由当前柱移动到目的柱</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, P.A, P.C);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             toPush.N = P.N - 1;</span><br><span class="line">             toPush.A = P.B; toPush.B = P.A; toPush.C = P.C;</span><br><span class="line">             Push(&amp;S, toPush);        //将第三步(n - 1, b, a, c)入栈</span><br><span class="line">             toPush.N = 1;</span><br><span class="line">             toPush.A = P.A; toPush.B = P.B; toPush.C = P.C;</span><br><span class="line">             Push(&amp;S, toPush);        //将第二步1, a, b, c)入栈</span><br><span class="line">             toPush.N = P.N - 1;</span><br><span class="line">             toPush.A = P.A; toPush.B = P.C; toPush.C = P.B;</span><br><span class="line">             Push(&amp;S, toPush);        //将第一步(n - 1, a, c, b)入栈</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= 0)<span class="built_in">return</span> 0;</span><br><span class="line">    <span class="keyword">else</span> Hanoi(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是三个步骤：<br>1.将n-1个盘子由a柱借助c柱移动到b柱<br>2.将最下面的盘子由a柱直接移动到c柱<br>3.将那n-1个盘子在由b柱借助a柱移动到c柱</p>
<p>因为这个是出栈时的操作，所以入栈时要到着写</p>
<h2 id="简要解释一下（因为跟递归思路差不多）"><a href="#简要解释一下（因为跟递归思路差不多）" class="headerlink" title="简要解释一下（因为跟递归思路差不多）"></a>简要解释一下（因为跟递归思路差不多）</h2><p>如果n不等于一时，就意味着，以上的n-1个盘子，都要做上述所说的三个步骤，知道n等于1时，直接移动到目的柱。<br>因此，移动次数最多的是最上边的那个盘子，移动次数最少的是最下面的那个盘子，只需要移动一次</p>
<p>利用结构体数组更便于理解。</p>
<p>本文为原创，如有问题欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>2-5 修理牧场 (35分) 哈夫曼树例题 c与c++鸳鸯解法 详细解释</title>
    <url>/2020/01/20/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91--%E4%BF%AE%E7%90%86%E7%89%A7%E5%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数Li个长度单位，于是他购买了一条很长的、能锯成N块的木头，即该木头的长度是Li​​的总和。</p>
<p>但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。</p>
<p>请编写程序帮助农夫计算将木头锯成N块的最少花费。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入首先给出正整数N（≤10000​​ ），表示要将木头锯成N块。第二行给出N个正整数（≤50），表示每段木块的长度。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>输出一个整数，即将木头锯成N块的最少花费。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><p>8<br>4 5 1 2 1 3 1 1</p>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><p>49</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。"><a href="#构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。" class="headerlink" title="构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。"></a>构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。</h2><p>实际上是没必要构造一颗树的，运用他的原理即可</p>
<p>其实这两个解法差不多，但是c++更加的简单易于理解，在时间上也是很短的。c相对而言就比较暴力了。相当于对c++解法的底层解释。注重基础。<br><code>
</code></p>
<h2 id="c-解法"><a href="#c-解法" class="headerlink" title="c++解法"></a>c++解法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,n,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        Q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a=Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> b=Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        Q.<span class="built_in">push</span>(a+b);</span><br><span class="line">        sum+=a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里解释一下这句话<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; Q;</span><br></pre></td></tr></table></figure><br>priority_queue<Type, Container, Functional>，其中Type 为数据类型，Container为保存数据的容器，Functional 为元素比较方式。<br>Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。<br>greater 可以实现由底部到顶部大到小实现。<br>所以这道题的步骤就是，<br>push出两个最小值并相加，将相加的值加到sum并放回Q中，然后会重新排列大小。<br>以此类推</p>
<p><img src="https://img-blog.csdnimg.cn/20191207174941948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>不仅代码量很少，时间也是很短的，考试的时候可以使用，平时练习不建议，有点投机取巧。练习还是用c一步步实现他的每一个步骤。</p>
<h2 id="c解法"><a href="#c解法" class="headerlink" title="c解法"></a>c解法</h2><p>用c语言其实就是对c++的具体实现，（可能我这个不是最好的解法。）但是每次取每次放都需要重新排序，这将是一件很累的事情。所以干脆就不排序了，直接放在那，取的时候再去判断最小值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10010</span>],n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Max+<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span> (min&gt;a[i]) min = a[i];</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == x) &#123;</span><br><span class="line">            a[i] = Max;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == Max) &#123;</span><br><span class="line">            a[i] = x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = findMin();</span><br><span class="line">        Delete(x);</span><br><span class="line">        <span class="keyword">int</span> y = findMin();</span><br><span class="line">        Delete(y);</span><br><span class="line">        add(x+y);</span><br><span class="line">        sum2+=x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注明一下：删除其实就是把现在这个数组里这个值（不一定是之前取的那个数）给赋值为非常大，这样下次寻找最小值就不会找到他。<br>如果有添加，那么之前一定有删除，直接把添加的值放在删除的值的地方就行了。<br>Max一定要特别大，要不然，最大值测试用例时，x+y的值甚至会大过Max，这样就出错了。<br>这个实现就很耗时了，算是锻炼思维把。<br><img src="https://img-blog.csdnimg.cn/20191207180030125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="如果有更好的解法，或者是有什么问题的话，欢迎留言。"><a href="#如果有更好的解法，或者是有什么问题的话，欢迎留言。" class="headerlink" title="如果有更好的解法，或者是有什么问题的话，欢迎留言。"></a>如果有更好的解法，或者是有什么问题的话，欢迎留言。</h1>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA 树种统计  c语言-------二叉搜索树 详细解释</title>
    <url>/2020/01/20/%E6%A0%91%E7%A7%8D%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="树种统计"><a href="#树种统计" class="headerlink" title="树种统计"></a>树种统计</h1><h2 id="这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。"><a href="#这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。" class="headerlink" title="这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。"></a>这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。</h2><p>随着卫星成像技术的应用，自然资源研究机构可以识别每一棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。</p>
<p>输入格式:<br>输入首先给出正整数N（≤10<br>​5<br>​​ ），随后N行，每行给出卫星观测到的一棵树的种类名称。种类名称由不超过30个英文字母和空格组成（大小写不区分）。</p>
<p>输出格式:<br>按字典序递增输出各种树的种类名称及其所占总数的百分比，其间以空格分隔，保留小数点后4位。</p>
<h2 id="第一眼直观感受是用数组常规排序？？？-但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。"><a href="#第一眼直观感受是用数组常规排序？？？-但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。" class="headerlink" title="第一眼直观感受是用数组常规排序？？？ 但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。"></a>第一眼直观感受是用数组常规排序？？？ 但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。</h2><h2 id="这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O-logN-。根据二维图像，可以想象数据量越大，O-logN-会越来越趋近与O-1"><a href="#这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O-logN-。根据二维图像，可以想象数据量越大，O-logN-会越来越趋近与O-1" class="headerlink" title="这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O(logN)。根据二维图像，可以想象数据量越大，O(logN)会越来越趋近与O(1)"></a><strong><em>这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O(logN)。根据二维图像，可以想象数据量越大，O(logN)会越来越趋近与O(1)</em></strong></h2><h2 id="在回归这道题，数组里的二分法是去查找元素。。-而这道题是把元素按顺序输出，所以还是不行。。。。"><a href="#在回归这道题，数组里的二分法是去查找元素。。-而这道题是把元素按顺序输出，所以还是不行。。。。" class="headerlink" title="在回归这道题，数组里的二分法是去查找元素。。 而这道题是把元素按顺序输出，所以还是不行。。。。"></a>在回归这道题，数组里的二分法是去查找元素。。 而这道题是把元素按顺序输出，所以还是不行。。。。</h2><p>最后想了想二分法在树里的应用</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>在输入时就开始构造二叉搜索树。。</p>
<p>然后中序遍历输出就可以了。。。<br>左中右 正好是有小到大。。<br>至于后面那个频率，加个计数器，最后除以总数就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 思路：已二叉搜索树的方式保存输入的名称，并赋予一个计数器。然后中序遍历输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">31</span>];</span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">    <span class="keyword">int</span> k;<span class="comment">//计数器</span></span><br><span class="line">&#125;tree[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InVisit</span><span class="params">(struct TreeNode Tree,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Tree.left == Null &amp;&amp; Tree.right == Null) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %.4f%%\n&quot;</span>,Tree.data,Tree.k/(<span class="keyword">double</span>)n*<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Tree.left!=Null) &#123;</span><br><span class="line">        InVisit(tree[Tree.left],n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %.4f%%\n&quot;</span>,Tree.data,Tree.k/(<span class="keyword">double</span>)n*<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (Tree.right!=Null) &#123;</span><br><span class="line">        InVisit(tree[Tree.right],n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,temp = <span class="number">0</span>,flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        tree[i].k = <span class="number">0</span>;</span><br><span class="line">        tree[i].left = Null;</span><br><span class="line">        tree[i].right = Null;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        gets(tree[i].data);</span><br><span class="line">        <span class="comment">//二叉搜索树插入 数组保存法</span></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tree[i].data, tree[temp].data)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[temp].left!=Null) &#123;</span><br><span class="line">            temp = tree[temp].left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tree[temp].left = i;</span><br><span class="line">                tree[i].k++;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tree[i].data, tree[temp].data)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[temp].right!=Null) &#123;</span><br><span class="line">                temp = tree[temp].right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tree[temp].right = i;</span><br><span class="line">                tree[i].k++;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tree[temp].k++;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    InVisit(tree[<span class="number">0</span>],n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我用的数组的方法保存树<br>当然也可以用链表储存，但是链表消耗内存过大。。。个人不太建议。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>LeeCode第二题常见报错</title>
    <url>/2020/01/19/leeCode%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%981/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><hr>
<h2 id="LeeCode第二题"><a href="#LeeCode第二题" class="headerlink" title="LeeCode第二题"></a>LeeCode第二题</h2><p>两数相加 c语言实现报错解决</p>
<hr>
<p>runtime error: member access within misaligned address 0xbebebebebebebebe for type ‘struct ListNode’, which requires 8 byte alignment (ListNode.c)<br>0xbebebebebebebebe: note: pointer points here</p>
<memory cannot be printed>

<p>*</p>
<p>同样的思路，用Java实现可以运行，但是c语言却频频出现了上述所说的错误。困扰了我许多天，最后参考了一下csdn上大佬的想法，然后仔细在读这个错误，原因在你申请一个节点空间时，它的next指针也诞生出来了，注意这句note: pointer points here<br>说明有指针，但是你没有让他指向一个地址。所以出现这个错误，所以在你申请一个节点空间后，紧跟着把它的next赋值为空就可以了。</p>
<p>*<br>顺便呈上我的代码吧，思路就不多解释了，比较容易懂</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2)&#123;</span><br><span class="line">    struct ListNode *p1,*p2,*p ,*h;</span><br><span class="line">    struct ListNode *head = malloc(sizeof(struct ListNode));</span><br><span class="line">    p1 = l1;</span><br><span class="line">    p2 = l2;</span><br><span class="line">    p = head;</span><br><span class="line"></span><br><span class="line">    int t = 0;</span><br><span class="line">    <span class="keyword">while</span> (p1||p2) &#123;</span><br><span class="line">        int x = (p1!=NULL) ? p1-&gt;val:0;</span><br><span class="line">        int y = (p2!=NULL) ? p2-&gt;val:0;</span><br><span class="line">        int sum = x + y +t;</span><br><span class="line">        t = sum/10;</span><br><span class="line">        h = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">        h-&gt;next = NULL;//赋值为空</span><br><span class="line">        p-&gt;next = h;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        h-&gt;val = sum%10;</span><br><span class="line">        <span class="keyword">if</span> (p1) p1 = p1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p2) p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t&gt;0) &#123;</span><br><span class="line">        p-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        p-&gt;val = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时间比较菜，如果有什么可以改进的话，或者更好的方法欢迎留言！！</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔递归实现c语言版</title>
    <url>/2020/01/19/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0c%E8%AF%AD%E8%A8%80%E7%89%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="汉诺塔问题-递归实现法"><a href="#汉诺塔问题-递归实现法" class="headerlink" title="汉诺塔问题 递归实现法"></a><strong><em>汉诺塔问题 递归实现法</em></strong></h2><p><strong>话不多说直接上代码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">void Move(int n ,char from ,char to)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>,from,to);</span><br><span class="line">&#125;</span><br><span class="line">void hanoi(int n ,char from,char depend,char to)&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == 1) &#123;</span><br><span class="line">        //当剩一个盘子的时候，直接移动到目的柱</span><br><span class="line">        Move(1, from, to);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        hanoi(n-1,from,to,depend);//将初始柱的前n-1个盘子借助目的塔移动到借用柱上</span><br><span class="line">        Move(n,from,to);              //将剩下的一个盘子移动到目的柱上</span><br><span class="line">        hanoi(n-1,depend,from,to);//将b柱n-1个盘子移动到借用a柱移动到c上</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    char x = <span class="string">&#x27;A&#x27;</span>,y = <span class="string">&#x27;B&#x27;</span>,z = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;盘子移动情况如下：\n&quot;</span>);</span><br><span class="line">    hanoi(n, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路：<br>不管多少个盘子（一个盘子的时候除外），全部都看作是两个盘子<br>即 最下面的那一个，和其上面的(n-1)个。<br>这样两个盘子的时候，移动就非常简单了。</p>
<p><strong>总共有三步：</strong><br>1.将第一个(也就是n-1)个盘子借助C柱从A柱移动到B柱。<br>2.将最下面的那一个盘子直接从A柱移动到C柱。<br>3.最后将B柱的那些(n-1)个盘子借助A柱移动到C柱。</p>
<p>所以在入口参数的时候需要，起始柱，借助柱（有点绕口），目的柱。</p>
<p>刚开始可能有些看不太懂，可以先输入几个简单的数，用断点调试，看一下他的移动过程。<br>递归函数的终点就是只剩一个盘子的时候，直接移动到目的柱。</p>
<p><strong><em>如果明白了就不用看我下面的废话了</em></strong></p>
<p>假设有64个盘子，那么问题就成了移动63和最下面的盘子。分成了两组去完成我上述说的那三步。<br>接着63个盘子去做第一步时就已经开始了递归。<br>递归到下一级时，就意味着再把63个盘子看成一个整体。分成两部分，最下面的一块和上面的62块。去完成这件事，以此类推，直到第一块。<br>因为只有前62块都完成移动，才可以移动到第六十三块。</p>
<p>不要去想着这个过程，很容易绕晕的，只需要知道这个函数的功能就是移动盘子。</p>
<p><strong><em>下篇博客写汉诺塔非递归算法，c语言实现。 </em></strong></p>
<blockquote>
<p>参考博客<br><a href="https://blog.csdn.net/csshuke/article/details/82630311">https://blog.csdn.net/csshuke/article/details/82630311</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C指针----和指针的第一次亲密接触</title>
    <url>/2020/01/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="先看代码："><a href="#先看代码：" class="headerlink" title="先看代码："></a>先看代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出每个变量的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的地址是 %p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b的地址是 %p\n&quot;</span>,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c的地址是 %p\n&quot;</span>,&amp;c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将a的地址赋予c*/</span></span><br><span class="line">    c = &amp;a;<span class="comment">//此处需用到  ”&amp;“来得到a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c修改后的地址为 %p\n&quot;</span>,c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c输出a的内容*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*c ----&gt;%d\n&quot;</span>,*c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c修改a的内容*/</span></span><br><span class="line">    *c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a----&gt;%d\n&quot;</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="然后我们看运行结果"><a href="#然后我们看运行结果" class="headerlink" title="然后我们看运行结果"></a>然后我们看运行结果</h2><p><img src="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c"><a href="#我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c" class="headerlink" title="我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c"></a>我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c</h2><p>==我们暂且先将c理解为指向int 的指针==</p>
<h2 id="再看初始化完后内存中保存的样子"><a href="#再看初始化完后内存中保存的样子" class="headerlink" title="再看初始化完后内存中保存的样子"></a>再看初始化完后内存中保存的样子<img src="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><p>在c语言中，会存在 int类型，double类型，等。。同样，c语言中也存在指针类型这样的类型。<br>指针类型并不是单独存在的，而是由其他类型派生出来的。。</p>
<p>==由引用类型T派生的指针类型有时候称为’（指向）T的指针‘==</p>
<p>因为指针类型是类型，所以他也像其他类型一样，有“指针类型的值和指针类型变量”，但有时，我们将“指针类型”，“指针类型变量”，“指针类型的值”简单统称为—-指针</p>
<p>因此 c就是一个指针类型变量——-指向int的指针，但此时并为对它赋值。</p>
<p>接下来我们将a的地址赋予了c，此时c的值就是a的地址<img src="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="接下来："><a href="#接下来：" class="headerlink" title="接下来："></a>接下来：</h2><p>在指针前面加<em>，可以表示指针指向的变量，因为现在c指向a，所以</em>c就等同于a。同理，修改*c就相当于修改了a的值。</p>
<p>==这是对后两行输出做的解释==</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>如果说c是 指向int的指针，但我们声明变量时一般要遵循：</p>
<h2 id="类型-变量名"><a href="#类型-变量名" class="headerlink" title="类型 变量名"></a>类型 变量名</h2><p>因此，我们似乎声明了一个名为*c的变量。</p>
<p>所以我们可以写成 ==int* c==的形式。这样更符合  ==类型 变量名==  的形式。</p>
<p>但之后就会出现问题：<br>数组也是C语言的一种类型。。如果按上述所说的话。<br>C语言声明数组时应该是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure>
<p>很明显，会报错。这就产生了矛盾。。</p>
<p>反而，Java中可以这么写，但是Java为了让C程序员更好的转向Java。也兼容了c语言定义数组的写法。。</p>
<p>在这里需要插一句：</p>
<h2 id="C语言的语法本来就是不自然的，奇怪的而又变态的。"><a href="#C语言的语法本来就是不自然的，奇怪的而又变态的。" class="headerlink" title="C语言的语法本来就是不自然的，奇怪的而又变态的。"></a>C语言的语法本来就是不自然的，奇怪的而又变态的。</h2><p>之后我会出一篇关于C语法的博客专门研究这“变态的”c语法。。。</p>
<p>欢迎吐槽评论</p>
]]></content>
      <categories>
        <category>征服C指针</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
</search>
