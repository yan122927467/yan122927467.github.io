<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UIKit与swiftUI 交互</title>
    <url>/2020/02/09/swiftui%E4%B8%8Euikit%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="UIKit与swiftUI-交互"><a href="#UIKit与swiftUI-交互" class="headerlink" title="UIKit与swiftUI 交互"></a>UIKit与swiftUI 交互</h1><p>运用swiftUI写界面非常迅速且酷炫。大大减少了曾经在UIKit中的代码量。<br>不过有时候可能你还会需要用到UIKit，但是你又想用swiftUI做界面，此时就考虑到二者交互的问题了。</p>
<h2 id="UIViewControllerRepresentable"><a href="#UIViewControllerRepresentable" class="headerlink" title="UIViewControllerRepresentable"></a>UIViewControllerRepresentable</h2><p><strong>在swiftUI中提供了一个UIViewControllerRepresentable协议</strong><br><strong>我们可以用它作为UIKit 与swiftUI的桥接</strong><br><a href="https://img-blog.csdnimg.cn/20200113121716232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200113121716232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h1 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h1><h2 id="你依然可以像往常一样，新建一个swift文件，把他命名为viewController-然后导入UiKit-，然后再让它继承UIViewController-重写父类的viewDidLoad-方法，你也可以往里面随便添点东西，为后面验证做准备，just-like-this"><a href="#你依然可以像往常一样，新建一个swift文件，把他命名为viewController-然后导入UiKit-，然后再让它继承UIViewController-重写父类的viewDidLoad-方法，你也可以往里面随便添点东西，为后面验证做准备，just-like-this" class="headerlink" title="你依然可以像往常一样，新建一个swift文件，把他命名为viewController 然后导入UiKit ，然后再让它继承UIViewController 重写父类的viewDidLoad()方法，你也可以往里面随便添点东西，为后面验证做准备，just like this.."></a>你依然可以像往常一样，新建一个swift文件，把他命名为viewController 然后导入UiKit ，然后再让它继承UIViewController 重写父类的viewDidLoad()方法，你也可以往里面随便添点东西，为后面验证做准备，just like this..<a href="https://img-blog.csdnimg.cn/20200113122152672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200113122152672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></h2><h1 id="第二步-桥接"><a href="#第二步-桥接" class="headerlink" title="第二步 桥接"></a>第二步 桥接</h1><h2 id="第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController-他需要遵循并实现UIViewControllerRepresentable这个协议"><a href="#第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController-他需要遵循并实现UIViewControllerRepresentable这个协议" class="headerlink" title="第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController 他需要遵循并实现UIViewControllerRepresentable这个协议"></a>第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController 他需要遵循并实现UIViewControllerRepresentable这个协议</h2><h1 id="第三步-应用"><a href="#第三步-应用" class="headerlink" title="第三步 应用"></a>第三步 应用</h1><h2 id="接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了"><a href="#接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了" class="headerlink" title="接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了"></a>接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了<a href="https://img-blog.csdnimg.cn/20200113125213490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="第二步与第三步" class="fancybox"><img alt="第二步与第三步" title="第二步与第三步" data-src="https://img-blog.csdnimg.cn/20200113125213490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></h2><h1 id="显示效果如图"><a href="#显示效果如图" class="headerlink" title="显示效果如图"></a>显示效果如图</h1><p><a href="https://img-blog.csdnimg.cn/20200113130421611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200113130421611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h1 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h1><p>viewController.swift 文件中：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">viewController</span>: <span class="title">UIViewController</span></span>{</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = .brown</span><br><span class="line">        <span class="keyword">let</span> viewDemo = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">        viewDemo.backgroundColor = .green</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(viewDemo)</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>ConventView.swift 文件中</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//UIKit 桥接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UIBridging</span>: <span class="title">UIViewControllerRepresentable</span> </span>{</span><br><span class="line">    <span class="comment">//这个UIViewControllerType你要接哪个就是哪个，在这里就是viewController</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">UIViewControllerType</span> = viewController</span><br><span class="line">    <span class="comment">//必须实现的方法，当swiftUI要显示view时，会调用这个方法。返回值就是当前需要显示的类</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIViewController</span><span class="params">(context: UIViewControllerRepresentableContext<uibridging>)</uibridging></span></span> -> <span class="type">UIBridging</span>.<span class="type">UIViewControllerType</span> {</span><br><span class="line">        <span class="keyword">return</span> viewController()</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//更新UIViewController时会调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIViewController</span><span class="params">(<span class="number">_</span> uiViewController: viewController, context: UIViewControllerRepresentableContext<uibridging>)</uibridging></span></span> {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span></span>{</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">UIBridging</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView_Previews</span>: <span class="title">PreviewProvider</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">ContentView</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些"><a href="#注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些" class="headerlink" title="注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些"></a>注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些</h2></body></html>]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>swiftUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeblocks中文乱码解决方法</title>
    <url>/2020/02/07/Codeblocks%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><p>Codeblocks中文乱码解决方法：</p>
<p>特别提示：出现中文乱码情况才执行以下操作，未出现请勿随意修改！！！！</p>
<p>打开Codeblocks -> 设置 -> 编辑器：</p>
<p><a href="https://img-blog.csdnimg.cn/20191205172416635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191205172416635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>然后点击 Encoding settings -> 选择编码 -> 选择UTF-8 -> 确定：</p>
<p><a href="https://img-blog.csdnimg.cn/20191205172454640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191205172454640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p><a href="https://img-blog.csdnimg.cn/20191205172512827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191205172512827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>点击设置 -> 编译器：</p>
<p><a href="https://img-blog.csdnimg.cn/20191205172528406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191205172528406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>点击Other compiler options->在空白处输入</p>
<p> -finput-charset=UTF-8</p>
<p>-fexec-charset=GBK</p>
<p>点击确定 -> 随意修改下代码 ->重新生成。</p>
<p><a href="https://img-blog.csdnimg.cn/2019120517254235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019120517254235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>即可解决乱码问题。</p>
</body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>mac与windows兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac修改键盘之 将 caps lock修改为esc</title>
    <url>/2020/02/05/Mac%E4%BF%AE%E6%94%B9%E9%94%AE%E7%9B%98%E4%B9%8B%E5%B0%86%E5%A4%A7%E5%B0%8F%E5%86%99%E9%94%81%E5%AE%9A%E4%BF%AE%E6%94%B9esc/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。"><a href="#想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。" class="headerlink" title="想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。"></a>想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。</h3><h3 id="大多数的人都是将caps-lock-修改为esc。"><a href="#大多数的人都是将caps-lock-修改为esc。" class="headerlink" title="大多数的人都是将caps lock 修改为esc。"></a>大多数的人都是将caps lock 修改为esc。</h3><p>因为caps lock 处在了最重要的位置却几乎不怎么使用他，如果用大写直接按住shift就可以了。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>之前在网上查到了关于此类的问题，说需要下载一个第三方软件，我推荐一个非常简单的方法，就在mac的设置里：</p>
<h4 id="找到系统偏好设置——-gt-键盘——-gt-左下角有一个修饰键"><a href="#找到系统偏好设置——-gt-键盘——-gt-左下角有一个修饰键" class="headerlink" title="找到系统偏好设置——>键盘——->左下角有一个修饰键"></a>找到系统偏好设置——>键盘——->左下角有一个修饰键</h4><p><a href="https://img-blog.csdnimg.cn/20200119094846166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119094846166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a><br>把第一个改成Escape就好啦</p>
<h1 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h1><p>实际上如图所示，mac已经提供了部分功能的修改，如果还想修改别的键，直接修改就好了</p>
</body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客基础命令</title>
    <url>/2020/02/04/hello-world/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
</body></html>]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 基础操作 + 配置文件设置 基础版 for mac</title>
    <url>/2020/02/03/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C+%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="vim-模式"><a href="#vim-模式" class="headerlink" title="vim 模式"></a>vim 模式</h2><h3 id="1-normal模式"><a href="#1-normal模式" class="headerlink" title="1.normal模式"></a>1.normal模式</h3><p>当我们用vim创建或者打开一个文件的时候，就是normal模式，然后我们可以输入一些指令，更加方便的操作文件。</p>
<h3 id="2-insert模式"><a href="#2-insert模式" class="headerlink" title="2.insert模式"></a>2.insert模式</h3><p>顾名思义就是可以进行编辑自己的文件内容了，从normal模式到insert模式有很多种快捷键，稍后一一说明。但是从insert模式到normal模式需要按esc键，没错，当我们常用到vim进行编辑的时候，会非常频繁的使用esc，但是他的位置却不是很让我们提高效率，在这里我们可以吧caps lock 修改为esc ，毕竟caps lock 真的没什么用，却处于一个非常方便的位置。</p>
<p>==具体修改可以看这篇博客，这里不再赘述==</p>
<p><a href="https://blog.csdn.net/VistorsYan/article/details/104036840" target="_blank" rel="noopener">Mac修改键盘之 将 caps lock修改为esc</a></p>
<h2 id="基本操作命令（增删改查-保存退出）"><a href="#基本操作命令（增删改查-保存退出）" class="headerlink" title="基本操作命令（增删改查+保存退出）"></a>基本操作命令（增删改查+保存退出）</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>在光标前写入</td>
</tr>
<tr>
<td>a</td>
<td>在光标后插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标所在行下一行插入一新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标所在行上一行插入一新行</td>
</tr>
<tr>
<td>shift+i</td>
<td>行前插入</td>
</tr>
<tr>
<td>shift + a</td>
<td>行尾插入</td>
</tr>
<tr>
<td>h j k l</td>
<td>光标移动：←↓↑→   上下左右键也可移动</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>删除当前光标所在的字符</td>
</tr>
<tr>
<td>:wq然后回车</td>
<td>保存并退出</td>
</tr>
<tr>
<td>dd</td>
<td>剪切当前行</td>
</tr>
<tr>
<td>p/P</td>
<td>粘贴 前者是在光标之前，后者是在光标之后</td>
</tr>
<tr>
<td>yy</td>
<td>拷贝当前行</td>
</tr>
<tr>
<td>/+要输入的字符串</td>
<td>在文本中查找改字符串</td>
</tr>
</tbody></table>
<h1 id="配置文件设置"><a href="#配置文件设置" class="headerlink" title="配置文件设置"></a>配置文件设置</h1><h2 id="创建vim配置文件"><a href="#创建vim配置文件" class="headerlink" title="创建vim配置文件"></a>创建vim配置文件</h2><h3 id="在根目录下找到-vim文件夹并打开"><a href="#在根目录下找到-vim文件夹并打开" class="headerlink" title="在根目录下找到 .vim文件夹并打开"></a>在根目录下找到 .vim文件夹并打开</h3><p>注：如果没有就新建一个.vim文件夹并打开即可。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"><span class="built_in">cd</span> .vim</span><br></pre></td></tr></tbody></table></figure></div>
<h3 id="然后-在当前路径下："><a href="#然后-在当前路径下：" class="headerlink" title="然后 在当前路径下："></a>然后 在当前路径下：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">vim vimrc</span><br></pre></td></tr></tbody></table></figure></div>
<p>这样就有打开了一个新的文件，这就是配置文件，你可以在这里进行“肆意的”修改</p>
<h2 id="键位修改"><a href="#键位修改" class="headerlink" title="键位修改"></a>键位修改</h2><p>有时vim的一些快捷键很不合你的口味，比如方向键，所以可以把方向键的位置改为符合方向的键。</p>
<h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>我想把h 键改为 i：（直接在vimrc里面写）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">noremap i h</span><br></pre></td></tr></tbody></table></figure></div>
<p>此时i键有着和h一样的功能，但是i键本来是有功能的（插入），因此==切记==不要忘了把i给改为别的键，如果你还想用这个功能的话。</p>
<h2 id="指令快捷化"><a href="#指令快捷化" class="headerlink" title="指令快捷化"></a>指令快捷化</h2><p>vim 保存命令是在normal模式下输入 :w 然后回车，虽然很方便了，但是可以更快：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> S :<span class="keyword">w</span><span class="symbol"><cr></cr></span></span><br></pre></td></tr></tbody></table></figure></div>
<p>现在直接用S即可保存，（w后的不用我说也清楚是回车的意思）<br>以此类推：举几个常用的例子</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> s <span class="symbol"><nop></nop></span></span><br></pre></td></tr></tbody></table></figure></div>
<p>nop(no operation) ==取消s的功能==</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> Q :q<span class="symbol"><cr></cr></span></span><br></pre></td></tr></tbody></table></figure></div>
<p>退出</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> R :<span class="keyword">source</span> $MYVIMRC<span class="symbol"><cr></cr></span></span><br></pre></td></tr></tbody></table></figure></div>
<p>刷新（应用的意思）<br>注：这些都需要保存退出以后才能生效，如果刷新，即刻生效</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">synatx <span class="keyword">on</span></span><br></pre></td></tr></tbody></table></figure></div>
<p>代码高亮</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="keyword">set</span> cursorline</span><br><span class="line"><span class="keyword">set</span> wrap</span><br><span class="line"><span class="keyword">set</span> wildmenu</span><br></pre></td></tr></tbody></table></figure></div>
<p>打开行号<br>添加下划线<br>如果该行已满 自动换行<br>命令自动补全 tab 同bash</p>
<h4 id="有关查找的指令"><a href="#有关查找的指令" class="headerlink" title="有关查找的指令"></a>有关查找的指令</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hlsearch</span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line">exec <span class="string">"nohlsearch"</span></span><br><span class="line"><span class="keyword">set</span> ignorecase</span><br><span class="line"><span class="keyword">set</span> smartcase</span><br></pre></td></tr></tbody></table></figure></div>
<p>查找时高亮显示<br>边输入边高亮<br>当再次进入文件时不显示高亮，否则还会显示上次查找的高亮<br>忽视高亮<br>忽略大小写<br>智能大小写</p>
<p>==注：查找完后会依然显示高亮，去除高亮的命令是==</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">:<span class="keyword">nohlsearch</span><span class="symbol"><cr></cr></span></span><br></pre></td></tr></tbody></table></figure></div>
<p>可以根据自己的意愿，按上边的方式修改一下快捷键去除查找后的高亮</p>
<p>以上仅提供了一些基础常用的设置，还不是全部。。。。<br>有什么更好的指令欢迎下方留言，嘻嘻😬</p>
</body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>C指针问题之不同类型指针之间的区别</title>
    <url>/2020/02/02/C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E4%B9%8B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="会想这样的一个问题："><a href="#会想这样的一个问题：" class="headerlink" title="会想这样的一个问题："></a>会想这样的一个问题：</h1><h3 id="指针就是地址吧，那么指向int-的指针也好，指向double的指针也好，他们有什么不同么"><a href="#指针就是地址吧，那么指向int-的指针也好，指向double的指针也好，他们有什么不同么" class="headerlink" title="== 指针就是地址吧，那么指向int 的指针也好，指向double的指针也好，他们有什么不同么=="></a>== 指针就是地址吧，那么指向int 的指针也好，指向double的指针也好，他们有什么不同么==</h3><p>emmmm<br>貌似也有一定道理。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>既然我们无法从正面解释，那我们就先设定一个“万能指针”<br>看我接下来这段操作：</p>
<p><a href="https://img-blog.csdnimg.cn/20200119212651514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119212651514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload" title="在这里插入图片描述"></a></p>
<p>在这里我创建了一个“可以指向任何类型的指针类型”——void*类型</p>
<p>但是当我运行的时候，出现了一个错误：</p>
<p><a href="https://img-blog.csdnimg.cn/20200119212816978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119212816978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload" title="在这里插入图片描述"></a></p>
<p>仔细想一下，如果仅仅知道了地址，但是不知道保存的数据类型，也是无法取出值的。<br>也就是说，上边的错误和下边的错误是一样的</p>
<p><a href="https://img-blog.csdnimg.cn/20200119213119242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119213119242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload" title="在这里插入图片描述"></a></p>
<p>也会报同样的错误。</p>
<p>如果我们把第一个做法中printf函数稍作更改</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*(<span class="keyword">int</span>*)hoge_p);</span><br></pre></td></tr></tbody></table></figure></div>
<p>成功！</p>
<p>因此，与其写成这样，还不如刚开始就定义他的类型</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *hoge_p;</span><br></pre></td></tr></tbody></table></figure></div>
<p>这样编译器会记住 hoge_p是指向int的指针<br>这也就是为什么指针要定义他的类型。</p>
<p>关于这一点，还有一个地方需要用到他的类型：<br>==指针运算==</p>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>书写如下代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> hoge;</span><br><span class="line">	<span class="keyword">int</span>* hoge_p;</span><br><span class="line">	hoge_p = &hoge;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hoge_p 的初始地址为：%p\n"</span>,hoge_p);</span><br><span class="line">	hoge_p++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hoge_p 加一后：%p\n"</span>,hoge_p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hoge_p 加一之后再加三后：%p\n"</span>,hoge_p + <span class="number">3</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>发现运行结果：</p>
<p><a href="https://img-blog.csdnimg.cn/20200119214650997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119214650997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload" title="在这里插入图片描述"></a></p>
<p>我们知道c语言地址是以16进制的方式存储的。</p>
<p>发现：</p>
<h4 id="第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12"><a href="#第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12" class="headerlink" title="第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12."></a>第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12.</h4><p>不难看出：：</p>
<h2 id="对指针加N，指针前进“当前指针指向的数据类型的长度×N”"><a href="#对指针加N，指针前进“当前指针指向的数据类型的长度×N”" class="headerlink" title="对指针加N，指针前进“当前指针指向的数据类型的长度×N”"></a>对指针加N，指针前进“当前指针指向的数据类型的长度×N”</h2></body></html>]]></content>
      <categories>
        <category>征服C指针</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上自定义各个应用快捷键</title>
    <url>/2020/02/01/Mac%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%84%E4%B8%AA%E5%BA%94%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="进入系统偏好设置"><a href="#进入系统偏好设置" class="headerlink" title="进入系统偏好设置"></a>进入系统偏好设置</h1><h2 id="键盘选项"><a href="#键盘选项" class="headerlink" title="键盘选项"></a>键盘选项</h2><h3 id="快捷键："><a href="#快捷键：" class="headerlink" title="快捷键："></a>快捷键：</h3><p><a href="https://img-blog.csdnimg.cn/20200121123450810.png" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200121123450810.png" class="lazyload" title="在这里插入图片描述"></a></p>
<h3 id="选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。"><a href="#选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。" class="headerlink" title="选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。"></a>选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。</h3><p><a href="https://img-blog.csdnimg.cn/20200121123525851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200121123525851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload" title="在这里插入图片描述"></a></p>
<p>点击添加，完成！</p>
</body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C指针——和指针的第一次亲密接触</title>
    <url>/2020/01/30/%E5%85%B3%E4%BA%8EC%E6%8C%87%E9%92%88%E2%80%94%E2%80%94%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="先看代码："><a href="#先看代码：" class="headerlink" title="先看代码："></a>先看代码：</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出每个变量的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a的地址是 %p\n"</span>,&a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b的地址是 %p\n"</span>,&b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c的地址是 %p\n"</span>,&c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将a的地址赋予c*/</span></span><br><span class="line">    c = &a;<span class="comment">//此处需用到  ”&“来得到a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c修改后的地址为 %p\n"</span>,c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c输出a的内容*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*c ---->%d\n"</span>,*c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c修改a的内容*/</span></span><br><span class="line">    *c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a---->%d\n"</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="然后我们看运行结果"><a href="#然后我们看运行结果" class="headerlink" title="然后我们看运行结果"></a>然后我们看运行结果</h2><p><a href="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h2 id="我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c"><a href="#我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c" class="headerlink" title="我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c"></a>我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c</h2><p>==我们暂且先将c理解为指向int 的指针==</p>
<h2 id="再看初始化完后内存中保存的样子"><a href="#再看初始化完后内存中保存的样子" class="headerlink" title="再看初始化完后内存中保存的样子"></a>再看初始化完后内存中保存的样子<a href="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></h2><p>在c语言中，会存在 int类型，double类型，等。。同样，c语言中也存在指针类型这样的类型。<br>指针类型并不是单独存在的，而是由其他类型派生出来的。。</p>
<p>==由引用类型T派生的指针类型有时候称为’（指向）T的指针‘==</p>
<p>因为指针类型是类型，所以他也像其他类型一样，有“指针类型的值和指针类型变量”，但有时，我们将“指针类型”，“指针类型变量”，“指针类型的值”简单统称为—指针</p>
<p>因此 c就是一个指针类型变量—–指向int的指针，但此时并为对它赋值。</p>
<p>接下来我们将a的地址赋予了c，此时c的值就是a的地址<a href="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h2 id="接下来："><a href="#接下来：" class="headerlink" title="接下来："></a>接下来：</h2><p>在指针前面加<em>，可以表示指针指向的变量，因为现在c指向a，所以</em>c就等同于a。同理，修改*c就相当于修改了a的值。</p>
<p>==这是对后两行输出做的解释==</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>如果说c是 指向int的指针，但我们声明变量时一般要遵循：</p>
<h2 id="类型-变量名"><a href="#类型-变量名" class="headerlink" title="类型 变量名"></a>类型 变量名</h2><p>因此，我们似乎声明了一个名为*c的变量。</p>
<p>所以我们可以写成 ==int* c==的形式。这样更符合  ==类型 变量名==  的形式。</p>
<p>但之后就会出现问题：<br>数组也是C语言的一种类型。。如果按上述所说的话。<br>C语言声明数组时应该是：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<p>很明显，会报错。这就产生了矛盾。。</p>
<p>反而，Java中可以这么写，但是Java为了让C程序员更好的转向Java。也兼容了c语言定义数组的写法。。</p>
<p>在这里需要插一句：</p>
<h2 id="C语言的语法本来就是不自然的，奇怪的而又变态的。"><a href="#C语言的语法本来就是不自然的，奇怪的而又变态的。" class="headerlink" title="C语言的语法本来就是不自然的，奇怪的而又变态的。"></a>C语言的语法本来就是不自然的，奇怪的而又变态的。</h2><p>之后我会出一篇关于C语法的博客专门研究这“变态的”c语法。。。</p>
<p>欢迎吐槽评论</p>
</body></html>]]></content>
      <categories>
        <category>征服C指针</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
  <entry>
    <title>swift之基本运算符</title>
    <url>/2020/01/30/swift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="本章大致介绍一些swift特别的运算符"><a href="#本章大致介绍一些swift特别的运算符" class="headerlink" title="本章大致介绍一些swift特别的运算符"></a><strong><em>本章大致介绍一些swift特别的运算符</em></strong></h2><h1 id="元组比较"><a href="#元组比较" class="headerlink" title="元组比较"></a>元组比较</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">元组比较：</span></span><br><span class="line"><span class="comment">1.从左到右比较，一旦比出结果，即大于或小于，就是整体的比较结果</span></span><br><span class="line"><span class="comment">2.如果每个对应的元祖相等，则整体的结果就是相等</span></span><br><span class="line"><span class="comment">3.要比较7个或者更多的元素的元祖，必须实现比较运算符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>,<span class="string">"zebra"</span>)<(<span class="number">2</span>,<span class="string">"apple"</span>){</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"the second win"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="number">3</span>,<span class="string">"apple"</span>)<(<span class="number">3</span>,<span class="string">"bird"</span>){</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"the second win"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="number">4</span>,<span class="string">"dog"</span>) == (<span class="number">4</span>,<span class="string">"dog"</span>){</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"sample"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h1 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a>三元条件运算符</h1><p>与C语言中差不太多，直接上例子：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//三元条件运算符</span></span><br><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight = contentHeight + (hasHeader ? <span class="number">50</span> : <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(rowHeight)</span><br></pre></td></tr></tbody></table></figure></div>



<h1 id="关于-与-重点"><a href="#关于-与-重点" class="headerlink" title="关于 ? 与 !  //重点"></a>关于 ? 与 !  //重点</h1><p>swift语言中，如果不对变量进行初始化是不会自动给他一个初值的<a href="https://img-blog.csdnimg.cn/20200112143559495.png" data-fancybox="group" data-caption="此处报错" class="fancybox"><img alt="此处报错" title="此处报错" data-src="https://img-blog.csdnimg.cn/20200112143559495.png" class="lazyload"></a><br>此处报错的原因就是未初始化number就对他进行了使用</p>
<p>swift中有一种可选类型。（Optionals）</p>
<h4 id="？"><a href="#？" class="headerlink" title="？"></a>？</h4><p>在定义变量时添加一个问号。以为此变量为可选类型，如果后面，给该变量赋值x。那么他就是x，如果没有赋值，他就是nil。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int?</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt)</span><br><span class="line"><span class="comment">// 此时结果是nil</span></span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int?</span></span><br><span class="line">optionalInt = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt)</span><br><span class="line"><span class="comment">//此时输出是Optional(1)</span></span><br></pre></td></tr></tbody></table></figure></div>
<p>但是现在会出现警告，就是虽然现在有值，（不管是不是nil都认为有值）。但是她现在是可选类型，应给他确定类型。</p>
<h4 id><a href="#" class="headerlink" title="!"></a>!</h4><p>此时 ！就是用来强制解析：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int?</span></span><br><span class="line">optionalInt = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt!)</span><br><span class="line"><span class="comment">//此时输出是1</span></span><br></pre></td></tr></tbody></table></figure></div>
<p>此时optionalInt 是Int 类型。<br>所以有时候我们可以直接这么写：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int!</span></span><br><span class="line">optionalInt = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt)</span><br><span class="line"><span class="comment">//此时输出是1</span></span><br></pre></td></tr></tbody></table></figure></div>
<p>==注：使用!来获取一个不存在的可选值会导致运行时错误。使用!来强制解析值之前，一定要确定可选包含一个非nil的值。==<br>也就是说如果没有第二句赋值，此程序会崩掉。<br>所以使用！时要注意这点</p>
</body></html>]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>6-1 邻接矩阵存储图的深度优先遍历 (20 分)</title>
    <url>/2020/01/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><blockquote>
<p>试实现邻接矩阵存储图的深度优先遍历。</p>
</blockquote>
<p>函数接口定义：<br>void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );<br>其中MGraph是邻接矩阵存储的图，定义如下：</p>
<p>typedef struct GNode <em>PtrToGNode;<br>struct GNode{<br>    int Nv;  /</em> 顶点数 <em>/<br>    int Ne;  /</em> 边数   <em>/<br>    WeightType G[MaxVertexNum][MaxVertexNum]; /</em> 邻接矩阵 <em>/<br>};<br>typedef PtrToGNode MGraph; /</em> 以邻接矩阵存储的图类型 */<br>函数DFS应从第V个顶点出发递归地深度优先遍历图Graph，遍历时用裁判定义的函数Visit访问每个顶点。当访问邻接点时，要求按序号递增的顺序。题目保证V是图中的合法顶点。</p>
<p>裁判测试程序样例：<br>#include <stdio.h></stdio.h></p>
<p>typedef enum {false, true} bool;<br>#define MaxVertexNum 10  /* 最大顶点数设为10 <em>/<br>#define INFINITY 65535   /</em> ∞设为双字节无符号整数的最大值65535<em>/<br>typedef int Vertex;      /</em> 用顶点下标表示顶点,为整型 <em>/<br>typedef int WeightType;  /</em> 边的权值设为整型 */</p>
<p>typedef struct GNode <em>PtrToGNode;<br>struct GNode{<br>    int Nv;  /</em> 顶点数 <em>/<br>    int Ne;  /</em> 边数   <em>/<br>    WeightType G[MaxVertexNum][MaxVertexNum]; /</em> 邻接矩阵 <em>/<br>};<br>typedef PtrToGNode MGraph; /</em> 以邻接矩阵存储的图类型 <em>/<br>bool Visited[MaxVertexNum]; /</em> 顶点的访问标记 */</p>
<p>MGraph CreateGraph(); /* 创建图并且将Visited初始化为false；裁判实现，细节不表 */</p>
<p>void Visit( Vertex V )<br>{<br>    printf(“ %d”, V);<br>}</p>
<p>void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );</p>
<p>int main()<br>{<br>    MGraph G;<br>    Vertex V;</p>
<pre><code>G = CreateGraph();
scanf("%d", &V);
printf("DFS from %d:", V);
DFS(G, V, Visit);

return 0;</code></pre><p>}</p>
<p>/* 你的代码将被嵌在这里 */<br>输入样例：给定图如下</p>
<p>5<br>输出样例：<br>DFS from 5: 5 1 3 0 2 4 6<br>作者: DS课程组<br>单位: 浙江大学<br>时间限制: 400 ms<br>内存限制: 64 MB</p>
<h2 id="很明显这个用递归就可以了"><a href="#很明显这个用递归就可以了" class="headerlink" title="很明显这个用递归就可以了"></a>很明显这个用递归就可以了</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( MGraph Graph, Vertex V, <span class="keyword">void</span> (*Visit)(Vertex) )</span></span>{</span><br><span class="line">    Visited[V] = <span class="literal">true</span>;</span><br><span class="line">    Visit(V);</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<maxvertexnum; i++) {< span><br><span class="line">        <span class="keyword">if</span> (Graph->G[V][i] == <span class="number">1</span> && !Visited[i]) {</span><br><span class="line">            DFS(Graph,i,Visit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></maxvertexnum;></span></pre></td></tr></tbody></table></figure></div>
<p>根据提要求访问过的节点需要true<br>所以在此访问还应判断该节点是不是false</p>
</body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假计划与每日进度（总章程）</title>
    <url>/2020/01/21/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92%E4%B8%8E%E6%AF%8F%E6%97%A5%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好，请输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="4d8ebd1745e742d7280342e793377938257344a62cc036d24a253e84e0e5207c">ba7233cb4492a779478ef44e61ef447c28141d18b1231ef6bbffa250b7c0f66f24db462cc1261ba70150ff3ac99f766c1f94890d60773646e2115b802c8b3a09db38fb51734a671df187131ec5d06cdb4e9cec757c91a89496f2dcca128ea3002b4daf37332a0a787c27bf74f71ff4ac29afa9804c123bd9854ddcb2ef037ba7934bcb6c5304027e68bb26674f5885b6e2a5b1e6aa76feffc847dbf54cd67550ad0fea75204ba84daf46ed589f24e794739b848736141324c5e96679ac8754ea67ce0aefc9f856b605b9fef5c6339da2779d72002db303a22ed327b682b9841b128dd482cd48333a37d8546a1cbfbc1c6808745196a829718459107716358b5a9da558b86067d208e4eb5905f277f94622ff2fd5a7fb19dd60b76e0ea1ea9345848ef53f09e5e63ab6a5547b7ef2a4b18a453b84b25652d934c4da0d969a4ae6b1ac720335f6404febff994b49e55f2591107bdd2b5b62cee3c58c5a25a4e41eaade1e49e803cb0a1d3a4d113889bf8b11024ca16ff498d458730a446c0fb0593c9698a7b7bab273b2ebc7e217c495d672310dc1a3e1818aa3c746c8e56140ec1223148385d1388beba1f56fa9ad3c17b236587f0fa5b28c19e97ac8ba85831aedb8da82c37e28c77023cea4b13c73a0e8c5f5b850f616d28046f424d5227a50dc453f014c15710a400d83a91b3e864342b34e2d05a980682f5c5c739838f7ee36f0712d3617a7a5a3114277957d1c5a5a1faa0ab4a212bfb23ba77a4b9f274b97661a6bbe77d5c38054498707642278fa26691f54bfd6f6816c04aaf18ce85101b08dacb6d90df8ac4a85f34c055c4840ebc7935531771c3a8dc66fb423f96b23b94fb8ed76485b1116f792ccaf79f36dafa80c2558407d2eafcba80cf2ad038185e1ffefec576244e8a6e0a0a0d9c0aa57b0646f96430dc2ae023e3f0e190545d621be5f44a770011bb674e9b1e7cbb5defe051c90dbd89af4474c430b97a0f581bf0cdf01678fd52d06a4b2bf73f13ddc68f9983d62fd23316095f89a8844280b3917cf1ead497a04388291bcb989c566b6454daf2f24b0d7fda0fd3adeb089f8dd3cfe3688798f45cbcc3ea21b8e43352d68807c6954d41cb74bf67c432b339f30a51e0b9e247e75f887e607bf0e06c33f734021d7d56d08da84b2d78f0c794d28d64615eb8093f77c567d8ad15165574d075d1cb353ef5352e7d89470c3947e5d7ddd4eeabf0925f616934ff079f2c0ed5b726184d2a09a9a76d4ab12183b552678a931ac2f487629d9af4d89557901f54e313a88d55536552a4284602ec7a37085aafc397b72f2d65d28af6de077d0b93af76f5d6a2e78cb48afcb3bd5e64fe542985ba3f1f1a1c8b5ada8dcd6f73d6c9e77e50adbe18fbefbe9e37648d47f98a2e2fc56f2a8e53dcd86224926f84ad238ad939a7beb2a0eee417edaf2d408d31781c6bcce9ebe71683421c87f44983e0511490c56e6c4b727b19d18cae85102c5545e58d323cfdf4f3bc4723bdc05f29d91733222e1d1db1dd0125cbf3d9552de33c49f1c9c8ee04c2111c6a6e24611bb697cc4f4c1981e635402aa3bf70fb60d389e12094a7814163964c842ffd21d9eb23cadd3207957dc0c4545140c5caa2acdfe05a889de1fea85681fec2d0df2b7d4c47165675bd9e3aa0bdab6e8b29b84c9af683463d9aff8434a940b5897a7e261c80a45986494617e7a8825c0326d5e60529c7cd6d27e8c03a728605b2a68fb1f3e8bac851ec2b97905dda56da4d8f7f50f12d48d478cecb99cc3c6b2d31990108239977092e44b65b3824f7f56b5578820998c08c9fb628c9b8d84f458858228fb31f40bb55288633e334eeff2a1088827773e9b57b01554450c1dfae13d2882061552c9534b9110eb7b93982e43af3b074526e7541f2219cd88953f0a0aee4285b81fa04ff0bcc73726734ddd0e1c6bb0d5e02615f891bd75bb2096609bb9e23540dcfb540fc3ec73f323249338d8e9fad105abbfac32750550a46be9acf7efd49fc030badd723a94f8972925edb2ec62ce543aa04a76f4592a17aa5806ea764c42487018b3569cbecedde8412203baf49a76f72563c720006d2fb100b13381542b046fa9b5d52686cce83f8c089e541cbdfc1cfdb7a4a125773497167e22bd4328a29ac1f108ffb7f5bdddadaa6c9da6853e1cd462fceffc88728d3e4d1f62de8841f05ff5fd766e67d158721542009ec2c56034d326a1a255f338013fa16c1e6436c36478b49f7611b83670ae9a480fcefd673cbf125e9b75d29d58a4c63fc634d2b280340a8db8d391164e1fa602b9baa0e633b43d58797eba7a919c3f7c34172ad907366c5bcf91f1c9dd58d9969a436867313585a3d65aea5c7d00f26a0cb07d1bcf95429bf4d29cf9af9fa078ba7f1ce356b21ae15f12af6792ad77eaccf6f8427a713e49960ffa8416ac45322494ebad66efdc6cd23cf1f127413b067698e78cb010124adb14b945078900c855d639ce43d0a005a46137aa77700a6f9ddd40a019bbf230dd5d5803e10f54afe1f693e27c8a5fd49986e43bb5937c0f078e33de75d68907239aea37ce6433fa04bc05c0b6c5d3cb67d20452d633b6f26ee9d5842b4be0ceca3b8423aeb3147b4179729b70e146e0173178b022467b69594df3fe2adb680d44845a99f623a871588d28fbbe7d93e83263793d397ce63dfa0e90403d170f56716959d0fc050f96f90ed5c41c2930a5abf3771bf165bb062ab0e8976b346ac5567a166032f24c3e0511f746c417c5d5ae42c35034c843d71108c600c9d2ded1c11c15f4c1a98b555ea77a4b16265d0cee7bedb4ac1fb522ea8e2cb3ff4960a41ff7cd8bcb4c6fa4b342bbf4b68d849514b88274830d9383223dee9ed5faf9214c778ae641020306aa8fb7c4875dafcdbd2fcc609e682dbf19bd1e3c116f1184356a81c625465a0de90906129e432991575c55516847dde9bd3a22edb50127f0fa3ea9b7576768b309da1e413e90bc2a253d00df62c304d19175995ad1c7fb6c5007f18d1e48588bb8e5812726b332ac7c63c2697b56e48d19f33546aeae1c3205aa7fa8a9897699f9497d849147fcea6e760ef5b4a3c27c41f3a63af8bc57f50b9893bb2cb190e2a76e8d642a3a8df23462f73ada998145aa7fba9c3ba1cfe0f39693ac37104193240ed099271407e2bdf2df82ef9b4c6439d3b8809bc2a80994bd46404608a83a62dc5f35711df120eb7314ff73cc3b111399aa2fd0f5eab1dab27106929e65dfd9adb763e42646ad2f70809eecf168595902976c372f4c664da65c035e96fe3529d4089927544c98d35fd464551af01e3dc05ab9d1d160ca8a0a1d1f301937967ddf240ae03c93d45821208fa5f58e0af613cd96e3a909309e4b67b7c9d192c1abee3d28b7fc9f6183c0384ef33fa42398e6e0e89e521bec10fe6577dc496995a9c31c6d1f175f78c386261ac283790bb623771f3d8486d2de3477f8daeff0208861ec5208611f6b51c94663de5dedf407b67fc97ba9de4db46fde6c3c888ca1382574d5e814428a1236a84c94c95012aaee804e73be9be47f926edc205653fadbf361d3e3af503dc3df96092571e4e3086dc8413a4735c56a2d80edb74c71e4708663ae2e489243216e6562532797eb96c3e6ecf33b960667f5159b6ef48b13198866612cb1332a1b9c8828add76680d085070c6667296e87204608f28d9bdc281189605777a313752a6855cae5f8b1c46c5d1c9b623c3d7800ff079a5731da18aa0d23d49c57a363c3507218497805324b49fa1dfb3bd7c787804d20301ee4a2f331873c43e1e25adbe02be4afce1eb9b42f7637288aab6e52691744e6692559d27f2fc2e6e41a52611accfe7c241bdcc92b86f90d5ec35a7fe9b27836a7cc0314ecb1bc5bf65fe84d0549bf7f3cc1351dc337f0160b1695ab1adb9c9b5c232ca7df17d06af4b51cd51dd625d528ddcbf396760cb515ada6d44e180c5175ba3d91f4487b4b89ee0ff4b8f7b190667505d7e805655ae2bc9885a84240f8ec75f0b8dafbdb3661c5f89d953d038d95068e315c9dca7f9e13506ae58fec87c75c425bb6674b616ff588f3eb9336a0bcb31146970bf5bfab563eeac9a08f4cad699ade4ebb5c648a82c7c5bc192decc9129214c7301b52901cdd9756b41f43f70c8c92fe9442c4e0ec8c26e25966069cbc0f229349d1b8e9f930991cb0fbc62a68013fff264fd81b8d921aed20162839f4e21e0a9f57463800a38c13a9e5909a6a729673d5a54d54c74e4ae6e57e05c0ae1ed3a4f1879ac48c15d9dffe5931f3f3a0f8d8252b560d6c36d839885b08e25cd218fe2356e1ba0e47a78fd29ba1e8ae5a4e9ac62f3cdb10b96712c6e5fab077ab4fbe2dd6a056c3ed472300bb4492e687810b17e419a216b457fff7186010ee7472a9b5465b833ffb49bf1269a56462e8360ed2e939f52bcf5d7c65e30285f6ed73e06f435fce8d2ea80113d312b8563ca020ad3c83b64066397b34b2d9731cff3b9b51b814162c6c53f108877206a166f2804a47bf6099cda2e1b16c7dadc4be0f57f90ba06e8f71e9720e0a2502c0e8672ebb9b78b025377c652913d9155dd74fc00aab2af3b4f10b3ab64a2a25713d2030f63b56e37e77523b315b53b96e3a2c3de298ccd1e2ffda5d3f4fa60dd4ce25553ef658eda195ba922dbd4ce35d3a286021cc10b42adf7fc3d2df89e6e5cd830e3b4eb23cc00b5a6a02b3ada0be8e9511562b782ead8a8d3afa3750c8f967db38e70bb0d3c96eaa4296d7e63b9e69592654f46eda3e9a62999ca5d10c2f5c26bb4838fff86fdd6864c0d536d56a8d74c88594be03e1d8be6c98301e79dc8b68256c602700e009887503c15542e5acab2bc703b758b098cf207b98860d3aebd90937f8430aa91b9dce3f4a92fb20f0e82f47e1649fc7076beee9ab5b2bf1875f2a90d6aade2267011bfd5b0307148b1b6568ec325731c965ad4c717f08606fced95f5c8fd107710ff9f31bf4f01aa40a38e7b0a11d7dd7a096a12f86f9916d704d4403fc421fd602242f7b32760ce0eed5b26e875f9ee9ed1036179480c254cd434308cd948435846608c36102ac058890e645284809cc2aabf61d41914d3bf574adaeb870e48aaaab6198abcfabe0f3d6d10a580f75780c867a52615c93012e9924f3454907cdf4500b5c2dbc76ac541110b06bd41f3daa3f38c91620954cc878a00781f775fb4566c2f29593adea42eb4b660f9913d979b34f1cdabfa61e15c4423462c0f9c80da6412333d8096a38613782e4352d7443811477e28fc12d3218e714e153af3022f15270e4d842980464e3f65f48d208c4987adc7d2993f448e6de9db29e4f55df209acc3768d7d8ac267e30635c5411c8a7412e856ab459c7e3be7b4552f6fccab242319e72af947d280367877c16cbf465a7749774d1c2941317a7694b8a4b2059fee953ba6aa8129887a9f32c88f6abf2708fdeb177f67e9636c2630713bb24126f0eb53a3708b8f1c6aea7a4e51d4cabc4ec460d4f26ba3501f2521d952eb7b0d7944143cfb8f6cdec40c13e7314e1b49e6fd6096b47222b9ed8db5d47fb01a4</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>My Daily Life</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>寒假终极计划</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔非递归实现 C语言版</title>
    <url>/2020/01/21/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0c%E8%AF%AD%E8%A8%80%E7%89%88/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="汉诺塔非递归实现-C语言版"><a href="#汉诺塔非递归实现-C语言版" class="headerlink" title="汉诺塔非递归实现 C语言版"></a><strong><em>汉诺塔非递归实现 C语言版</em></strong></h1><p>我上一篇博客是汉诺塔C语言递归实现，非递归和递归想法一样。这里不再赘述，直接链接转到：</p>
<p><a href="https://blog.csdn.net/VistorsYan/article/details/102765478" target="_blank" rel="noopener">汉诺塔递归实现 C语言版</a></p>
<p>   递归实现固然好理解，但是n的值越大，空间和时间上都是极大的消耗，最终可能导致程序直接崩溃。<br>在以后的做题或者是面试中，不推荐用递归方法做，所以要写出对应的非递归方法。</p>
<p>  某次上课无意间听到老师说了这样一句话：任何递归法都可以用循环的方法进行非递归实现，然后回头找了找汉诺塔非递归的资料，整理整理，搞出了一个c实现的非递归方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#include<stdio.h></stdio.h></span></span><br><span class="line"><span class="comment">#include <stdlib.h></stdlib.h></span></span><br><span class="line"><span class="comment">#define MaxSize 100</span></span><br><span class="line">typedef struct{</span><br><span class="line">     int N;</span><br><span class="line">     char A;        //起始柱</span><br><span class="line">     char B;        //借助柱</span><br><span class="line">     char C;        //目标柱</span><br><span class="line">}ElementType;</span><br><span class="line">typedef struct {</span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    int top;</span><br><span class="line">}Stack;//汉诺塔问题的结构类型</span><br><span class="line">void Push(Stack *PtrS, ElementType item){</span><br><span class="line">     //入栈操作</span><br><span class="line">     <span class="keyword">if</span> (PtrS->top == MaxSize)</span><br><span class="line">     {</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"The stack is full!\n"</span>);</span><br><span class="line">         <span class="built_in">return</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     {</span><br><span class="line">         PtrS->Data[++(PtrS->top)] = item;</span><br><span class="line">         <span class="built_in">return</span>;</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line">ElementType Pop(Stack *PtrS){</span><br><span class="line">    <span class="keyword">if</span> (PtrS->top == -1)</span><br><span class="line">      {</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"The stack is empty!\n"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(1);   //直接终止程序，一般不会出现这个错误</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">          PtrS->top--;</span><br><span class="line">         <span class="built_in">return</span> (PtrS->Data[PtrS->top + 1]);        //或者是<span class="built_in">return</span> PtrS->Data[PtrS->top--];</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line">//借助栈的非递归实现</span><br><span class="line"> void Hanoi(int n){</span><br><span class="line">    ElementType P, toPush;</span><br><span class="line">    Stack S;</span><br><span class="line"></span><br><span class="line">    P.N = n; P.A = <span class="string">'a'</span>; P.B = <span class="string">'b'</span>; P.C = <span class="string">'c'</span>;</span><br><span class="line">    S.top = -1;</span><br><span class="line"></span><br><span class="line">     Push(&S, P);</span><br><span class="line">     <span class="keyword">while</span> (S.top != -1)        //当堆栈不为空时</span><br><span class="line">     {</span><br><span class="line">         P = Pop(&S);//出栈</span><br><span class="line">         <span class="keyword">if</span> (P.N == 1)//当只剩一个盘子时，直接由当前柱移动到目的柱</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%c -> %c\n"</span>, P.A, P.C);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         {</span><br><span class="line">             toPush.N = P.N - 1;</span><br><span class="line">             toPush.A = P.B; toPush.B = P.A; toPush.C = P.C;</span><br><span class="line">             Push(&S, toPush);        //将第三步(n - 1, b, a, c)入栈</span><br><span class="line">             toPush.N = 1;</span><br><span class="line">             toPush.A = P.A; toPush.B = P.B; toPush.C = P.C;</span><br><span class="line">             Push(&S, toPush);        //将第二步1, a, b, c)入栈</span><br><span class="line">             toPush.N = P.N - 1;</span><br><span class="line">             toPush.A = P.A; toPush.B = P.C; toPush.C = P.B;</span><br><span class="line">             Push(&S, toPush);        //将第一步(n - 1, a, c, b)入栈</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line"> }</span><br><span class="line">int <span class="function"><span class="title">main</span></span>(){</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">"%d"</span>, &n);</span><br><span class="line">    <span class="keyword">if</span> (n <= 0)<span class="built_in">return</span> 0;</span><br><span class="line">    <span class="keyword">else</span> Hanoi(n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>还是三个步骤：<br>1.将n-1个盘子由a柱借助c柱移动到b柱<br>2.将最下面的盘子由a柱直接移动到c柱<br>3.将那n-1个盘子在由b柱借助a柱移动到c柱</p>
<p>因为这个是出栈时的操作，所以入栈时要到着写</p>
<h2 id="简要解释一下（因为跟递归思路差不多）"><a href="#简要解释一下（因为跟递归思路差不多）" class="headerlink" title="简要解释一下（因为跟递归思路差不多）"></a>简要解释一下（因为跟递归思路差不多）</h2><p>如果n不等于一时，就意味着，以上的n-1个盘子，都要做上述所说的三个步骤，知道n等于1时，直接移动到目的柱。<br>因此，移动次数最多的是最上边的那个盘子，移动次数最少的是最下面的那个盘子，只需要移动一次</p>
<p>利用结构体数组更便于理解。</p>
<p>本文为原创，如有问题欢迎评论区留言。</p>
</body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>My Daily Life Jan 20th</title>
    <url>/2020/01/20/DailyLife--Jan--20th/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>   没错今天非常的浑浑噩噩，上午基本没干什么，除了下载了一下vim编辑markdown文件的插件后，然后还非常的作。。。诶，具体的就不说了。好不容易坚持了一段时间，突然又放弃了。<br>    下午貌似捣鼓网页捣鼓了半天，貌似却没啥成果。然后睡了一觉。有些疲惫。晚上也捣鼓了一些东西。貌似收获也不大。。</p>
<p>   明天再写一篇文章记录一下假期任务和完成情况吧。</p>
<p>   每天锻炼的项目只能多不能少。十点半前必须睡觉。</p>
<p>   今天除了安装了一些必要插件外，令需要记得就是有关vim的快捷方式：</p>
<table>
<thead>
<tr>
<th>markdown命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>zr</td>
<td>降低整个缓冲区的折叠级别</td>
</tr>
<tr>
<td>zR</td>
<td>打开所有折叠</td>
</tr>
<tr>
<td>zm</td>
<td>增加整个缓冲区的折叠级别</td>
</tr>
<tr>
<td>zM</td>
<td>折叠所有内容</td>
</tr>
<tr>
<td>za</td>
<td>打开光标所在的折叠</td>
</tr>
<tr>
<td>zA</td>
<td>递归打开一个折痕</td>
</tr>
<tr>
<td>zc</td>
<td>关闭光标所在的折痕</td>
</tr>
<tr>
<td>zC</td>
<td>递归关闭光标所在的位置</td>
</tr>
</tbody></table>
<h3 id="Adobe账号"><a href="#Adobe账号" class="headerlink" title="Adobe账号"></a>Adobe账号</h3><p>还有一个 Adobe账号：<a href="mailto:3jkxtqhtq4@privaterelay.appleid.com">3jkxtqhtq4@privaterelay.appleid.com</a></p>
<p>这搁谁谁能记得住阿</p>
<p>   现在是22:30 准备去睡觉，多的就先不说了，每天早起规划第二天的任务，晚上打卡，完成情况。</p>
<h2 id="就先这样吧-晚安"><a href="#就先这样吧-晚安" class="headerlink" title="就先这样吧 晚安"></a>就先这样吧 晚安</h2></body></html>]]></content>
      <categories>
        <category>My Daily Life</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>2-5 修理牧场 (35分) 哈夫曼树例题 c与c++鸳鸯解法 详细解释</title>
    <url>/2020/01/20/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91--%E4%BF%AE%E7%90%86%E7%89%A7%E5%9C%BA/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><p>农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数Li个长度单位，于是他购买了一条很长的、能锯成N块的木头，即该木头的长度是Li​​的总和。</p>
<p>但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。</p>
<p>请编写程序帮助农夫计算将木头锯成N块的最少花费。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入首先给出正整数N（≤10000​​ ），表示要将木头锯成N块。第二行给出N个正整数（≤50），表示每段木块的长度。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>输出一个整数，即将木头锯成N块的最少花费。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><p>8<br>4 5 1 2 1 3 1 1</p>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><p>49</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。"><a href="#构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。" class="headerlink" title="构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。"></a>构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。</h2><p>实际上是没必要构造一颗树的，运用他的原理即可</p>
<p>其实这两个解法差不多，但是c++更加的简单易于理解，在时间上也是很短的。c相对而言就比较暴力了。相当于对c++解法的底层解释。注重基础。<br><code></code></p>
<h2 id="c-解法"><a href="#c-解法" class="headerlink" title="c++解法"></a>c++解法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><queue></queue></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue<<span class="keyword">int</span>,<span class="built_in">vector</span><<span class="keyword">int</span>>,greater<<span class="keyword">int</span>> > Q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> x,n,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<n;i++){< span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&x);</span><br><span class="line">        Q.push(x);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(Q.size()><span class="number">1</span>){</span><br><span class="line">        <span class="keyword">int</span> a=Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">int</span> b=Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        Q.push(a+b);</span><br><span class="line">        sum+=a+b;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></n;i++){<></span></pre></td></tr></tbody></table></figure></div>
<p>在这里解释一下这句话</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">priority_queue<<span class="keyword">int</span>,<span class="built_in">vector</span><<span class="keyword">int</span>>,greater<<span class="keyword">int</span>> > Q;</span><br></pre></td></tr></tbody></table></figure></div>
<p>priority_queue<type, container, functional>，其中Type 为数据类型，Container为保存数据的容器，Functional 为元素比较方式。<br>Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。<br>greater 可以实现由底部到顶部大到小实现。<br>所以这道题的步骤就是，<br>push出两个最小值并相加，将相加的值加到sum并放回Q中，然后会重新排列大小。<br>以此类推</type,></p>
<p><a href="https://img-blog.csdnimg.cn/20191207174941948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191207174941948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a><br>不仅代码量很少，时间也是很短的，考试的时候可以使用，平时练习不建议，有点投机取巧。练习还是用c一步步实现他的每一个步骤。</p>
<h2 id="c解法"><a href="#c解法" class="headerlink" title="c解法"></a>c解法</h2><p>用c语言其实就是对c++的具体实现，（可能我这个不是最好的解法。）但是每次取每次放都需要重新排序，这将是一件很累的事情。所以干脆就不排序了，直接放在那，取的时候再去判断最小值。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10010</span>],n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = Max+<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++)< span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span>>a[i]) <span class="built_in">min</span> = a[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++)< span><br><span class="line">        <span class="keyword">if</span> (a[i] == x) {</span><br><span class="line">            a[i] = Max;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++)< span><br><span class="line">        <span class="keyword">if</span> (a[i] == Max) {</span><br><span class="line">            a[i] = x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i,sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++)< span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&a[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i<n; i++) {< span><br><span class="line">        <span class="keyword">int</span> x = findMin();</span><br><span class="line">        Delete(x);</span><br><span class="line">        <span class="keyword">int</span> y = findMin();</span><br><span class="line">        Delete(y);</span><br><span class="line">        add(x+y);</span><br><span class="line">        sum2+=x+y;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum2);</span><br><span class="line">}</span><br></n;></span></n;></span></n;></span></n;></span></n;></span></pre></td></tr></tbody></table></figure></div>
<p>这里注明一下：删除其实就是把现在这个数组里这个值（不一定是之前取的那个数）给赋值为非常大，这样下次寻找最小值就不会找到他。<br>如果有添加，那么之前一定有删除，直接把添加的值放在删除的值的地方就行了。<br>Max一定要特别大，要不然，最大值测试用例时，x+y的值甚至会大过Max，这样就出错了。<br>这个实现就很耗时了，算是锻炼思维把。<br><a href="https://img-blog.csdnimg.cn/20191207180030125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191207180030125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h1 id="如果有更好的解法，或者是有什么问题的话，欢迎留言。"><a href="#如果有更好的解法，或者是有什么问题的话，欢迎留言。" class="headerlink" title="如果有更好的解法，或者是有什么问题的话，欢迎留言。"></a>如果有更好的解法，或者是有什么问题的话，欢迎留言。</h1></body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA 树种统计  c语言-------二叉搜索树 详细解释</title>
    <url>/2020/01/20/%E6%A0%91%E7%A7%8D%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="树种统计"><a href="#树种统计" class="headerlink" title="树种统计"></a>树种统计</h1><h2 id="这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。"><a href="#这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。" class="headerlink" title="这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。"></a>这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。</h2><p>随着卫星成像技术的应用，自然资源研究机构可以识别每一棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。</p>
<p>输入格式:<br>输入首先给出正整数N（≤10<br>​5<br>​​ ），随后N行，每行给出卫星观测到的一棵树的种类名称。种类名称由不超过30个英文字母和空格组成（大小写不区分）。</p>
<p>输出格式:<br>按字典序递增输出各种树的种类名称及其所占总数的百分比，其间以空格分隔，保留小数点后4位。</p>
<h2 id="第一眼直观感受是用数组常规排序？？？-但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。"><a href="#第一眼直观感受是用数组常规排序？？？-但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。" class="headerlink" title="第一眼直观感受是用数组常规排序？？？ 但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。"></a>第一眼直观感受是用数组常规排序？？？ 但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。</h2><h2 id="这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O-logN-。根据二维图像，可以想象数据量越大，O-logN-会越来越趋近与O-1"><a href="#这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O-logN-。根据二维图像，可以想象数据量越大，O-logN-会越来越趋近与O-1" class="headerlink" title="这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O(logN)。根据二维图像，可以想象数据量越大，O(logN)会越来越趋近与O(1)"></a><strong><em>这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O(logN)。根据二维图像，可以想象数据量越大，O(logN)会越来越趋近与O(1)</em></strong></h2><h2 id="在回归这道题，数组里的二分法是去查找元素。。-而这道题是把元素按顺序输出，所以还是不行。。。。"><a href="#在回归这道题，数组里的二分法是去查找元素。。-而这道题是把元素按顺序输出，所以还是不行。。。。" class="headerlink" title="在回归这道题，数组里的二分法是去查找元素。。 而这道题是把元素按顺序输出，所以还是不行。。。。"></a>在回归这道题，数组里的二分法是去查找元素。。 而这道题是把元素按顺序输出，所以还是不行。。。。</h2><p>最后想了想二分法在树里的应用</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>在输入时就开始构造二叉搜索树。。</p>
<p>然后中序遍历输出就可以了。。。<br>左中右 正好是有小到大。。<br>至于后面那个频率，加个计数器，最后除以总数就可以了。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 思路：已二叉搜索树的方式保存输入的名称，并赋予一个计数器。然后中序遍历输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><string.h></string.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>{</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">31</span>];</span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">    <span class="keyword">int</span> k;<span class="comment">//计数器</span></span><br><span class="line">}tree[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InVisit</span><span class="params">(struct TreeNode Tree,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (Tree.left == Null && Tree.right == Null) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %.4f%%\n"</span>,Tree.data,Tree.k/(<span class="keyword">double</span>)n*<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (Tree.left!=Null) {</span><br><span class="line">        InVisit(tree[Tree.left],n);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %.4f%%\n"</span>,Tree.data,Tree.k/(<span class="keyword">double</span>)n*<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (Tree.right!=Null) {</span><br><span class="line">        InVisit(tree[Tree.right],n);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n,i,temp = <span class="number">0</span>,flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++) {< span><br><span class="line">        tree[i].k = <span class="number">0</span>;</span><br><span class="line">        tree[i].left = Null;</span><br><span class="line">        tree[i].right = Null;</span><br><span class="line">    }</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++) {< span><br><span class="line">        gets(tree[i].data);</span><br><span class="line">        <span class="comment">//二叉搜索树插入 数组保存法</span></span><br><span class="line">        <span class="keyword">while</span> (flag) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tree[i].data, tree[temp].data)<<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (tree[temp].left!=Null) {</span><br><span class="line">            temp = tree[temp].left;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                tree[temp].left = i;</span><br><span class="line">                tree[i].k++;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tree[i].data, tree[temp].data)><span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span> (tree[temp].right!=Null) {</span><br><span class="line">                temp = tree[temp].right;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                tree[temp].right = i;</span><br><span class="line">                tree[i].k++;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            tree[temp].k++;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    InVisit(tree[<span class="number">0</span>],n);</span><br><span class="line">}</span><br></n;></span></n;></span></pre></td></tr></tbody></table></figure></div>
<p>这里我用的数组的方法保存树<br>当然也可以用链表储存，但是链表消耗内存过大。。。个人不太建议。</p>
</body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔递归实现c语言版</title>
    <url>/2020/01/19/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0c%E8%AF%AD%E8%A8%80%E7%89%88/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="汉诺塔问题-递归实现法"><a href="#汉诺塔问题-递归实现法" class="headerlink" title="汉诺塔问题 递归实现法"></a><strong><em>汉诺塔问题 递归实现法</em></strong></h2><p><strong>话不多说直接上代码</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#include <stdio.h></stdio.h></span></span><br><span class="line">void Move(int n ,char from ,char to){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c -> %c\n"</span>,from,to);</span><br><span class="line">}</span><br><span class="line">void hanoi(int n ,char from,char depend,char to){</span><br><span class="line">    <span class="keyword">if</span> (n == 1) {</span><br><span class="line">        //当剩一个盘子的时候，直接移动到目的柱</span><br><span class="line">        Move(1, from, to);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        hanoi(n-1,from,to,depend);//将初始柱的前n-1个盘子借助目的塔移动到借用柱上</span><br><span class="line">        Move(n,from,to);              //将剩下的一个盘子移动到目的柱上</span><br><span class="line">        hanoi(n-1,depend,from,to);//将b柱n-1个盘子移动到借用a柱移动到c上</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() {</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&n);</span><br><span class="line">    char x = <span class="string">'A'</span>,y = <span class="string">'B'</span>,z = <span class="string">'C'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"盘子移动情况如下：\n"</span>);</span><br><span class="line">    hanoi(n, x, y, z);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>思路：<br>不管多少个盘子（一个盘子的时候除外），全部都看作是两个盘子<br>即 最下面的那一个，和其上面的(n-1)个。<br>这样两个盘子的时候，移动就非常简单了。</p>
<p><strong>总共有三步：</strong><br>1.将第一个(也就是n-1)个盘子借助C柱从A柱移动到B柱。<br>2.将最下面的那一个盘子直接从A柱移动到C柱。<br>3.最后将B柱的那些(n-1)个盘子借助A柱移动到C柱。</p>
<p>所以在入口参数的时候需要，起始柱，借助柱（有点绕口），目的柱。</p>
<p>刚开始可能有些看不太懂，可以先输入几个简单的数，用断点调试，看一下他的移动过程。<br>递归函数的终点就是只剩一个盘子的时候，直接移动到目的柱。</p>
<p><strong><em>如果明白了就不用看我下面的废话了</em></strong></p>
<p>假设有64个盘子，那么问题就成了移动63和最下面的盘子。分成了两组去完成我上述说的那三步。<br>接着63个盘子去做第一步时就已经开始了递归。<br>递归到下一级时，就意味着再把63个盘子看成一个整体。分成两部分，最下面的一块和上面的62块。去完成这件事，以此类推，直到第一块。<br>因为只有前62块都完成移动，才可以移动到第六十三块。</p>
<p>不要去想着这个过程，很容易绕晕的，只需要知道这个函数的功能就是移动盘子。</p>
<p><strong>*下篇博客写汉诺塔非递归算法，c语言实现。 *</strong></p>
<blockquote>
<p>参考博客<br><a href="https://blog.csdn.net/csshuke/article/details/82630311" target="_blank" rel="noopener">https://blog.csdn.net/csshuke/article/details/82630311</a></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeeCode第二题常见报错</title>
    <url>/2020/01/19/leeCode%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%981/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><hr>
<h2 id="LeeCode第二题"><a href="#LeeCode第二题" class="headerlink" title="LeeCode第二题"></a>LeeCode第二题</h2><p>两数相加 c语言实现报错解决</p>
<hr>
<p>runtime error: member access within misaligned address 0xbebebebebebebebe for type ‘struct ListNode’, which requires 8 byte alignment (ListNode.c)<br>0xbebebebebebebebe: note: pointer points here<br><memory cannot be printed></memory></p>
<p>*</p>
<p>同样的思路，用Java实现可以运行，但是c语言却频频出现了上述所说的错误。困扰了我许多天，最后参考了一下csdn上大佬的想法，然后仔细在读这个错误，原因在你申请一个节点空间时，它的next指针也诞生出来了，注意这句note: pointer points here<br>说明有指针，但是你没有让他指向一个地址。所以出现这个错误，所以在你申请一个节点空间后，紧跟着把它的next赋值为空就可以了。</p>
<p>*<br>顺便呈上我的代码吧，思路就不多解释了，比较容易懂</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){</span><br><span class="line">    struct ListNode *p1,*p2,*p ,*h;</span><br><span class="line">    struct ListNode *head = malloc(sizeof(struct ListNode));</span><br><span class="line">    p1 = l1;</span><br><span class="line">    p2 = l2;</span><br><span class="line">    p = head;</span><br><span class="line"></span><br><span class="line">    int t = 0;</span><br><span class="line">    <span class="keyword">while</span> (p1||p2) {</span><br><span class="line">        int x = (p1!=NULL) ? p1->val:0;</span><br><span class="line">        int y = (p2!=NULL) ? p2->val:0;</span><br><span class="line">        int sum = x + y +t;</span><br><span class="line">        t = sum/10;</span><br><span class="line">        h = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">        h->next = NULL;//赋值为空</span><br><span class="line">        p->next = h;</span><br><span class="line">        p = p->next;</span><br><span class="line">        h->val = sum%10;</span><br><span class="line">        <span class="keyword">if</span> (p1) p1 = p1->next;</span><br><span class="line">        <span class="keyword">if</span> (p2) p2 = p2->next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (t>0) {</span><br><span class="line">        p->next = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">        p = p->next;</span><br><span class="line">        p->next = NULL;</span><br><span class="line">        p->val = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">return</span> head->next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>运行时间比较菜，如果有什么可以改进的话，或者更好的方法欢迎留言！！</p>
</body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeeCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上好用的敲代码软件CodeRunner外加破解</title>
    <url>/2020/01/13/Mac%E4%B8%8A%E5%A5%BD%E7%94%A8%E7%9A%84%E6%95%B2%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6CodeRunner/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="Powerful-IDE-level-code-completion-for-most-languages"><a href="#Powerful-IDE-level-code-completion-for-most-languages" class="headerlink" title="Powerful IDE level code completion for most languages"></a>Powerful IDE level code completion for most languages</h1><h2 id="有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS-Code-，但是插件的下载与安装也是比较麻烦的。"><a href="#有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS-Code-，但是插件的下载与安装也是比较麻烦的。" class="headerlink" title="有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS Code ，但是插件的下载与安装也是比较麻烦的。"></a>有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS Code ，但是插件的下载与安装也是比较麻烦的。</h2><h2 id="我介绍一个万能IDE———–-gt-Code-Runner"><a href="#我介绍一个万能IDE———–-gt-Code-Runner" class="headerlink" title="我介绍一个万能IDE———–> Code Runner"></a>我介绍一个万能IDE———–> Code Runner</h2><p><a href="https://img-blog.csdnimg.cn/20200117085038328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200117085038328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a><br>他几乎支持的了所有语言，如果没有你想要的，你也可以手动添加。<br>他的界面如xcode一样，非常的美观，清楚。支持代码自动补全，同样也支持很多主题。</p>
<p>运行之后还会显示运行时间。。</p>
<h3 id="功能强大-仅有270多MB-是不是心动了呢"><a href="#功能强大-仅有270多MB-是不是心动了呢" class="headerlink" title="功能强大 仅有270多MB 是不是心动了呢?"></a>功能强大 仅有270多MB 是不是心动了呢?</h3><h1 id="然而"><a href="#然而" class="headerlink" title="然而"></a>然而</h1><p><a href="https://img-blog.csdnimg.cn/20200117085414258.png" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200117085414258.png" class="lazyload"></a><br>没错它是需要付费的。</p>
<h1 id="然而-1"><a href="#然而-1" class="headerlink" title="然而"></a>然而</h1><p>不废话—</p>
<h2 id="1-直接登录官网下载"><a href="#1-直接登录官网下载" class="headerlink" title="1. 直接登录官网下载"></a>1. 直接登录官网下载</h2><h2 id="2-断网激活："><a href="#2-断网激活：" class="headerlink" title="2. 断网激活："></a>2. 断网激活：</h2><p>安装成功后，选择输入激活码。并断网。激活码网上都有，我就不找啦。几乎是随便一个就可以。成功后会有一个successfully</p>
<h2 id="3-修改hosts文件："><a href="#3-修改hosts文件：" class="headerlink" title="3. 修改hosts文件："></a>3. 修改hosts文件：</h2><p>打开<br>终端，开启root权限：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></tbody></table></figure></div>
<p>输入密码后，打开hosts文件位置：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /private/etc</span><br></pre></td></tr></tbody></table></figure></div>
<p>然后用vim打开 hosts文件：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">vim hosts</span><br></pre></td></tr></tbody></table></figure></div>
<p>进入此文件后，在后面加上一行</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">127.0.0.1       coderunnerapp.com</span><br></pre></td></tr></tbody></table></figure></div>


<p>然后保存退出。。。<br>（这块需要用到vim的一些简单操作，不会的话百度一下就OK，非常简单）<br>（注：修改成功以后他的官网就会进不去）</p>
<h3 id="重启coderunner-就可以使用啦。"><a href="#重启coderunner-就可以使用啦。" class="headerlink" title="重启coderunner 就可以使用啦。"></a>重启coderunner 就可以使用啦。</h3></body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C指针----和指针的第一次亲密接触</title>
    <url>/2020/01/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="先看代码："><a href="#先看代码：" class="headerlink" title="先看代码："></a>先看代码：</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出每个变量的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a的地址是 %p\n"</span>,&a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b的地址是 %p\n"</span>,&b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c的地址是 %p\n"</span>,&c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将a的地址赋予c*/</span></span><br><span class="line">    c = &a;<span class="comment">//此处需用到  ”&“来得到a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c修改后的地址为 %p\n"</span>,c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c输出a的内容*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*c ---->%d\n"</span>,*c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c修改a的内容*/</span></span><br><span class="line">    *c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a---->%d\n"</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="然后我们看运行结果"><a href="#然后我们看运行结果" class="headerlink" title="然后我们看运行结果"></a>然后我们看运行结果</h2><p><a href="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h2 id="我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c"><a href="#我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c" class="headerlink" title="我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c"></a>我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c</h2><p>==我们暂且先将c理解为指向int 的指针==</p>
<h2 id="再看初始化完后内存中保存的样子"><a href="#再看初始化完后内存中保存的样子" class="headerlink" title="再看初始化完后内存中保存的样子"></a>再看初始化完后内存中保存的样子<a href="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></h2><p>在c语言中，会存在 int类型，double类型，等。。同样，c语言中也存在指针类型这样的类型。<br>指针类型并不是单独存在的，而是由其他类型派生出来的。。</p>
<p>==由引用类型T派生的指针类型有时候称为’（指向）T的指针‘==</p>
<p>因为指针类型是类型，所以他也像其他类型一样，有“指针类型的值和指针类型变量”，但有时，我们将“指针类型”，“指针类型变量”，“指针类型的值”简单统称为—指针</p>
<p>因此 c就是一个指针类型变量—–指向int的指针，但此时并为对它赋值。</p>
<p>接下来我们将a的地址赋予了c，此时c的值就是a的地址<a href="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h2 id="接下来："><a href="#接下来：" class="headerlink" title="接下来："></a>接下来：</h2><p>在指针前面加<em>，可以表示指针指向的变量，因为现在c指向a，所以</em>c就等同于a。同理，修改*c就相当于修改了a的值。</p>
<p>==这是对后两行输出做的解释==</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>如果说c是 指向int的指针，但我们声明变量时一般要遵循：</p>
<h2 id="类型-变量名"><a href="#类型-变量名" class="headerlink" title="类型 变量名"></a>类型 变量名</h2><p>因此，我们似乎声明了一个名为*c的变量。</p>
<p>所以我们可以写成 ==int* c==的形式。这样更符合  ==类型 变量名==  的形式。</p>
<p>但之后就会出现问题：<br>数组也是C语言的一种类型。。如果按上述所说的话。<br>C语言声明数组时应该是：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<p>很明显，会报错。这就产生了矛盾。。</p>
<p>反而，Java中可以这么写，但是Java为了让C程序员更好的转向Java。也兼容了c语言定义数组的写法。。</p>
<p>在这里需要插一句：</p>
<h2 id="C语言的语法本来就是不自然的，奇怪的而又变态的。"><a href="#C语言的语法本来就是不自然的，奇怪的而又变态的。" class="headerlink" title="C语言的语法本来就是不自然的，奇怪的而又变态的。"></a>C语言的语法本来就是不自然的，奇怪的而又变态的。</h2><p>之后我会出一篇关于C语法的博客专门研究这“变态的”c语法。。。</p>
<p>欢迎吐槽评论</p>
</body></html>]]></content>
      <categories>
        <category>征服C指针</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
</search>
