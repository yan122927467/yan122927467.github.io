<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>No birthday is better than this</title>
    <url>/2021/01/06/%E7%94%9F%E6%97%A5/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好，请输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="b8ee0c23d522dbc173df803a6188f48259144bd4d67cc0376b30b8bad24fa03c">79726956eb8baa7ee600807ae32fad0638219cdc09ab3005663b5764cc08c691f234d02f1d11db62207de0f486237e66e985616607942c920de3bb785d9ae8dff678b0b50d7bad60f760b958db85f9cc57e5038de8b7cf24204bead029ca2c0a8363f4667c7d1b855dc05abd4ed54019fbca1ed62d64efab6541853e95889ccc7eb5d26b3a2cffa9dd232eac22601fad903b952fc251bcc061e5f20b91668fb8a00d7f8a948d68137d14afc22b8b096885827622366ba3b5d5f5208ce960ab6c335099ad86fc4f283756699c908624cad64bdbb7cf1a82e988d39b4aa81b642ab9d8aa6f3bbb31afa3d8a65d82ab0c119df7bbe73c4e35a7061470c5c45d887a21b9c47e58cefb5b185d61541a92f76b4641d5c30e844a1ae5780ac51a0977f40da5e957b4612114f9f8d601f1a07c563876e583dd437b447732e3774555f99e23480d4b3187de3a39756edbb37e4882164a64cc0031518fd69c63effb8f1970460f3f2e2b651ae6b92065234c6779964ffd8b9e9777d9e4106ad5002b26eebfbec50c8ae1d3d653bb5c8d632eb591cfce7d935f1d41cbf6bb43c12c3ca96e707f34cd11b8358c6fc009e1513c932b1221169a5235aa2bb362acb24ec2fe2f4d15f3845ba2aeef1f94fdb026b955b9e5745d155f5ea52ac8f04a8dd568fc929eb730ee166af49069806404fe2a0e713c8c65f33f920cd0729daff3e2718180e2fd6a1a4b61ed5ccc2010deae1b4a344dd86cf6df3c563356e68bb925110af8c2b3cb3d8a9e4fbbac5793991bef58519c06b4016a13d01bf2896f95187bc9bdcce5a6adff18838931f13a703546dbc95373e6062d43df29e8d1cf03cab43113c533c3a228b0bce76e006811a0a3490e9aa37b53913e71dccf77a696ae8d1422edd1d28c7029436ae3ba382e7d300ec3385133de1251959df2f8ef972404e56e3e94f1548abe9d74532ff390e894cfa225baec3969e54791fce81ff0dd458de33cddfc567f8024c4e1b32bad6dc498f186d28e70583b6d85c4474f163db5392b3676ab8252842b19f519e98b1fb1b45169acdf0392147f9ad633f46dd8b57164d0910d9bc86a3a5734cbee598b2273530e562357fd43d8fe92e3e758fd4f501f6a0a0d5fdd5cafd9b4afe271943b2e3ac5d8717cc8dcbb93d5fb0deab2e9b8e60d76857fe8861de6528a6e0c41cdc75332d2940a459724fd3046bc81b8de0138c27f46d038f78f69e8c4e0d4a9fed91224d4e2e1b871203f3562534265cad6d29a63649617d18c4dab086d73f12149d6fe713d790b72df5d654f841f7957e8e8e5e41031cc3080b52970dd930754e5b0094b9caf7056ee16019c6129714fa63c91b72237f6356fcafcf37fab4f4e7838f43b8b445af4f1416e3047b04e06460b999d9be9254a129182224ba3bfb48d9b87a5f311e8936ebfb0788c5b47eabda02cc148f459514453c08e11e4cc2dabe3bbe5ed52802d27cdd8a12c4fc836b1f13e20451f4636b56c4c635f4bdbc3925a0c042645961ae70f2efe79e26b4c1267908492dfc589e51051f50b4e888ee6e4180526e5b3dc29cf97b36d1cec49e5b3e3bc40d46468dc8948083037430bddbe4aeed2c8168ad2193a5c06e5ec32d3ac592dc9a7f2f64293aacf1628f7f91aecd744b3d5a9fb5b5a38b6a9cb62b7dd16c1ae7780a8c34d29e1bcb24fbb705d7fdee817c9ab1a3db5ce4ef40faf71641baea6affad0841034786ed4fd38b98b2915759baf12c3bdc119d750c5a144d99afd7c64eb1471beaa8e659c97c7882be5e42f573a03cc962f12b607cdfe9d5179d9b9ec22f3ead7d0e1352e080a438de73951a84b802aaddb779a2384659fb74fe9a409f98fc82d4bea1309f5a852e8171a1460de46c01549076ff7a00a09894a7c72e25b155298c88858a49de25982ca4537561acd1f1c8234dbc7514c950c938b983c3747d9bf5163971304f1acea854a1596f7d5e63f6d5bbc8126003c842a65a891df884e90d7e484b459d6ac337e287be5714e47c33122e894f960f381310a38e544adfca60303b71ef85df14c1169b9ba8a545617848176c946d3dba7e8fb8e42cd71c8c6c7a283086b9088367bf6179eeccff72f46c1369f918510a3ca2c3b72304748f38f4e01e89e27dcb0e09beab83dd9c40ba56cad36c8435306a62f1889f4d3b6798386b020604ed98e751fc2726c9b90850a632962e3411b66e6af55f7a327a2544e6aad01317cc8432aa1e33a4e1f6ffecbfb282358cee7c32b310de820abf317cd3e338204b5f390dd96aa2b5ee50a164a26ffc538bdb225a4b45c870894c4abc01b2854681227f7309037ac704ede0668a0f5b4687fa3775e33a1a135969d7a0c06819144b34da96d5217a1afb8580940195dfde6c59317901ad96da740d3addb246f505b7fe106afa32feb7bb40b817ac2c5ec9ca35178384362f2b5506157e467418aa298d84ce85dade39b50350733fcdf33c14e943bdbfe8688b31be33c05d12b3339f13fba31f63613d50382aaf71b5e30060d129b8802ff33d4fdc463be142a7c9a3cebe3f5da63a7932833d8b255b7ffc94254e5673c8e3fcc331d13a3b459ccfec6762d472a6e6357630d527438eaef58eb6735d7acbc7f745f08ccc84c3b90d6bb8299485866742a9cf62c10a53ba0dd0d5da8b7aee2c1d4403a3da65a6ccd8ef86e9e191c74c5e8b650b03f437def9ef0783651c1c59cca3055f56aa7abdf840d038516aab0ab5b59cb8a6eaba1cfbc7c470c5aab7b9b73349f595bfafabdfd47f9a54bde8483514e662136bb950bd509200c85d07b7bb420b3a3f5154fb9f6dbcd90ba1ea5f07dffa076d0c490a6c722ce35853852b87e038206557c4ff82497d5a3f71a7990016232f062520acdcc8d8daad6c076c59612161a15c2ac455c5448f3e609f269cbabeb3a8b0ebad6cee3c0e69b816e33191cf143c996df76677542fe7aff44fed2ebe4af9d6a25fdf749e3873ba9244dcb533850e17e4563522e761037874d503d238b31b7e7e3fc0cf2d0b4fe36654054a81e30ee9957979506c9abbab578f7818b2664ef49a626b84e4633ebd20bc89a380bb9a3984c700a737002ffd0e7cc4407e16850f2d7ae3b2e666b681ba78c38db792daac3d2d371b9255fe27fe99abe23296c3b4202577fb169aa97bf31e0a6126ddeb74ab81bc122f49bb3993102bebf62f20049d8b26ca86d2b5925d27626d876810bbb805b7724202dd759f62d0f6e771056cbef7f770c60d7f8901ed2e0bb70f4e3a4d4e94cf578baff67a014c2b8caaa990f812352e4bf1be24c3d494a0869f638ea1131e84f3e608b01994d1821be18ca4f27b431e3a0672c005b68ec2184c7e8799badbdea6470b9a88509de4d80fbf11feb59faff76c16875cda8c5dda2daf15408e6ba1c3e0bad00e6614407f458504ed148a1b45a5657eaa86ad6e9a27059b4b6223c9a104a979c61ca11f45574cc520eb66702761a9dc06540c0884ed55dc29cae682087202902dcee7c4a33e79eecf370fe4faa2d4b527d7d68409e9e6cf481128be40e1164bd5414f70cfa51b86aaad4c34eb52fdca6699e24014a1d84267f99e0a70b60d5768720a0bb9c234eb1a102f6df03fbd0d5f336e5a0d0ad5746a255f09924fab7df44b6d260d70d116c1f2716515eab0da753851adb0e80d79673676ab3f2ed011ec59fe418b61e84d328c5c76f2026220c6c2ca5c9fd23d6a6c088b1553329a1e0bcedde8fedb5cb33290ef8c879935afcff70e83bf0c3123d3512b1f77a82b528809ba3742a4a397285b105a58ffb83672b904d5182561ac2d425e9ca8fe8b0781e38f33e585e13a2797a5c481c9a44ae6fe631bfeff24d6b3697497d68ea94505f41b30817ec8100d8384a4d271eb88a8129563f1be2a419a930fe0e3e348ae2b4bf03cc3c10f3b8b4022d00e29440e3ae231781501e0a59e6b2df9eb8ae727bd4a802aad44c131950c00c4043103f477ac58b8b7e16dbd84b432ce6a3e5341fbe5c2ba907d69bb50a0b75e330236c8e00d92667dbe4afc54015e03407c5190663f1bbb4697c258923dccdcffc59ff40b8893ec8681d728261673ee82ded9d213e38b1a83f4434031da2231344b71df2690aaea1439e2e320b48bb17a9bc7271b011588365ede172897b505927ad3a121c25634550ff3f889b6d980142cee5982af8dc4ed488985faf561d86280ede7484658d90c6b074d7c342eb146d86d5b03677b68a784c00c4c496d037fde1ed4b681371c8af3177ac4a738b4c5549a329c1ee5d3b6be7252baea31783f11e17639640e5ec6a8801f14b75f66b1ba2622f0dfdea0a65470a0b6a3549c933b1b55e17b073c2078278edda1e7d30211cf5ffe178bf89e5318338a66a14ed3020c95fec12926b2870b02d89352a73b02024b1b47fde32a681821a6cfc0a7a3bc719cd0103f9df362a8cfc35823a13c3b69a873ae540bdbee7005e3d4a151e84f0f0daad02e6a2afcc38ef649e014fcf0b4884c379d18d0cbf2a071d6460d68c9f954a8911904341b08b47ceff5cc8e085e65814233a4e25ec0e5fde3f1052253594362aeb9f9478780d80f097dd96a26cf8c54f4d4cc5208ea97cfb2be6c7f6faa76dcd1e1f1048389ad11eabd8d107f5696462c33f5d614c8fa17ee78d8b491d9241200d1138d0b21f122efb30fc05bfeedf9ab25ad43eea44eb0e892c181edae260df179339eff48dee75b3dff78e4f3ff48351a928e0afd0525daaa2700355b775f6cf096b75003e3eaadf3c013b4cf0e86a05d197fbfec06dbade3aeeb974296773f5434ebf7d829e7e3002436480462ea4820995cc5b2aaa853977d5c19d7b102ec76c6cc01f6fa62ba18e13002d5f0e5685648ffb416f85c1b81868f3637ca57ece4b8fd17568c33788cb424884ea04b374b6fbdcf74c08ccb0095f37222cb04ab5347ddcc233a8fb8629cc1872b5ea589a8b5417786868e1f0a67a5d71f5a2de260e26014d8360d57e6c8d8b1b7162439f4ec6aaff5c9c967a8ac979dc77bfff76e7e7086a83435e156a9a780a6e70c63f1b598c79fa86d7004300f2040953db58012c0fb29070b6fde9f047050c5e153f7563cd159f4dad5ae53e18085934106fbd3814f83ef606cf510eb4d29349a2e3bc3a9146913194733f62e5cb2e1e386c1cc8cde236f7aa68519e0a06748e52e86d3b905745412e895e9b653773b39f97ffb6141c662451fdc782f12ecc9ab1eb9b231ffa3b41de771c23892212a7d7ca4adea775c450331594bd0760b837e9ba0251077e345601f96684a44894ee4be960a945c4ded5a64992544a2482bdb643c3fe2d27c09b6c094536e489e451bb79e19df5e875d3afb5446be371732ec47c77e42bb889b41007e95161caa06da10bed49f83d5da82a227222c2417315359aa5641c1138eebf45c77a6fd839211dd1503e58f3cdfe65569285a8f481863d951ab987f69b8226322fa4b2c41f4e26e73c4ae8baf13c47eae6cc9f27917430801d75aba24ca912b0f5056338ee0efed287a89ac17f5df0f7d62ab4360e9f014ed00dc43aed25d543a79de46029e5e82f176d0bd3f70afd17ae6ae649fa3e8aa5e63b3b78eadf8122332ac98e23ce2d74cbdaf6d159791bc61ac537142c21b99fe7a7fd45245442d9586ca3a9ec711f6b35e1c401eb59fcde2743b7a69be3958ed8f66e66aae0f6e034c200dee391b4e55310934e0ca7e555f799edd3601a3267b9463a803e2115fc72ade1796c8c65a7e6263106afd5e310d0fdce9decee19037ac4f1fce8d6ef9b8497b1d6b8a8f704bf5ca5f7caae68b3b99d3a3ee194fad12d6c7e54672ca8b888ee1140be55060cc252a427dc9a3d1d5eaf02d8b6d36d0452ae1b6d9c0e663d606b91df9ba857a80efbcee97ff13024e9d52cbe6373659ce08800ac18e78b3a0e1fcbeec70354dc115d9f88103efa95d3a3c95a1fc9f880900cf598d17f09826b7227576239487287dc2dd96be527726eb53bfcc00c6b737443d01dd0592bf16802038ff5feaa62109c06d31ea80fe8dfbb4411956305e499958acab7dec53ef85def587e5fb6d8ca154f5e11f380774774a99a28d85e337b1a6e36f74f0e81f09b6af16593ac6c0dcc5fa4367cb5bac6effd80d4c92e27d401385c37e6bd37eed46cc3fd6295e9aaabde84179e694d844b7c2486f3004cd083a09e01743a60031b427c12f335a3fc3767641ef518bec5bb951bfa7f3b19074ad0bd8471b288a9c970f4f035b4082a9ca01274013427e20b4e243f2d5c2670f33487db50c2f3b67ac8419862f56ce35d26256af16d64768d4d4d71faeeb66d21f953b88eea6909edfda494f18cb229f83c55bc6e66eada53fd1961d594ab1cde791daed62187261e1b5a3bfb41115ac99d64b587600638732e56e56180169521a8124c9189ea1de6d31a12046e01c4d8c00264ea2f86cd7d14672dae8fa12d9affecaf0ae791f09affb5bfa5a705c0693aa19781d5b8bb8afc4f082a79ec3ed2e2d01009a5d374f5a5fb46f47c28b9460b0421ff82daa41ebfff1dc255178cc0fb54cce671aa6a7455bce8500b3e1c2e79cec6afe7098123cd0d4fc9e97dd7b22478ee47af6c09dfed17798bb72c35d269a138d8aa6eb0fe5acb761c0728fec6a11a318a4b13044dcd2b4b55fe59968f7c3f96dd318c107b190ec848677af2beadf9aad6db33328e59b718863a6515e2619f832adbe3a27fd06ab7266f7bf91ef3e4e1d0ab1ac33389038e6095f447bc4dc28621759e39a17d5332c62f29421ae4e4c8c63c3695236affe757953ed43535574480849ffc43efb7b5d80b1be1f55056312d0603e5f0530dfb44a23a52185444851681a8f3955f30a8c794940faed50173a1fb80859d0630823bd184b5ad6ccdde2f4b8e80dda39fd8d7d77370e3e631686470f6352b662578527c6a4b69c53ba984878f1a06f37df6b9c4a8a9b0cd5c6367f6229a1c616ed44f5c87de7f4e3c28f098df153d8497be3ca32b88f60eb3cf67a57870a19a4d0ce33a8c9b7c807caaf89441e5745493844774a2f9f1f16b130dac23a2b264d48065762ccac52f7f2be42d57aa6cae0b78707a9722deea0e72955a98701cf301bcbf1e3761255bba912c3a86d93f32171d505a38447383d7c115964182dc6b800b3559bad10a030f12dc37fc4c5cc96f0c35142c4a866a5f204c9a552e3318effeaa0d31d3016e7ad5d5e43c4eb6bf001f2efaf96f2ffd529d165cc28f4901d630baf65590a5652b40d5b7bfc80711ed2a8ccf85d22201f4ed5cff402ec72684ab86cbb3db1d3440c6bafff0169e0b09b49414c6398e8e3337eda9bd331721b260d670637dcd1a5664ba369b6aff685d802fba347ac4d524b4654c4f18c075ef5bf9790f75abe9a6ed614036739390152e560b6b55d7ec4731a84e662235a6084dd81c4e3af552591a36db1c7c0998f0a2104aa8f379b6384d8780933d19a0e320530da62422a19545cd12e933b8c98349b92a65b9306acdd06c869d18af97ef34000a440f7f8ab99f001a6f0c4241683ef346bdb1507fe75572de4d2a91fa87a1543801ff4a3a91111f3694fa0cf172f11a2757f53463cdbac4467286065789d76ab036a1d956196d945cd56f60c05a29df8891862ce89d8b400c4683c9c780caeed0d1b7c3e7321c0853c7bc97a1b9de0ce69ba35af800cf947c965bfb200ecba228d372925ae79bae91b1ace8e9a9f28eebba1e34cbb1fda1c2afceb4183721bf051287823dbc352579082c03b2ddcaa2359d1d04784d9bc7e67731073260ce128aabb397cc3113eb29b2e449d0ca4aac49c9c2d182ac4a37167e334d922cc5b83c657d69ff7143df870917a96c04f790e20a417c42d32e9f43f473200d67a5650a93c807a6dcafe4f43413b701cb0d929d40cb44a29aabb0e7fbac25409edb3c4c5c19bfa24472e753f2489cf92966230adc90a6e9e8f21394b683fccbfefd9152a5f4dcf897ee16ad87dd4d3cf5e459c9747fed6685ec4b4514fb988b2ee8128b725cc6d84a54ac9885a623ba6e6f174ee1112cd8448da3e7f95c2b827fe14a100fbd2672ee5ee451999476e3a7906f9b2ed6cf622810920cf86003f333bfae9c0ac6fc996fd3d0e53b7411c1571dcee64c48b12458daf352a397ae685aca6c2caf15422237b892cefefe2b12e2732052d414458235a4d70c1c03dfbbf7eb3cbc7f0038a96793cae1b87a935619a898e58436fcd36452bec7a0b50bdbb714aed8042d5d1e74f6d919cd41c8881f1cd62d1f0f1953b219808f982988ba0bdabd2d4998e238e379f2c8ee38979ad6fe1febdcf3aceba79d2a1754dbcbfbf5db025b9ed348c63f30ea50bf7c6d3c7a9da96aad3c84178f2280b708d4b008ca444c4ebe750aa409169280911c814eda9c9f713471446a02e4106a56420af20c98225283c6146ab6999a6c7162de264565c02c3873a8c73ae4808c1e6504b4b717b7ba742dc6fd026a6f9a1ef27e6951a54c14a33e28ec7e9de385f631b5c70e88831089fb8a5d016b2d5551aad6c9124ad5547d122896355b5e403d02bbe79363c6b0fcda9ba61057d6ff676a996dcfd1830a251003bb8388765f0b3f1a4ccd04c5bb9a387a8a6c0a357b2790fcb7012d482e948113da294cb947d9d9f8b3eec9600f464eaf72efb8a3131f6357db45bc49c1e2a379553a7391b1e2dfc959a2ec579bf75dd64a380b8e96ec7b63a1439adf815b22da7646b83fce6ec59c74737cfdff09a6116f0e6ab97dec91900e42fb21dafd179c9d3289e1f190d5a1bcb014c54a629e1ad97907f0d395d9109026070447890e282abfd4f6c4c6a04f8d41bbb1f0e5122fec3c8eee99d32ef7653bbf4cd34ce716e872ff960ded6cb8c24f9ed0a471f01403d648f339494eb4c559f797c015b621733b61a10103d563070e69303c17ca0bfbedd3d75d0d308bbfd79525444b618070695caf5db98bf3966b062d066c396af269e5cd979e0ddab356694faaa010a607bce11e4971286b2e7cfd2074fe4d80581d59979ba77d625ce221c719e6c3cb4cbfb5c92401d9d8894796b3337099b82e779859f5e58b3c74c0dd3cf481442a3998697f4b0a348c55a9a8ce09e455b275f5a36c0871da57532d2e6c8178fef7ecebcf9e30a418430ed97eed6024159fcedc3ce37a39aa7ffe9f860b0accc756669739958e202a741af5b257e68ba088eb976d1b25171ed5a3edb757ecc831fb7c95b889f1adc524e8dd9ed8ea1296830634af61d680ea1721c5e215724dac8355770cb404de455be9b7fbf2128565acc185859c3285c7928ae7e06ea6789a12748da1ade584564d443ab2a299083e00d60715ceb09830c0f15f8195a602af1311a27d4af0a9dcc356a68eb543c2b642a8a661b47934c2083facd807b87c7e30acb32b95b9f1dd9a0ed9b34856e1f09d3e2a0f149edbbed55b9f24974d6d70151faa91aa50c47f0e1a54579c0b9c2e3623d9012ba7bd9652701bd537ca6f330ba4e76c557b6d3d9a952f6e680aed87d15f5e54487bebcde8a238d6885e9eef60f3288b808d6ac8f5185f0db4e660477b03f7c0d9669d3083aff5df7bb678185871a3804c334456e71923c27f25ebe2c24c21e182d81f1b7311f996843fb2946070697f631cb36013734e66eac8f16ae4e416a968753c6d8c9581a67ccfda62c76978bfbdd63211902ec374f41a6234fcaf786ef391c92aa70c029f184a250403660fdcd59f0623c7e0a85afba97993205bfbf1cf9e2fc6736775588af4360128678ec24fbe796daa2f9edcba6c930b1a59c9bb2695a9667f81845cd1f3aad2200a47a334b8b6a10f97ff2d75170a8c34d788df57b19c540f71f5a61dbf3ad8352eda16513304ccdcaa764d9994a51c9fd04e9507eb5da35f67612068c6ea7ec750df2dffec646358d98813174d5bcdfc81e777c9f854fed887c4d7db34f02a93a1b13a4c54d120eba04064ca314238aff271bc595a190ba8fa852fb2fd23cb6d82d268c7f948d9fc25147d307236170aef7eeff2730325f3f3288c005ea69e05e81c90d758680d5820dd1581c43c358dff1e57825db8a1bfd01db29d8c00ea9708f17b26516276b1fba67dc7f8bb58cb4cf874a445ef7f8e2de32f60aff2ace97bc52dea1478862ca6631ae9306cbc63e0d1865cab9a897d1c679d421149c9e5ac8fd8a1da1ed50845915885086d348cd03711a81a08962b011b44e4692c9a74253a89e449c6e5d6e3b63acb638a8b7cbc62fff9f344172157a396c09d248d557e72ac6db5e0befac9d10d741c86d30788b727406898f0b4660117f7375ab0b291badeabbd86259e594d8cb013e183962b6119d72bba762b536beaf67e3b3bdce409b83b69ec45bb7949cf4e8f7f0b962117bf243f86bc9d0bfc4b76b9a6f235a2ba23cf698e7a66a8d942cfb51e82707954f57879683838eb88ede11ef39b9c5d21aee891ccc4c63ad435bc0d16c5483dd268bc407618bd47b6f89c3b78bcc3adea25170e9da1884206ea699e00f9381b95a1585196cd5c37fd30c96682d563d3f4e8ae157bfa5f9ac9d3dfff33841c44263755d20ed854b0529f9a9797eb028bf19ef7bf56ffbad2a21a27ecc083e1afc25ad2b45e9a56cd7cabc0aba194a4463606a8a8c9c7778eab8538026890381df2a5e4aa01ae3a61df8a380017dbcdd6a1659a21fea76571b0f65e6cc64bf4a4f01cdfbf296f1de02e737483c723408a629b82ef0fa037d920f28c6aaa48e47a51327a8e24a9634a1602f840f569415180fa4ce7e8e820884e46d041a5b73207ab34168b2e552e564cfd86263adb1717c79220d5a21806edfe1c6da56082f5169a460a0a274653ad90f592a8617c87a76a5a539018107219528844a8dd86b11e497978f4ae72de3058bf18d74e3b434d0912205d0dbd30e57af0ad606f41042c4713be58c7b489a16b7cf012ed5ddb4a64a3d3a82c2821bac6a8c9185d71d91681119a8c34a57eb476fcbf109e5db8a49dca7c9c06ac75f3f6a431f77aa223b18f8e6eff60fef8f2bdb60a7b72fa4dd2677e0848909b0b1aa50d6f3bd9b1fbd3771d032c930763c614b720ffa8065881550ad8ba34bd0e6e737e9ad9246b24c5664a5b1fca0508a88007314aa850533325703a25ea3bdfc05563b7c895e4e57120aef29824888ba89052ab3767467cbd2acc14d93d23af1155efe46362489efc9242ef5215dcff9faa581237e91c4505e4c2018ef5c2741dba405da8c9aba88a80a4e47f9c80eab256741900b08c28dd42d9a2f28ed0e0eb00c829220fdd388a5f2fd20ba108f88d7b80a699bfb127fd59260207d1f5ebebe5a6f658b82a7cc7a71d0ab46497187b18405471a466b54390c863bc86d1735bce6ec98e4b4c7a3c5a382788698dd9734a0741bed54f1c573763d78e3106c921d868de66ec26496ee527f4afb50dd3d1bbe24472ccb3a4aa070eb5ccac0f15baeddf94130a57ec07b36f904217d571f3b56b987b3531dc9ed845dcf6637cf67bc29b8ce4f22e081935597000f83cf4d7acd14efad2af83d23234f5be034bffcb84b4527c2d5739cfe5c9b995db02b39dcdf40003965893fb2c8921ae0e0041b8da5e012c7d29aefca53da4937c4a4d6783ee586c2517ce13323276799355a7712e73aced186f6ae4d501880164aeacf45d8e72366e2a79ed13c52c0155171be3378ffa03dfbb52aeca881f833fb7b66b78fd6053d08fd6eb72b380d6cbaa36d8d42005076defbaeec0c11e54aba7beeda54b03c8c16716bd25ef0981fd48073c3ec5af20eaca13ec38eb5538440fccf8551907afb67fd08f416babe9702c0775ea15a8d7b7842e155a2459d8ba77dca386f1059e8b242c6e60715fe424f57602763817a03718564d7e575df1e223371f3855ec0417f720f16b135571c83ea18be383b8e8e27120c2e1edec08aa973f7397b06472ed9dec01331cb37b44e7075f7501fd2b719cde4a76d758bcfdcd9b18e193a6ca11a3886bc8adc378c31f0e8fbbdc9148b3f05024c2b79ed9fe88165683f2e8770b51a588401d892d45720b352cbb5d4fa40188666d55635766ead82b2998c6992c433b03b36f5cb7b896b6a1830e99ec396744688e6fbc101b78f176bdaf316620827264898c53a80292dd02a9609f9d5a13c623d951c2d40c3bec3545c4486ae0e9ec44200936081fc0099cfddda9bf391f27ca987b3f14eecfcb3bc90e6272e5017cf94e74401db2af7b4d4b3105f833ad0073c1f805ff82bc67c001dc13ede1f50be7f586fd5744a9b3f926ee889f9ed68b201ffabc8cc2e3734ce7e768f4d1b96ecdbce0d00c0f19f20dd8c92150a0a5c666e25315276edbc236c231fa5464aff22284dfb0a681f8dd509c1d286a8c5509d810bb8f4f433a1a3477e57c6a773b23229793559da474067166cdcec2c77b44b48dbf948bd70a7122bb5a5ad019470ae34ac90765ef93e7a2d20733e8b4daf436a070a3d1e4d1a31f34c9a0dcf0074d05aafaf7ad5187ae0c3d6c40357db1aeaa958026ce3adce878dd5e85e2ba6bb71c1f4369d8313c2255b2d41b96f4c30abf6344feaa4d746d65946aefe791c7d5903bf5d16b536d025b00a1cdd595ff42847fc6df1535371b38872db37ddf14bc15790538e9cfe251614876d965b4209e4b66b4ee9936f62bd981fec6eb239424dfb8135994546b2bff1963631a5d503c18bf569c87c9257e9fb4e411ae8cba7feddabac5df419a369f972917de36c46f541b0191e48db72ce1cb649f18fda525adb4982b1a1e6c2ff0dbfcecf9a424bca3eefcdba04e44983b7ec8570f4ea3471cf348f9b3a93df14851da679ee3bc8bd1d5ccca3eef0b2307afa6396328ee4f454fecf40e074a121884ea42977860c80887093839676719522c75013baeccd7f58e3f3f1af9aad7fb609cb90faf285d0a15f73a8de50f9235c158500b1f417497b03515380df2bda357ec922fc4699f2019d56a63da0bc3cd5956e4e976bae3896ff424f7616f649c760146b26cea41ebb6c4b7f088ae0091122f0d761dc6fa41013d1ecf6f261adda842d0100a73da3f348e287c43137f80ce80fcabb4020849e64a5e6c0de181bda3cc323805c4d79bab844761d63560b7cfca7da682bb77941607359aabb77bc415cbe0c13e57111ca903c6d1dfe4872de070b37bcd5bce05b1435fad123f6c984cc6932f29ff4eb4cb6bac30cc7d7b1b8a92c7a0c9c0ca9cd63ff48d5c7f1f6af0bc6d494a8ff38d10db330a36b26588ac18885a49d9cbaa438446ac96977768dcdf142154b2f00a09b53169d0c133b6e9658d023f60e482bd902bd2479bd7f0649f1736208714872058cc60118e6e67bdf829be9446fec16b67561b388e728cb09c3b9f3425a6c0a500e002a373b02300001101df9796498612328ae2427e2f53b533d433063d586179dcd78a70368fec0c2f924023ef1fae0136cd229d25c4d99ebb814ea45e974aa9fa5cab23835fd94d3ec807bf230c3f1bcef1a66d78dacc9274e3c14b1cb9e54e4deafd1907698252a3a78d27f12c6d8ff293f29d9d004b060504a47397c469b545f283e2810dfd9852385b0f891a4b65ab6bcc4bb84adfb1c728bbee36500f7fcc0dfe0497ede84ea2f22ed9e98dd4aef97b524fcf453212290ec575269e76e5bec2035e6be3ae441edaf1287dab1d8e391021a58dee5cd5efa85e4e7b3afb4772a43faf64923bf45e46521e258d12f52737d8ddd5fed600f96987967ed57a609df24b74e5ee15441c0c3fe5372946ce0d66674304551103f7f26416f1d8302d670ab667e41ac62b80d2ef85412cc5652e3d159c8285bd6e6b2bcb8f0bbda8d0b8a4ffbd29fa4e2691dd4565377a8dcbebbcb78d50ee4fdf0a5408ccbb97ee8a05a9325a82415156f8d4dd3751a43c0ecb50337cd4ea3b2468d40ca269cfb8c0417702480849a00280acb388bea61233b98713366668afb9d49d8e113e9919b49607c8407a9f25a3e542db5627ca665027eefb00dd2b58cf92</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>My Daily Life</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>分支限界法</title>
    <url>/2020/12/27/%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><p><strong>问题描述：</strong>假设有n个任务由k个可并行工作的机器完成。完成任务i需要的时间为ti ,试设计一个算法找出完成这n个任务的最佳调度，使得完成全部任务的时间最早；</p>
<p><strong>数据输入：</strong>第一行有2个正整数n和k，第二行的n个正整数是完成n个任务需要的</p>
<p>时间；</p>
<p><strong>数据输出：</strong>将计算的完成全部任务的最早时间输出；</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">14</span> <span class="number">4</span> <span class="number">16</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>题解：</strong>n个任务，分配给k台机器，总需要的时间最短，分支限界法其实是穷举法加剪枝函数，我们的函数用到递归，层层返回。一共七层，每层的除去叶子节点都有三个孩子，每搜索到叶子节点就更新一次maxnum值（小于maxnum则更新）（初值为一个较大的数），是用一次搜索结束后三个机器中花费时间最长的机器的所用时间作为此次分配的所用时间。</p>
<p>一个任务存在n种状态，即选择被哪台机器所完成，程序分为两部分，上半部分是赋值，下半部分是剪枝，不断把符合条件的值往优先队列里整，并且通过循环，不断优化结果。</p>
<p><strong>代码：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">100</span>];<span class="comment">//机器</span></span><br><span class="line"><span class="keyword">int</span> x1[<span class="number">100</span>];<span class="comment">//作业</span></span><br><span class="line"><span class="keyword">int</span> maxnum=<span class="number">1000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> level)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(level>n){</span><br><span class="line">     <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<=k;i++){</span><br><span class="line">        <span class="keyword">if</span>(x[i]>temp){</span><br><span class="line">            temp=x[i];</span><br><span class="line">        }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">if</span>(temp<maxnum){< span><br><span class="line">        maxnum=temp;</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<=k;i++){</span><br><span class="line">            x[i]+=x1[level];</span><br><span class="line">            task(level+<span class="number">1</span>);</span><br><span class="line">            x[i]-=x1[level];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    <span class="built_in">cin</span> >> k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<=n;i++){</span><br><span class="line">        <span class="built_in">cin</span> >>x1[i];</span><br><span class="line">    }</span><br><span class="line">    task(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> << maxnum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></maxnum){<></span></pre></td></tr></tbody></table></figure></div>
</body></html>]]></content>
  </entry>
  <entry>
    <title>算法分析与设计之回溯法</title>
    <url>/2020/11/30/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><h3 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h3><h4 id="1-什么是回溯法"><a href="#1-什么是回溯法" class="headerlink" title="1. 什么是回溯法"></a>1. 什么是回溯法</h4><ul>
<li>可以系统的搜索一个问题的所有解或者任意解，他是一个既带有系统性又带有跳跃性的搜索算法。</li>
<li>回溯法求问题的一个解时，只要搜索到问题的一个解就可以结束。</li>
</ul>
<h4 id="2-回溯法思想"><a href="#2-回溯法思想" class="headerlink" title="2. 回溯法思想"></a>2. 回溯法思想</h4><ul>
<li>针对所给问题，定义问题的解空间。</li>
<li>确定易于搜索的解空间结构</li>
<li>以深度有线方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索（<strong>剪枝函数：</strong> 用约束函数在扩展节点处减去不满足约束的子树，用限界函数剪去得不到最优解的子树。）</li>
</ul>
<h4 id="3-回溯设计策略"><a href="#3-回溯设计策略" class="headerlink" title="3. 回溯设计策略"></a>3. 回溯设计策略</h4><div class="table-container">
<table>
<thead>
<tr>
<th>装载问题</th>
<th>批处理作业调度</th>
</tr>
</thead>
<tbody>
<tr>
<td>符号三角形问题</td>
<td>n后问题</td>
</tr>
<tr>
<td>0-1背包问题</td>
<td>图的m着色问题</td>
</tr>
<tr>
<td>最大团问题</td>
<td>旅行售货员问题</td>
</tr>
<tr>
<td>电路板排列问题</td>
<td>圆排列问题</td>
</tr>
<tr>
<td>电路板排列问题</td>
<td>连续邮资问题</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-算法框架"><a href="#4-算法框架" class="headerlink" title="4. 算法框架"></a>4. 算法框架</h4><ul>
<li>递归回溯</li>
<li>迭代回溯</li>
<li>子集树算法框架</li>
<li>排列树算法框架</li>
</ul>
<h4 id="1-装载问题"><a href="#1-装载问题" class="headerlink" title="1. 装载问题"></a>1. 装载问题</h4><p>当前载重量cw+剩余集装箱的重量r小于等于点前最优载重量bestw</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">  <span class="comment">//搜索第i层结点</span></span><br><span class="line">  <span class="keyword">if</span>(i<n)<span class="comment">//到达叶结点 </n)<span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//更新最优解</span></span><br><span class="line">  r -=w[i];</span><br><span class="line">  <span class="keyword">if</span>(cw + w[i] <= c){<span class="comment">//搜索左子树</span></span><br><span class="line">    x[i] = <span class="number">1</span>;</span><br><span class="line">    cw += w[i];</span><br><span class="line">    backtrcak(i+<span class="number">1</span>);</span><br><span class="line">    cw -= w[i];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(cw + r >bestw){</span><br><span class="line">    x[i] = <span class="number">0</span>;<span class="comment">//搜索右子树</span></span><br><span class="line">    backtrack(i+<span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line">  r += w[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//bestx 目前得到的最优解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maxloading</span><span class="params">(<span class="keyword">int</span> w[],<span class="keyword">int</span> c,<span class="keyword">int</span> n,<span class="keyword">int</span> bestx[])</span></span>{</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//当前层 x[1:x-1]为当前路径</span></span><br><span class="line">  <span class="keyword">int</span> *x = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> bestw = <span class="number">0</span>,cw = <span class="number">0</span>,r = <span class="number">0</span>;<span class="comment">//当前最优值放在cw</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j<=n;j++)</span><br><span class="line">    r+=w[j];<span class="comment">//求所有的集装箱总和</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">    <span class="keyword">while</span>(i<=n && cw + w[i]<=c){</span><br><span class="line">      r -= w[i];</span><br><span class="line">      cw += w[i];</span><br><span class="line">      x[i] = <span class="number">1</span>;</span><br><span class="line">      i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i>n){</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j<=n;j++)</span><br><span class="line">        bestx[j] = x[j];</span><br><span class="line">      bestw = cw;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">      r -= w[i];</span><br><span class="line">      x[i] = <span class="number">0</span>;</span><br><span class="line">      i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(cw+r <= bestw){</span><br><span class="line">      i--;</span><br><span class="line">      <span class="keyword">while</span>(i><span class="number">0</span> && !x[i]){<span class="comment">//从右子树返回</span></span><br><span class="line">        r += w[i];</span><br><span class="line">        i--;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">delete</span> []x;</span><br><span class="line">        <span class="keyword">return</span> bestw;</span><br><span class="line">      }</span><br><span class="line">      x[i] = <span class="number">0</span>;</span><br><span class="line">      cw -= w[i];<span class="comment">//进入右子树</span></span><br><span class="line">      i++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h4 id="2、批处理作业调度"><a href="#2、批处理作业调度" class="headerlink" title="2、批处理作业调度"></a>2、批处理作业调度</h4><p><strong>问题描述：</strong>给定n个作业集合</p>
<p><strong>5-1 子集合问题：</strong> 子集合问题的一个实例为$<s,t>$。其中$S = {x<em>1,x_2,…,x_n}$是一个正整数的集合，c是一个正整数。子集合问题判定是否存在S的一个子集$S_1$，使得$\sum</em>{x\in{S1}}x = c$。试设计一个解子集和问题的回溯法。</s,t></p>
<p><strong>数据输入：</strong>第一行有两个正整数$n,c$，n表示S的大小，c是子集和的目标值。接下来的一行中，有n个正整数，表示集合S中的元素。</p>
<p><strong>结果输出：</strong> 将子集和问题的解输出，当问题无解时，输出“No Solution!”。</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>题解：</strong></p>
<p>5-3 </p>
<p>5-6</p>
<p>5-13</p>
</body></html>]]></content>
  </entry>
  <entry>
    <title>算法设计与分析之贪心算法</title>
    <url>/2020/11/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%E5%8A%A0%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%89/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h3 id="贪心算法（算法理解加经典例题解析）"><a href="#贪心算法（算法理解加经典例题解析）" class="headerlink" title="贪心算法（算法理解加经典例题解析）"></a>贪心算法（算法理解加经典例题解析）</h3><h3 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h3><h4 id="1-什么是贪心算法？"><a href="#1-什么是贪心算法？" class="headerlink" title="1. 什么是贪心算法？"></a>1. 什么是贪心算法？</h4><ul>
<li><p>顾名思义，总是在作出当前看来最好的选择。</p>
</li>
<li><p>并不从整体最优考虑，只是某种程度上的局部最优选择。</p>
</li>
<li><p>不一定是最优解，但往往是最接近最优解的。</p>
</li>
</ul>
<h4 id="2-贪心设计策略"><a href="#2-贪心设计策略" class="headerlink" title="2. 贪心设计策略"></a>2. 贪心设计策略</h4><ol>
<li>活动安排问题</li>
<li>最优装载问题</li>
<li>哈夫曼编码</li>
<li>单源最短路径</li>
<li>最小生成树</li>
<li>多机调度问题</li>
</ol>
<h4 id="3-贪心选择性质"><a href="#3-贪心选择性质" class="headerlink" title="3. 贪心选择性质"></a>3. 贪心选择性质</h4><ol>
<li><p>贪心算法通常自顶向下的方式进行</p>
</li>
<li><p>最优子结构性质</p>
</li>
</ol>
<h3 id="二、习题解析"><a href="#二、习题解析" class="headerlink" title="二、习题解析"></a>二、习题解析</h3><h4 id="1-会场安排问题"><a href="#1-会场安排问题" class="headerlink" title="1. 会场安排问题"></a>1. 会场安排问题</h4><p><strong>题目：</strong> 假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。设计一个有效的贪心算法进行安排。（这个问题实际上是著名的图着色问题。若将每个活动作为一个图的顶点，不相容活动间用边相连。使相邻顶点着有不同颜色的最小着色数，相当于要找的最小会场数。）</p>
<p><strong>数据输入：</strong> 第一行有一个正整数$k$ ，表示有$k$ 个待安排的活动，接下来的$k$ 行中，每行有2个正整数，分别表示$k$ 个待安排的活动屁那个的开始时间和结束时间。时间以0点开始的分钟计。</p>
<p><strong>结果输出：</strong> 将计算的最少会场数输出</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">23</span></span><br><span class="line"><span class="number">12</span> <span class="number">28</span></span><br><span class="line"><span class="number">25</span> <span class="number">35</span></span><br><span class="line"><span class="number">27</span> <span class="number">80</span></span><br><span class="line"><span class="number">36</span> <span class="number">50</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>1.题解：</strong> 这里采用贪心策略，每一步最优，即下一个会议的开始时间大于等于之前任意一个会议的结束时间，那么这两个会议可以安排在同一个会议室。如果该会议开始了，但是之前的会议都还没有结束，那么就另起一个会议室。</p>
<p>需要注意的是，当两个会议安排在同一个会议室时，那么下次判断时间的时候要以后者的会议结束时间为准，要将前者的会议时间覆盖。</p>
<p>在这里，用到的会议室总数用$num$记录，$flag$记录的是第$i$个会议用在哪个会议室（更新）</p>
<p><strong>代码：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="comment">//会场安排问题，贪心策略，每一步最优</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meeting</span> {</span></span><br><span class="line">	<span class="keyword">int</span> start;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">}m[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">1000</span>] = {<span class="number">0</span>};<span class="comment">//记录会场个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>>>n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i<n; i++) {< span><br><span class="line">		<span class="built_in">cin</span>>>m[i].start;</span><br><span class="line">		<span class="built_in">cin</span>>>m[i].<span class="built_in">end</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">1</span>;<span class="comment">//会场个数</span></span><br><span class="line">	flag[start] = num;<span class="comment">//在哪个会场开会</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i<n; i++) {< span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = start;j<i;j++){< span><br><span class="line">		<span class="keyword">if</span> (m[j].<span class="built_in">end</span><=m[i].start && flag[j]) {</span><br><span class="line">			flag[i] = flag[j];</span><br><span class="line">			flag[j] = <span class="number">0</span>;</span><br><span class="line">			temp = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="number">0</span>) {</span><br><span class="line">			num++;</span><br><span class="line">			flag[i] = num;</span><br><span class="line">		}<span class="keyword">else</span> temp = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span><<num<<<span class="built_in">endl</num<<<span></span>;</i;j++){<></span><br><span class="line">}</span><br></n;></span></n;></span></pre></td></tr></tbody></table></figure></div>
<h4 id="2-最优合并问题"><a href="#2-最优合并问题" class="headerlink" title="2. 最优合并问题"></a>2. 最优合并问题</h4><p><strong>题目：</strong> 给定$k$个排好序的序列$s1,s2,…,sk$，用$2$路合并算法将这$k$个序列合并成一个序列。假设所采用的2路合并算法合并两个长度分别为$m$和$n$的序列需要$m+n-1$次比较。试设计一个算法确定合并这个序列的最优合并顺序，使所需要的总比较次数最少。 </p>
<p><strong>数据输入：</strong> 第一行有一个正整数$k$，表示有$k$个待合并序列。接下来的一行中，有$k$个正整数，表示个待合并序列的长度。</p>
<p><strong>数据输出：</strong> 将计算的最多比较次数和最少比较次数输出</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">12</span> <span class="number">11</span> <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">78</span> <span class="number">52</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>2.题解：</strong> 贪心策略，局部最优考虑。比较一次需要$m+n-1$次，那么对于最少比较次数 ，每一个都使m，n是最小的两个值，对于例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>当前序列</th>
<th>合并</th>
<th>总和</th>
<th>剩余序列</th>
</tr>
</thead>
<tbody>
<tr>
<td>2,5,11,12</td>
<td>2+5 = 7</td>
<td>2+5-1 = 6</td>
<td>7,11,12</td>
</tr>
<tr>
<td>7,11,12</td>
<td>7+11 = 18</td>
<td>6+18-1 = 23</td>
<td>12,18</td>
</tr>
<tr>
<td>12,18</td>
<td>12+18 = 30</td>
<td>23+30-1 = 52</td>
<td>30</td>
</tr>
</tbody>
</table>
</div>
<p>同理最大比较次数与之相反。</p>
<p><strong>代码：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 最优升序比较</span></span><br><span class="line"><span class="comment">2. 最差降序比较</span></span><br><span class="line"><span class="comment">贪心策略，每一步最优</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//序列个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> a>b;</span><br><span class="line">}<span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Huffman</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i < n<span class="number">-1</span>;i++) {</span><br><span class="line">		a[i+<span class="number">1</span>] = a[i]+a[i+<span class="number">1</span>];</span><br><span class="line">		sum += a[i+<span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1000</span>] = {};<span class="comment">//升序</span></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">1000</span>] = {};<span class="comment">//降序</span></span><br><span class="line">	<span class="built_in">cin</span>>>n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i<n;i++){ < span><br><span class="line">		<span class="built_in">cin</span>>>a[i];</span><br><span class="line">		b[i] = a[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//排序---最优</span></span><br><span class="line">	sort(a, a+n);<span class="comment">//升序</span></span><br><span class="line">	sort(b, b+n,cmp);</span><br><span class="line">	<span class="built_in">cout</span><<huffman(a, n)-n+<span class="number">1</huffman(a,></span><<<span class="built_in">endl</span>;</n;i++){></span><br><span class="line">	<span class="built_in">cout</span><<huffman(b, n)-n+<span class="number">1</huffman(b,></span><<<span class="built_in">endl</span>;<br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h4 id="3-最优服务次序问题"><a href="#3-最优服务次序问题" class="headerlink" title="3. 最优服务次序问题"></a>3. 最优服务次序问题</h4><p><strong>题目：</strong> 设有$n$个顾客同时等待一项服务，顾客$i$需要的服务时间为$t_i(1\leq i \leq n  )$。应该如何安排n个顾客的服务次序才能使平均等待时间达到最小？平均等待时间是n个顾客等待服务时间的总和除以$n$。</p>
<p><strong>数据输入：</strong> 第一行正整数$n$，表示有$n$个顾客。接下来的1行中，有$n$个正整数，表示n个顾客需要的服务时间。</p>
<p><strong>结果输出：</strong> 将计算的最小平均等待时间输出。</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">56</span> <span class="number">12</span> <span class="number">1</span> <span class="number">99</span> <span class="number">1000</span> <span class="number">234</span> <span class="number">33</span> <span class="number">55</span> <span class="number">99</span> <span class="number">812</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">532.00</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>3.题解：</strong> 贪心策略，最短服务时间优先，在人数一定时，总的等待时间越短，平均时间也就越短，因此，现将所有顾客等待时间进行升序排列，然后求和。</p>
<p><strong>代码：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="comment">//最优服务次序问题，贪心策略，即最短服务时间优先，类似于最优合并排序</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>] = {<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Huffman</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i < n;i++) a[i] += a[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">double</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i<n;i++) t +="a[i];</span"><br><span class="line">	t /= n;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">	<span class="built_in">cin</span>>>n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i < n;i++) <span class="built_in">cin</span> >> a[i];</span><br><span class="line">	sort(a,a+n);<span class="comment">//升序排列</span></span><br><span class="line">	<span class="built_in">cout</span><<huffman(a, n)<<<span class="built_in">endl</huffman(a,></span>;</n;i++)></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h4 id="4-虚拟汽车加油站问题"><a href="#4-虚拟汽车加油站问题" class="headerlink" title="4. 虚拟汽车加油站问题"></a>4. 虚拟汽车加油站问题</h4><p><strong>问题描述：</strong> 一辆虚拟汽车加满油后可行驶$nkm$。旅途中有若干加油站。设计一个有效算法，指出应在哪些加油站停靠加油，使沿途加油次数最少。并证明算法能产生一个最优解。</p>
<p><strong>数据输入：</strong> 第一行有2个正整数$n$和$k$，表示汽车加满油后可行驶$nkm$，且旅途中有$k$个加油站。接下来的1行中有$k+1$个整数，表示第$k$个加油站与第$k-1$个加油站之间的距离。第0个加油站表示出发地，汽车已加满油。第$k+1$个加油站表示目的地。</p>
<p><strong>数据输出：</strong> 将计算的最少加油次数输出。</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong> </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>4.题解：</strong> 贪心策略，最远加油站优先，从前往后走，每一次都计算出最远能到达的加油站。由局部最优解最终算出全局最优解</p>
<p><strong>代码：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//贪心策略，最远加油站优先</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>,s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i<=k;i++) {</span><br><span class="line">		<span class="keyword">if</span> (a[i] > n) {</span><br><span class="line">			<span class="built_in">cout</span><<<span class="string">"ERROR!"</span><<<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i< k;i++) {</span><br><span class="line">		<span class="keyword">if</span> (n>= a[i]+a[i+<span class="number">1</span>]) {</span><br><span class="line">			a[i+<span class="number">1</span>] += a[i];</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			sum++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1000</span>] = {};</span><br><span class="line">	<span class="built_in">cin</span>>>n;</span><br><span class="line">	<span class="built_in">cin</span>>>k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i<=n;i++) <span class="built_in">cin</span>>>a[i];</span><br><span class="line">	<span class="built_in">cout</span><<greedy(a,n,k);< span><br><span class="line">}</span><br></greedy(a,n,k);<></span></pre></td></tr></tbody></table></figure></div>
<h4 id="5-最优分解问题"><a href="#5-最优分解问题" class="headerlink" title="5. 最优分解问题"></a>5. 最优分解问题</h4><p><strong>问题描述：</strong> 设n是一个正整数。现要求将n分解为若干互不相同的自然数的和，且使这些自然数的乘积最大。</p>
<p><strong>数据输入：</strong> 第一行正整数n</p>
<p><strong>结果输出：</strong> 将计算的最大乘积输出</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong> </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>5.题解：</strong> 将n分成从2开始的连续自然数的和，如果最后剩下一个数，将此数在后项优先的方式下均匀的地分给前面各项。对于10，可以分成2，3，4最后还剩1，以后项优先的方式分配，所以就是2，3，5。结果就是$(2\times3\times5 = 30)$  </p>
<p>原理：在固定总和数的情况下，两个数相差越小，乘积越大，因数越多，乘积越大。</p>
<p><strong>代码：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="comment">//最优分解问题</span></span><br><span class="line"><span class="comment">//贪心算法：将n分解为以2开始连续自然数之和</span></span><br><span class="line"><span class="comment">//原理：在固定总和数的情况下，两个数相差越小，乘积越大，因数越多，乘积越大。</span></span><br><span class="line"><span class="comment">//几何意义解释：固定周长，正方形面积大于长方形</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(n < <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1000</span>] = {};</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	n -= a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; ;i++){</span><br><span class="line">		<span class="keyword">if</span>(n >= a[i]+<span class="number">1</span>){</span><br><span class="line">		a[i+<span class="number">1</span>] = a[i]+<span class="number">1</span>;</span><br><span class="line">		n = n - a[i+<span class="number">1</span>];</span><br><span class="line">	  }<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">	<span class="keyword">int</span> t = i;<span class="comment">//保存最后一位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = n;j><span class="number">0</span>;j--){</span><br><span class="line">		<span class="keyword">if</span>(t) a[t--] += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			a[t] += <span class="number">1</span>;</span><br><span class="line">			t = i;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//求乘积</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j<=i;j++) sum = sum * a[j];</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>>>n;</span><br><span class="line">	<span class="built_in">cout</span><<maxarea(n);< span><br><span class="line">}</span><br></maxarea(n);<></span></pre></td></tr></tbody></table></figure></div>
</body></html>]]></content>
      <categories>
        <category>算法分析与设计</category>
      </categories>
      <tags>
        <tag>上课笔记 - 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析之动态规划</title>
    <url>/2020/11/14/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="算法设计与分析之动态规划"><a href="#算法设计与分析之动态规划" class="headerlink" title="算法设计与分析之动态规划"></a>算法设计与分析之动态规划</h2><h3 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h3><h4 id="1-什么是动态规划算法"><a href="#1-什么是动态规划算法" class="headerlink" title="1. 什么是动态规划算法"></a>1. 什么是动态规划算法</h4><p>动态规划算法与分治法类似，其基本思想是将待求问题分解成若干个子问题，先求子问题，再结合这些子问题的解得到原问题的解，与分治法不同的是，动态规划会将前面求得的子问题的解保存在一个表中，在需要时用到以求得的答案，这样避免了重复的大量计算。</p>
<h4 id="2-动态规划的步骤"><a href="#2-动态规划的步骤" class="headerlink" title="2. 动态规划的步骤"></a>2. 动态规划的步骤</h4><ol>
<li>找出最优解的性质，并刻画其结构特征。</li>
<li>递归的定义最优值。</li>
<li><p>自底向上的方式计算最优值。</p>
</li>
<li><p>根据计算最优值时得到的信息，构造最优解。</p>
</li>
</ol>
<h4 id="3-动态规划算法的基本要素"><a href="#3-动态规划算法的基本要素" class="headerlink" title="3. 动态规划算法的基本要素"></a>3. 动态规划算法的基本要素</h4><ol>
<li><strong>最优子结构性质</strong>：问题的最优解包含子问题的最优解，反过来说，我们可以通过子问题的最优解求出问题的最优解。也可以理解为，后面的状态可以通过前面的状态推到出来。</li>
<li><strong>重叠子问题性质</strong>：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态</li>
</ol>
<h3 id="二、习题以及解析"><a href="#二、习题以及解析" class="headerlink" title="二、习题以及解析"></a>二、习题以及解析</h3><h4 id="1-独立任务最优调度问题"><a href="#1-独立任务最优调度问题" class="headerlink" title="1. 独立任务最优调度问题"></a>1. 独立任务最优调度问题</h4><p><strong>题目：</strong> 用2台处理机$A$和$B$处理$n$个作业。设第i个作业交给机器A处理时需要时间$a_i$,若由机器B来处理，则需要时间$b_i$。由于各作业的特点和机器的性能关系，很可能对于某些$i$ ,有$a_i\geq b_i$ ，而对于某些$j$ ，$j\neq i$ 有$a_j>b_j$ 。既不能将一个作业分开由两台机器处理，也没有一台机器能同时处理2个作业。设计一个动态规划算法，使得这2台机器处理完这$n$个作业时间最短（从任何一台机器开弓到最后一台机器停工的总时间）。研究一个实例：$(a_1,a_2,a_3,a_4,a_6) = (2,5,7,10,5,2),(b_1,b_2,b_3,b_4,b_5,b_6) = (3,8,4,11,3,4)$。</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">7</span> <span class="number">10</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">11</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">15</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>1.题解：</strong>利用dp存储每个状态的结果，最后选出最优的一个解。转换方程：$dp[i][j]=min(dp[i-1][j]+b[i],dp[i-1][j-a[i]]);dp[i][j]$代表做完前i个任务，A机器花几分钟情况下，B机器所花的时间，也就是说$dp[i][j]$就是表示B机器所花时间。</p>
<p>$dp[i][j] = dp[i-1][j]+b[i]$代表第i个任务交给B来做，所以做完前i个任务的时候,A机器和前$i - 1$的任务一样，还是花了j分钟，而B机器则花$dp[i-1][j]+b[i]$分钟；</p>
<p>$dp[i][j] = dp[i-1][j-a[i]]$代表第i个任务交给A来做，现在的A机器花费时间是j，所以在前$i - 1$个任务完成的时候，A机器是花了$j-a[i]$分钟的，所以现在B机器还是花了$dp[i-1][j-a[i]]$分钟；</p>
<p>一直到$dp[n][i]$:代表所有的任务都做完了，B机器所花费的时间，那么最迟的时间就是B的时间和A的时间求最大值；</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i<=sum; i++)</span><br><span class="line">  ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(dp[n][i],i));<span class="comment">//max(dp[n][i],i)</span></span><br></pre></td></tr></tbody></table></figure></div>
<p>表示完成前n个作业A机器花i分钟 B机器花$dp[n][i]$分钟情况下，最迟完工时间 </p>
<p><strong>代码：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><algorithm></algorithm></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><string.h></string.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">201</span>], b[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">202</span>][<span class="number">10000</span>];<span class="comment">//dp[i][j] 表示前i个作业中A机器花j分钟的时候 B机器所花时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>{</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i<=n; i++) <span class="built_in">cin</span>>>a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i<=n; i++) <span class="built_in">cin</span>>>b[i];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i<=n; i++) {</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j<=sum; j++) {</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+b[i];<span class="comment">//dp[i-1][j]中对a的时间分配已经分配好，无需在判断a，直接添加b[i]的时间。</span></span><br><span class="line">            <span class="keyword">if</span>(j>=a[i]) dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+b[i],dp[i<span class="number">-1</span>][j-a[i]]);<span class="comment">//当时间超过当前a[i] 就需要判断是否需要更新</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">999999</span>;</span><br><span class="line">    <span class="comment">//max(dp[n][i],i) 表示完成前n个作业A机器花i分钟 B机器花dp[n][i]分钟情况下，最迟完工时间，最后一个机器完成才算最终完成。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i<=sum; i++)ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(dp[n][i],i));</span><br><span class="line">    <span class="built_in">cout</span><<ans<<<span class="built_in">endl</ans<<<span></span>;<br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h4 id="2-最优批处理问题"><a href="#2-最优批处理问题" class="headerlink" title="2. 最优批处理问题"></a>2. 最优批处理问题</h4><p><strong>问题描述：</strong> 在一台超级计算机上，编号为1、2、3…、n的n个作业等待批处理，批处理的任务就是将这n个作业分成若干批，每批包含相邻的若干作业。从时刻0开始，分批加工这些作业。在每批作业开始前，机器需要启动时间S而完成这批作业所需的时间是单独完成批中各个作业需要时间的总和。单独完成第$i$个作业所需要的时间是$t_i$，所需的费用是它的完成时刻乘以一个费用系数$f_i$</p>
<p><strong>题解：</strong></p>
<p>设$z_i$是</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">153</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>2.题解</strong></p>
<p><a href="/Users/Yan/Library/Application Support/typora-user-images/image-20201123112546597.png" data-fancybox="group" data-caption="image-20201123112546597" class="fancybox"><img alt="image-20201123112546597" title="image-20201123112546597" data-src="/Users/Yan/Library/Application Support/typora-user-images/image-20201123112546597.png" class="lazyload"></a></p>
<p><strong>代码：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> z[<span class="number">1000</span>] = {};</span><br><span class="line"><span class="keyword">int</span> S,n;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">1000</span>] = {},sw[<span class="number">1000</span>] = {};</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">1000</span>] = {},w[<span class="number">1000</span>] = {};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dyna</span><span class="params">()</span></span>{</span><br><span class="line">    z[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--) {</span><br><span class="line">        <span class="comment">//倒序累加</span></span><br><span class="line">        st[i] = st[i+<span class="number">1</span>]+t[i];<span class="comment">//</span></span><br><span class="line">        sw[i] = sw[i+<span class="number">1</span>]+w[i];<span class="comment">//</span></span><br><span class="line">        z[i] = (st[i]+S)*sw[i];<span class="comment">//初始化每一个任务各一个组</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j<=n+<span class="number">1</span>;j++)</span><br><span class="line">        z[i] = <span class="built_in">min</span>(z[i],z[j]+sw[i]*(S+st[i]-st[j]));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> z[<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    <span class="built_in">cin</span>>>n;</span><br><span class="line">    <span class="built_in">cin</span>>>S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i<=n; i++) {</span><br><span class="line">        <span class="built_in">cin</span>>>t[i];</span><br><span class="line">        <span class="built_in">cin</span>>>w[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span><<dyna()<<<span class="built_in">endl</dyna()<<<span></span>;<br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h4 id="3-石子合并问题"><a href="#3-石子合并问题" class="headerlink" title="3. 石子合并问题"></a>3. 石子合并问题</h4><p><strong>问题描述：</strong> 在一个圆形操场摆放着$n$堆石子。现将石子有次序的合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。设计一个算法，计算出将n堆石子合并成一堆最小得分和最大得分。</p>
<p><strong>输入：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">54</span></span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>3.题解：</strong></p>
<p>首先，我们对这两个结果进行解释。对于这四堆石子，我们可以先从左到右合并，那它的得分就是：</p>
<script type="math/tex; mode=display">
 (4+4)+(4+4+5)+(4+4+5+9) = 43</script><p>会发现最小得分是优先合并石子数少的两堆，相反，最大得分就是优先合并石子数多的两堆，也就有：</p>
<script type="math/tex; mode=display">
(9+5)+(9+5+4)+(9+5+4+4) = 54</script><p>注意并不是所有测试案例都是有一定顺序的，如 9，4，4，5 的结果与上述一致，因此每一次都需要进行判断相邻两堆相加的值是当前得分最小或最大的。</p>
<p>难点在于把环形当做直线型</p>
<p>4 4 5 9 5 4 4</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><algorithm></algorithm></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Arr[<span class="number">300</span>],Sum[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">int</span> Min[<span class="number">300</span>][<span class="number">300</span>], Max[<span class="number">300</span>][<span class="number">300</span>];<span class="comment">//第i到第j堆求和分数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= n; i++) {</span><br><span class="line">        <span class="built_in">cin</span> >> Arr[i];</span><br><span class="line">        Arr[i + n] = Arr[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最大和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= <span class="number">2</span> * n; i++) {</span><br><span class="line">        Sum[i] = Sum[i - <span class="number">1</span>] + Arr[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始递归循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n<span class="number">-1</span>; i >= <span class="number">1</span>; i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j < i + n; j++) {</span><br><span class="line">            Min[i][j] = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k < j; k++) {</span><br><span class="line">                Min[i][j] = <span class="built_in">min</span>(Min[i][j], Min[i][k] + Min[k + <span class="number">1</span>][j] + Sum[j] - Sum[i - <span class="number">1</span>]);</span><br><span class="line">                Max[i][j] = <span class="built_in">max</span>(Max[i][j], Max[i][k] + Max[k + <span class="number">1</span>][j] + Sum[j] - Sum[i - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历找到最大与最小值</span></span><br><span class="line">    <span class="keyword">int</span> MaxValue = <span class="number">0</span>, MinValue = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= n; i++) {</span><br><span class="line">        MaxValue = <span class="built_in">max</span>(MaxValue, Max[i][i + n - <span class="number">1</span>]);</span><br><span class="line">        MinValue = <span class="built_in">min</span>(MinValue, Min[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << MinValue << <span class="built_in">endl</span> << MaxValue << <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h4 id="4-最小m段和问题"><a href="#4-最小m段和问题" class="headerlink" title="4. 最小m段和问题"></a>4. 最小m段和问题</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>] = {};</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>] = {};<span class="comment">//i长度 j段数。</span></span><br><span class="line"><span class="keyword">int</span> min1,max1,temp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i<=n; i++) {</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i<=n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j<=m; j++) {</span><br><span class="line">            min1 = <span class="number">99999</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k<i; k++) {< span><br><span class="line">                min1 = <span class="built_in">min</span>(min1,<span class="built_in">max</span>(dp[k][j<span class="number">-1</span>],dp[i][<span class="number">1</span>]-dp[k][<span class="number">1</span>]));</span><br><span class="line">            }</span><br><span class="line">            dp[i][j] = min1;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">cin</span>>>n>>m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i<=n; i++) <span class="built_in">cin</span>>>a[i];</span><br><span class="line">    <span class="built_in">cout</span><<solve()<<<span class="built_in">endl</solve()<<<span></span>;</i;></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
</body></html>]]></content>
      <categories>
        <category>算法分析与设计</category>
      </categories>
      <tags>
        <tag>上课笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>向水学习</title>
    <url>/2020/09/08/2020-09-08-%E5%90%91%E6%B0%B4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id><a href="#" class="headerlink" title=" "></a> </h1><h3 id="向水学习"><a href="#向水学习" class="headerlink" title="向水学习"></a><strong>向水学习</strong></h3><h4 id="黄永武"><a href="#黄永武" class="headerlink" title="黄永武"></a><strong>黄永武</strong></h4><p>地水火风，水是构成大千世界的要素之一，随处展现在眼前，又是水流动，有时水停蓄，老子看了就说：“最美妙的就是水，它简直就是道！”孔子看水也激动地大叫：“水载，水载。”表示他内心美妙得难以形容的赞叹！</p>
<p>古人对水为什么如此崇拜？是发现水有哪些德行？望着天天见面的水，该学习哪些方面呢？</p>
<p>水供应万物是普遍而无私的，有了水，万物才能生长；有了水，国家才安宁。水，有利于万物，却不与万物争利，最有德行。</p>
<p>水处在大家厌恶的地下，一切污秽丢向它，它的默默接受，尽管是废水污水，他总是要努力净化污秽成为洁美，他像善于教化的老师。</p>
<p>水有“去盈就备”的性格，水愈大，处的地位愈地，海处在最卑下的位置，百川都归向它，它像一个有道而修养深厚的哲人，也像最重义气的老大。</p>
<p>水载悬崖绝壁上奔腾而下，踩落再深的坑谷，也不回顾，像果决赴难的英雄，不畏粉神碎骨，真勇敢。</p>
<p>水流过去，不管有坑洞，有高坡，最后汪洋万里都安于一律平等，像法律。</p>
<p>水最柔弱，但持之以恒，竟滴水穿石。水源着一定的理走，再小的地方也不放过，何处有缝隙，水就浸润透达，它明察秋毫，像一个智者。</p>
<p>千缨万折的水，不改变东向的决心，历险致远，就像不可劫夺的志向。水遇到地方障碍，就安于规范，即可把自己清净下来，仿佛随遇而安，像一个乐知天命的人。</p>
<p>滚滚的水是先流满一个坑洞再前进的，所谓盈科而后进，就像君子要循序渐进，不愿邋第。</p>
<p>水要有源头才不枯竭，盗一时嘘声浮名的人，想大雨满集在沟中的水，没多久就枯竭了。</p>
<p>水是最清澈，最能辨别美丑，然而它广照万物，不分美丑，无物不照，心胸是十分宽广的。</p>
<p>水动的时候，有喷薄的景观，有汹涌的形势。凝凝然净下来又可以水天一色，波平如镜。无论动或静，水绝不止于外表的美观。而有君子殿可乐的内涵，它那“周流无滞”的作风，想一个通达事理的智者，所以说智者乐水。</p>
<p>综合而言：沐浴众生，泽及万物，谁最仁慈；疏通江河，自截盈满，而流于谦卑，水最智慧。水的德行如此，能不向水学习？</p>
<hr>
<p>孔子在川上，忽然有所领悟，说了一句：“逝者如斯夫，不舍昼夜。”孔子在想什么，丢下一个谜团给人猜。</p>
<p>有人说：“水洸洸然就像‘道’的无穷无尽！”</p>
<p>有人说：“流水一刻不停地逝去，如同时间的流逝，时间虽然无穷，但是人生是有涯的，生命只是一个泡影，所以要早就自己，孝顺父母，都要及时呀！”</p>
<p>有人又说：“孔子是在唤醒君子自强不息，昼夜不能稍息，像水不达到海，就绝不改变。‘万折而比东’的志向，不要像沼泽的水，无法行远；不要像涂潦之水，无法持久；不要像横流的水，失其所归，要学习不舍昼夜的川流。</p>
<hr>
</body></html>]]></content>
      <categories>
        <category>散文集</category>
      </categories>
      <tags>
        <tag>散文</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>考研体验营----英语试讲</title>
    <url>/2020/08/30/2020-08-30-%E8%80%83%E7%A0%94%E4%BD%93%E9%AA%8C%E8%90%A5----%E8%8B%B1%E8%AF%AD%E8%AF%95%E8%AE%B2/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="领航体验营——英语"><a href="#领航体验营——英语" class="headerlink" title="领航体验营——英语"></a>领航体验营——英语</h2><h3 id="一、考研英语基本常识："><a href="#一、考研英语基本常识：" class="headerlink" title="一、考研英语基本常识："></a>一、考研英语基本常识：</h3><h4 id="1-考研英语考什么"><a href="#1-考研英语考什么" class="headerlink" title="1. 考研英语考什么"></a>1. 考研英语考什么</h4><div class="table-container">
<table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>题数</th>
<th>分数占比</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>完形填空</td>
<td>20个空</td>
<td>共十分</td>
</tr>
<tr>
<td>2</td>
<td>阅读</td>
<td>20个题</td>
<td>共四十分</td>
</tr>
<tr>
<td>3</td>
<td>新题型</td>
<td>5个题</td>
<td>共十分</td>
</tr>
<tr>
<td>4</td>
<td>翻译（英译汉）</td>
<td>5个题（一卷）一段话（二卷）</td>
<td>10（一）15（二）</td>
</tr>
<tr>
<td>5</td>
<td>作文</td>
<td>小作文</td>
<td>10分</td>
</tr>
<tr>
<td>6</td>
<td>作文</td>
<td>大作文</td>
<td>20分（二）15分（一）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-英语基本功："><a href="#2-英语基本功：" class="headerlink" title="2. 英语基本功："></a>2. 英语基本功：</h4><ul>
<li><p>单词：考试掌握5500词汇以及相关短语，除此之外，还应掌握词汇之间词义意思：同义词，近义词，反义词，掌握词汇之间的搭配关系，如动词与介词，形容词与介词，形容词与名字。掌握词汇生成的基本知识，如词源，词根，词缀等。</p>
<p>另外，大纲中许多单词特殊形式未在词汇表中直接出现，但作为派生词而不是生词。</p>
</li>
<li><p>语法：语法知识尤为重要，长难句解析。</p>
</li>
<li><p>思维：出题规律，解题方法以及个人思维。注：阅读题大多出自外国著名<strong>期刊</strong>，但出题人却是中国人，因此思维逻辑很重要。</p>
</li>
</ul>
<h3 id="二、课上笔记"><a href="#二、课上笔记" class="headerlink" title="二、课上笔记"></a>二、课上笔记</h3><h4 id="1、如何背单词"><a href="#1、如何背单词" class="headerlink" title="1、如何背单词"></a>1、如何背单词</h4><ul>
<li><p>词根词缀法：</p>
<p>| 词根或词缀 | 意思            | 例                       | 解释                  |<br>| ————— | ———————- | ———————————— | ——————————- |<br>| a~         | 代表否定        | amorphous                | 无形状的              |<br>| ~ous       | 词缀形容词      | ponderous                | 笨重的                |<br>| re~        | 重复，往回      | review                   | 复习                  |<br>| dis~       | 否定<br>分离   |dissolved<br>dispersed   | 溶解<br>分散，扩散   |<br>| com~       | 共同，一起      | compel                   | 强迫，迫使            |<br>| pre~       | 之间            | 1                        | 1                     |</p>
</li>
<li><p>反复背诵</p>
</li>
<li>谐音联想法：ponderous 胖的要死 ——笨重的</li>
<li>语境记忆：真题</li>
</ul>
<h4 id="2-单词词组特殊记："><a href="#2-单词词组特殊记：" class="headerlink" title="2. 单词词组特殊记："></a>2. 单词词组特殊记：</h4><ul>
<li>单词</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>单词</th>
<th>词性</th>
<th>词义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>distinguishing</td>
<td>n</td>
<td>区分</td>
</tr>
<tr>
<td>2</td>
<td>detect</td>
<td>v</td>
<td>侦查</td>
</tr>
<tr>
<td>3</td>
<td>diffuse</td>
<td>v</td>
<td>驱散</td>
</tr>
<tr>
<td>4</td>
<td>even</td>
<td>adv</td>
<td>甚至，<strong>即使</strong></td>
</tr>
<tr>
<td>5</td>
<td>solid</td>
<td>n</td>
<td>固体</td>
</tr>
<tr>
<td>6</td>
<td>liquid</td>
<td>n</td>
<td>液体</td>
</tr>
<tr>
<td>7</td>
<td>depression</td>
<td>n</td>
<td>抑郁症</td>
</tr>
<tr>
<td>8</td>
<td>differentiate</td>
<td>v</td>
<td>区别</td>
</tr>
<tr>
<td>9</td>
<td>distinct<br>distinctive</td>
<td>adj</td>
<td>不同的</td>
</tr>
<tr>
<td>10</td>
<td>draw</td>
<td>v</td>
<td>得到，得出</td>
</tr>
<tr>
<td>11</td>
<td>means</td>
<td>n</td>
<td>方式方法（单复同形）</td>
</tr>
<tr>
<td>12</td>
<td>medium（media）</td>
<td>n</td>
<td>媒体，媒介</td>
</tr>
<tr>
<td>13</td>
<td>domiant</td>
<td>adj</td>
<td>主要的</td>
</tr>
<tr>
<td>14</td>
<td>company</td>
<td>n</td>
<td>公司；陪伴</td>
</tr>
<tr>
<td>15</td>
<td>hitherto</td>
<td>n</td>
<td>到目前为止</td>
</tr>
<tr>
<td>16</td>
<td>comparative</td>
<td>adj</td>
<td>相对的</td>
</tr>
<tr>
<td>17</td>
<td>respectable</td>
<td>adj</td>
<td>令人尊重的</td>
</tr>
<tr>
<td>18</td>
<td>formidable</td>
<td>adj</td>
<td>令人敬畏的</td>
</tr>
<tr>
<td>19</td>
<td>faint</td>
<td>adj</td>
<td>微弱的</td>
</tr>
<tr>
<td>20</td>
<td>municipal</td>
<td>adj</td>
<td>市政的</td>
</tr>
<tr>
<td>21</td>
<td>detach</td>
<td>v</td>
<td>分开；使—-分开</td>
</tr>
<tr>
<td>22</td>
<td>manipulation</td>
<td>n</td>
<td>操纵</td>
</tr>
<tr>
<td>23</td>
<td>class</td>
<td>n</td>
<td>等级；阶级</td>
</tr>
<tr>
<td>24</td>
<td>emergence</td>
<td>n</td>
<td>出现</td>
</tr>
<tr>
<td>25</td>
<td>raise</td>
<td>v</td>
<td>提升；<strong>抚养</strong>；<strong>筹集</strong></td>
</tr>
<tr>
<td>26</td>
<td>couple</td>
<td>n/v</td>
<td>夫妇；<strong>与—-联合一起</strong></td>
</tr>
<tr>
<td>27</td>
<td>quality</td>
<td>n</td>
<td>品质；特征</td>
</tr>
<tr>
<td>28</td>
<td>evolve</td>
<td>v</td>
<td>进化</td>
</tr>
<tr>
<td>29</td>
<td>involve</td>
<td>v</td>
<td>涉及</td>
</tr>
<tr>
<td>30</td>
<td>species</td>
<td>n</td>
<td>物种</td>
</tr>
<tr>
<td>31</td>
<td>establishment</td>
<td>n</td>
<td>建立</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>词组<ol>
<li>2038（十万）—— 203.8 million</li>
<li>one part in ten——十分之一</li>
<li>A of B——B的A</li>
<li>in the wake of——紧随——之后</li>
<li>but与yet 词义一致，但是。</li>
<li>in the light of 根据</li>
<li>result in 导致</li>
<li>in the company of 在—-陪伴之下</li>
</ol>
</li>
</ul>
<h4 id="3-语法知识"><a href="#3-语法知识" class="headerlink" title="3.语法知识"></a>3.语法知识</h4><ul>
<li><p>强调句： It is/was + 强调内容+that+剩余内容。</p>
<p>It was <strong>not until the 19th century</strong> that the newspaper became the dominant pre-electronic medium.</p>
</li>
<li><p>倒装句：否定意义的词位于句首+情态动词、助动词+主+谓。</p>
</li>
<li><p>定语从句：先行词，连词，连词省略，关系代词做宾语。</p>
</li>
<li><p>同位语从句：一句话解释一个宾语。</p>
</li>
</ul>
<p>The main problem <strong>people may encounter today</strong> arises from the <strong>fact</strong> that they have difficulty obtaining the needed information readily.</p>
<p>（判断句子个数，找谓语动词）</p>
<p>今天人们可能遇到的主要问题是他们很难轻易获得所需的信息。</p>
</body></html>]]></content>
      <categories>
        <category>考研类</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上好用的敲代码软件CodeRunner外加破解</title>
    <url>/2020/08/13/Mac%E4%B8%8A%E5%A5%BD%E7%94%A8%E7%9A%84%E6%95%B2%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6CodeRunner/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="Powerful-IDE-level-code-completion-for-most-languages"><a href="#Powerful-IDE-level-code-completion-for-most-languages" class="headerlink" title="Powerful IDE level code completion for most languages"></a>Powerful IDE level code completion for most languages</h1><h2 id="有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS-Code-，但是插件的下载与安装也是比较麻烦的。"><a href="#有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS-Code-，但是插件的下载与安装也是比较麻烦的。" class="headerlink" title="有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS Code ，但是插件的下载与安装也是比较麻烦的。"></a>有时候我们会一下子学好多语言，仅是用它写写算法而已。对于每一个语言都特意去下在一个IDE的话，无疑是件浪费时间和空间的事情，或许你可以用VS Code ，但是插件的下载与安装也是比较麻烦的。</h2><h2 id="我介绍一个万能IDE—————-gt-Code-Runner"><a href="#我介绍一个万能IDE—————-gt-Code-Runner" class="headerlink" title="我介绍一个万能IDE—————-> Code Runner"></a>我介绍一个万能IDE—————-> Code Runner</h2><p><a href="https://img-blog.csdnimg.cn/20200117085038328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200117085038328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a><br>他几乎支持的了所有语言，如果没有你想要的，你也可以手动添加。<br>他的界面如xcode一样，非常的美观，清楚。支持代码自动补全，同样也支持很多主题。</p>
<p>运行之后还会显示运行时间。。</p>
<h3 id="功能强大-仅有270多MB-是不是心动了呢"><a href="#功能强大-仅有270多MB-是不是心动了呢" class="headerlink" title="功能强大 仅有270多MB 是不是心动了呢?"></a>功能强大 仅有270多MB 是不是心动了呢?</h3><h1 id="然而"><a href="#然而" class="headerlink" title="然而"></a>然而</h1><p><a href="https://img-blog.csdnimg.cn/20200117085414258.png" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200117085414258.png" class="lazyload"></a><br>没错它是需要付费的。</p>
<h1 id="然而-1"><a href="#然而-1" class="headerlink" title="然而"></a>然而</h1><p>不废话—-</p>
<h2 id="1-直接登录官网下载"><a href="#1-直接登录官网下载" class="headerlink" title="1. 直接登录官网下载"></a>1. 直接登录官网下载</h2><h2 id="2-断网激活："><a href="#2-断网激活：" class="headerlink" title="2. 断网激活："></a>2. 断网激活：</h2><p>安装成功后，选择输入激活码。并断网。激活码网上都有，我就不找啦。几乎是随便一个就可以。成功后会有一个successfully</p>
<h2 id="3-修改hosts文件："><a href="#3-修改hosts文件：" class="headerlink" title="3. 修改hosts文件："></a>3. 修改hosts文件：</h2><p>打开<br>终端，开启root权限：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></tbody></table></figure></div>
<p>输入密码后，打开hosts文件位置：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /private/etc</span><br></pre></td></tr></tbody></table></figure></div>
<p>然后用vim打开 hosts文件：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">vim hosts</span><br></pre></td></tr></tbody></table></figure></div>
<p>进入此文件后，在后面加上一行</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">127.0.0.1       coderunnerapp.com</span><br></pre></td></tr></tbody></table></figure></div>
<p>然后保存退出。。。<br>（这块需要用到vim的一些简单操作，不会的话百度一下就OK，非常简单）<br>（注：修改成功以后他的官网就会进不去）</p>
<h3 id="重启coderunner-就可以使用啦。"><a href="#重启coderunner-就可以使用啦。" class="headerlink" title="重启coderunner 就可以使用啦。"></a>重启coderunner 就可以使用啦。</h3></body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 基础操作 + 配置文件设置 基础版 for mac</title>
    <url>/2020/07/04/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C+%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="vim-模式"><a href="#vim-模式" class="headerlink" title="vim 模式"></a>vim 模式</h2><h3 id="1-normal模式"><a href="#1-normal模式" class="headerlink" title="1.normal模式"></a>1.normal模式</h3><p>当我们用vim创建或者打开一个文件的时候，就是normal模式，然后我们可以输入一些指令，更加方便的操作文件。</p>
<h3 id="2-insert模式"><a href="#2-insert模式" class="headerlink" title="2.insert模式"></a>2.insert模式</h3><p>顾名思义就是可以进行编辑自己的文件内容了，从normal模式到insert模式有很多种快捷键，稍后一一说明。但是从insert模式到normal模式需要按esc键，没错，当我们常用到vim进行编辑的时候，会非常频繁的使用esc，但是他的位置却不是很让我们提高效率，在这里我们可以吧caps lock 修改为esc ，毕竟caps lock 真的没什么用，却处于一个非常方便的位置。</p>
<p>==具体修改可以看这篇博客，这里不再赘述==</p>
<p><a href="https://blog.csdn.net/VistorsYan/article/details/104036840" target="_blank" rel="noopener">Mac修改键盘之 将 caps lock修改为esc</a></p>
<h2 id="基本操作命令（增删改查-保存退出）"><a href="#基本操作命令（增删改查-保存退出）" class="headerlink" title="基本操作命令（增删改查+保存退出）"></a>基本操作命令（增删改查+保存退出）</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>在光标前写入</td>
</tr>
<tr>
<td>a</td>
<td>在光标后插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标所在行下一行插入一新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标所在行上一行插入一新行</td>
</tr>
<tr>
<td>shift+i</td>
<td>行前插入</td>
</tr>
<tr>
<td>shift + a</td>
<td>行尾插入</td>
</tr>
<tr>
<td>h j k l</td>
<td>光标移动：←↓↑→   上下左右键也可移动</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除当前光标所在的字符</td>
</tr>
<tr>
<td>:wq然后回车</td>
<td>保存并退出</td>
</tr>
<tr>
<td>dd</td>
<td>剪切当前行</td>
</tr>
<tr>
<td>p/P</td>
<td>粘贴 前者是在光标之前，后者是在光标之后</td>
</tr>
<tr>
<td>yy</td>
<td>拷贝当前行</td>
</tr>
<tr>
<td>/+要输入的字符串</td>
<td>在文本中查找改字符串</td>
</tr>
</tbody>
</table>
</div>
<h1 id="配置文件设置"><a href="#配置文件设置" class="headerlink" title="配置文件设置"></a>配置文件设置</h1><h2 id="创建vim配置文件"><a href="#创建vim配置文件" class="headerlink" title="创建vim配置文件"></a>创建vim配置文件</h2><h3 id="在根目录下找到-vim文件夹并打开"><a href="#在根目录下找到-vim文件夹并打开" class="headerlink" title="在根目录下找到 .vim文件夹并打开"></a>在根目录下找到 .vim文件夹并打开</h3><p>注：如果没有就新建一个.vim文件夹并打开即可。<br></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"><span class="built_in">cd</span> .vim</span><br></pre></td></tr></tbody></table></figure></div><p></p>
<h3 id="然后-在当前路径下："><a href="#然后-在当前路径下：" class="headerlink" title="然后 在当前路径下："></a>然后 在当前路径下：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">vim vimrc</span><br></pre></td></tr></tbody></table></figure></div>
<p>这样就有打开了一个新的文件，这就是配置文件，你可以在这里进行“肆意的”修改</p>
<h2 id="键位修改"><a href="#键位修改" class="headerlink" title="键位修改"></a>键位修改</h2><p>有时vim的一些快捷键很不合你的口味，比如方向键，所以可以把方向键的位置改为符合方向的键。</p>
<h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>我想把h 键改为 i：（直接在vimrc里面写）<br></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">noremap i h</span><br></pre></td></tr></tbody></table></figure></div><br>此时i键有着和h一样的功能，但是i键本来是有功能的（插入），因此==切记==不要忘了把i给改为别的键，如果你还想用这个功能的话。<p></p>
<h2 id="指令快捷化"><a href="#指令快捷化" class="headerlink" title="指令快捷化"></a>指令快捷化</h2><p>vim 保存命令是在normal模式下输入 :w 然后回车，虽然很方便了，但是可以更快：<br></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> S :<span class="keyword">w</span><span class="symbol"><cr></cr></span></span><br></pre></td></tr></tbody></table></figure></div><br>现在直接用S即可保存，（w后的不用我说也清楚是回车的意思）<br>以此类推：举几个常用的例子<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> s <span class="symbol"><nop></nop></span></span><br></pre></td></tr></tbody></table></figure></div><br>nop(no operation) ==取消s的功能==<p></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> Q :q<span class="symbol"><cr></cr></span></span><br></pre></td></tr></tbody></table></figure></div>
<p>退出<br></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> R :<span class="keyword">source</span> $MYVIMRC<span class="symbol"><cr></cr></span></span><br></pre></td></tr></tbody></table></figure></div><br>刷新（应用的意思）<br>注：这些都需要保存退出以后才能生效，如果刷新，即刻生效<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">synatx <span class="keyword">on</span></span><br></pre></td></tr></tbody></table></figure></div><br>代码高亮<p></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="keyword">set</span> cursorline</span><br><span class="line"><span class="keyword">set</span> wrap</span><br><span class="line"><span class="keyword">set</span> wildmenu</span><br></pre></td></tr></tbody></table></figure></div>
<p>打开行号<br>添加下划线<br>如果该行已满 自动换行<br>命令自动补全 tab 同bash</p>
<h4 id="有关查找的指令"><a href="#有关查找的指令" class="headerlink" title="有关查找的指令"></a>有关查找的指令</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hlsearch</span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line">exec <span class="string">"nohlsearch"</span></span><br><span class="line"><span class="keyword">set</span> ignorecase</span><br><span class="line"><span class="keyword">set</span> smartcase</span><br></pre></td></tr></tbody></table></figure></div>
<p>查找时高亮显示<br>边输入边高亮<br>当再次进入文件时不显示高亮，否则还会显示上次查找的高亮<br>忽视高亮<br>忽略大小写<br>智能大小写</p>
<p>==注：查找完后会依然显示高亮，去除高亮的命令是==</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vim</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">:<span class="keyword">nohlsearch</span><span class="symbol"><cr></cr></span></span><br></pre></td></tr></tbody></table></figure></div>
<p>可以根据自己的意愿，按上边的方式修改一下快捷键去除查找后的高亮</p>
<p>以上仅提供了一些基础常用的设置，还不是全部。。。。<br>有什么更好的指令欢迎下方留言，嘻嘻😬</p>
</body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Datagrip的基本使用方法。</title>
    <url>/2020/04/18/Datagrip%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="Datagrip-的基本使用方法"><a href="#Datagrip-的基本使用方法" class="headerlink" title="Datagrip 的基本使用方法"></a>Datagrip 的基本使用方法</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​    我使用的是MySQL，并安装成功且可以正常使用，这里不再介绍如何安装，有需求的可以自行百度。。😬</p>
<h2 id="1-新建MySQL"><a href="#1-新建MySQL" class="headerlink" title="1.新建MySQL"></a>1.新建MySQL</h2><ul>
<li>按如下图示操作，选中MySQL选项：</li>
</ul>
<p><a href="https://i.loli.net/2020/04/18/tkmlcHWUQO7wZdV.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/04/18/tkmlcHWUQO7wZdV.png" class="lazyload"></a></p>
<ul>
<li>在安装MySQL会注册自己的User和Password，填在下方：</li>
</ul>
<p><a href="https://i.loli.net/2020/04/18/IfCoDwKLeXl2kjy.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/04/18/IfCoDwKLeXl2kjy.png" class="lazyload"></a></p>
<p>之后就会在左侧栏中出现了</p>
<h2 id="2-建立数据库"><a href="#2-建立数据库" class="headerlink" title="2.建立数据库"></a>2.建立数据库</h2><ul>
<li>如下图操作，选择后，创建名字即可</li>
</ul>
<p><a href="https://i.loli.net/2020/04/18/r6EG2AqNHSXwUxg.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/04/18/r6EG2AqNHSXwUxg.png" class="lazyload"></a></p>
<h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><ul>
<li><p>在你新建的数据库下，右击选择 new 选择 table ： </p>
<p><a href="https://i.loli.net/2020/04/18/ehHfkmrxVDnaFQZ.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/04/18/ehHfkmrxVDnaFQZ.png" class="lazyload"></a></p>
</li>
</ul>
<p>第一个为表的名字，第二项是备注，下面加号可以手动添加表格内列名，也可以设置主键和特征，下面对应生成SQL语句。</p>
<h2 id="4-使用查询分析器"><a href="#4-使用查询分析器" class="headerlink" title="4. 使用查询分析器"></a>4. 使用查询分析器</h2><p>右击数据库，选择 Jump to Console ,选择当下MySQL的Console即可。就可以在上面书写SQL语句了。</p>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>sql数据查询之---嵌套查询</title>
    <url>/2020/04/02/sql%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2---%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="sql数据查询之———嵌套查询"><a href="#sql数据查询之———嵌套查询" class="headerlink" title="sql数据查询之———嵌套查询"></a>sql数据查询之———嵌套查询</h1><h2 id="一、嵌套查询概述"><a href="#一、嵌套查询概述" class="headerlink" title="一、嵌套查询概述"></a>一、嵌套查询概述</h2><ul>
<li>一个 SELECT-FROM-WHERE 语句称为一个查询块。</li>
<li>将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为 嵌套查询。</li>
</ul>
<p>例如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname	                           <span class="comment">/*外层查询/父查询*/</span></span><br><span class="line">     <span class="keyword">FROM</span> Student</span><br><span class="line">     <span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">                        ( <span class="keyword">SELECT</span> Sno        <span class="comment">/*内层查询/子查询*/</span></span><br><span class="line">                          <span class="keyword">FROM</span> SC</span><br><span class="line">                          <span class="keyword">WHERE</span> Cno= <span class="string">' 2 '</span>);</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>注意：子查询的SELECT语句中不能使用 ORDER BY 子句，因为 ORDER BY 子句只能对最终查询结果排序。</strong></p>
<ul>
<li>不相关子查询：<strong>子查询的查询条件不依赖于父查询</strong></li>
<li>相关子查询：<strong>子查询的查询条件依赖于父查询</strong></li>
</ul>
<p>（后续在对二者详细解释）</p>
<h2 id="二、嵌套查询"><a href="#二、嵌套查询" class="headerlink" title="二、嵌套查询"></a>二、嵌套查询</h2><h3 id="1-带有in谓词的子查询"><a href="#1-带有in谓词的子查询" class="headerlink" title="1.带有in谓词的子查询"></a>1.带有in谓词的子查询</h3><h4 id="例1：查询与“刘晨”在同一个系学习的学生。"><a href="#例1：查询与“刘晨”在同一个系学习的学生。" class="headerlink" title="例1：查询与“刘晨”在同一个系学习的学生。"></a>例1：<strong>查询与“刘晨”在同一个系学习的学生。</strong></h4><p>分部完成：</p>
<p><strong>①</strong> 确定“刘晨”所在系名</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Sdept  </span><br><span class="line">         <span class="keyword">FROM</span>     Student                            </span><br><span class="line">         <span class="keyword">WHERE</span>  Sname= <span class="string">' 刘晨 '</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<p>假设结果为CS</p>
<p><strong>②</strong> 查找所有在CS系学习的学生。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   Sno, Sname, Sdept     </span><br><span class="line">        <span class="keyword">FROM</span>      Student                 </span><br><span class="line">        <span class="keyword">WHERE</span>   Sdept= <span class="string">' CS '</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<p>第一部就是子查询，第二步为父查询</p>
<p>那么可以写成：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Sdept</span><br><span class="line">    	<span class="keyword">FROM</span> Student</span><br><span class="line">   	<span class="keyword">WHERE</span> Sdept  <span class="keyword">IN</span></span><br><span class="line">                  (<span class="keyword">SELECT</span> Sdept</span><br><span class="line">                   <span class="keyword">FROM</span> Student</span><br><span class="line">                   <span class="keyword">WHERE</span> Sname= <span class="string">' 刘晨 '</span>);</span><br></pre></td></tr></tbody></table></figure></div>
<p>注：这是不相关查询，即子查询条件与父查询条件无关</p>
<h4 id="例2：查询选修了课程名为“信息系统”的学生学号和姓名"><a href="#例2：查询选修了课程名为“信息系统”的学生学号和姓名" class="headerlink" title="例2：查询选修了课程名为“信息系统”的学生学号和姓名"></a>例2：<strong>查询选修了课程名为“信息系统”的学生学号和姓名</strong></h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname                 ③ 最后在Student关系中</span><br><span class="line">  	<span class="keyword">FROM</span>    Student                          取出Sno和Sname</span><br><span class="line"> 	<span class="keyword">WHERE</span> Sno  <span class="keyword">IN</span></span><br><span class="line">             (<span class="keyword">SELECT</span> Sno                     ② 然后在SC关系中找出选</span><br><span class="line">              <span class="keyword">FROM</span>    SC                         修了<span class="number">3</span>号课程的学生学号</span><br><span class="line">              <span class="keyword">WHERE</span>  Cno <span class="keyword">IN</span></span><br><span class="line">                     (<span class="keyword">SELECT</span> Cno             ① 首先在Course关系中找出</span><br><span class="line">                       <span class="keyword">FROM</span> Course           “信息系统”的课程号，为<span class="number">3</span>号</span><br><span class="line">                       <span class="keyword">WHERE</span> Cname= <span class="string">'信息系统'</span>                      </span><br><span class="line">		          )</span><br><span class="line">        );</span><br></pre></td></tr></tbody></table></figure></div>
<p>当然也可以用连接查询实现:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname</span><br><span class="line"><span class="keyword">FROM</span> Student,SC,Course</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno=SC.Sno <span class="keyword">AND</span></span><br><span class="line">    SC.Cno=Course.Cno <span class="keyword">AND</span></span><br><span class="line">    Course.Cname=<span class="string">'信息系统'</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<h3 id="2-带有比较运算符的子查询"><a href="#2-带有比较运算符的子查询" class="headerlink" title="2.带有比较运算符的子查询"></a>2.<strong>带有比较运算符的子查询</strong></h3><p>当能确切知道内层查询返回单值时，可用比较运算符（>，<，=，>=，<=，!=或< >）。</p>
<p>对于第一个例子来说，由于一个学生只可能在一个系里学习，所以可以用 = 代替 in</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Sdept</span><br><span class="line">    	<span class="keyword">FROM</span> Student</span><br><span class="line">   	<span class="keyword">WHERE</span> Sdept  =</span><br><span class="line">                  (<span class="keyword">SELECT</span> Sdept</span><br><span class="line">                   <span class="keyword">FROM</span> Student</span><br><span class="line">                   <span class="keyword">WHERE</span> Sname= <span class="string">' 刘晨 '</span>);</span><br></pre></td></tr></tbody></table></figure></div>
<h3 id="3-带有ANY-SOME-或ALL谓词的子查询"><a href="#3-带有ANY-SOME-或ALL谓词的子查询" class="headerlink" title="3.带有ANY(SOME)或ALL谓词的子查询"></a>3.带有ANY(SOME)或ALL谓词的子查询</h3><p><strong>子查询返回单值时可以用比较运算符，但返回多值时要用ANY（有的系统用SOME）或ALL谓词修饰符。而使用ANY或ALL谓词时则必须同时使用比较运算符。</strong>其语义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>>ANY</th>
<th>大于子查询结果中的某个值</th>
</tr>
</thead>
<tbody>
<tr>
<td>>ALL</td>
<td>大于子查询结果中的所有值</td>
</tr>
<tr>
<td><any< td>
</any<></td><td>小于子查询结果中的某个值</td>
</tr>
<tr>
<td><all< td>
</all<></td><td>小于子查询结果中的所有值</td>
</tr>
<tr>
<td>>=ANY</td>
<td>大于等于子查询结果中的某个值</td>
</tr>
<tr>
<td>>=ALL</td>
<td>大于等于子查询结果中的所有值</td>
</tr>
<tr>
<td><=ALL</td>
<td>小于等于子查询结果中的所有值</td>
</tr>
<tr>
<td><=ANY</td>
<td>大于等于子查询结果中的某个值</td>
</tr>
<tr>
<td>=ANY</td>
<td>等于子查询结果中的某个值</td>
</tr>
<tr>
<td>=ALL</td>
<td>等于子查询结果中的所有值（通常没有实际意义）</td>
</tr>
<tr>
<td>!=（或<>）ANY</td>
<td>不等于子查询结果中的某个值</td>
</tr>
<tr>
<td>!=（或<>）ALL</td>
<td>不等于子查询结果中的任何一个值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="例1：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄"><a href="#例1：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄" class="headerlink" title="例1：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄"></a>例1：<strong>查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</strong></h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<<span class="keyword">ANY</span> (<span class="keyword">SELECT</span> Sage</span><br><span class="line">                <span class="keyword">FROM</span> Student</span><br><span class="line">                <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept <> <span class="string">'CS'</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<h4 id="例2：查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄"><a href="#例2：查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄" class="headerlink" title="例2：查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄"></a>例2：查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<<span class="keyword">ALL</span></span><br><span class="line">          (<span class="keyword">SELECT</span> Sage</span><br><span class="line">           <span class="keyword">FROM</span> Student</span><br><span class="line">           <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept <> <span class="string">'CS'</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<p>提示：本查询同样可以用<strong>聚集函数</strong>实现</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(Sage)</span><br><span class="line">     <span class="keyword">FROM</span> Student</span><br><span class="line">     <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept <><span class="string">'CS'</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://i.loli.net/2020/04/02/pa3jZ8t5SCVIAHy.png" data-fancybox="group" data-caption="截屏2020-04-02下午9.25.09.png" class="fancybox"><img alt="截屏2020-04-02下午9.25.09.png" title="截屏2020-04-02下午9.25.09.png" data-src="https://i.loli.net/2020/04/02/pa3jZ8t5SCVIAHy.png" class="lazyload"></a></p>
<h3 id="4-带有EXISTS谓词的子查询"><a href="#4-带有EXISTS谓词的子查询" class="headerlink" title="4.带有EXISTS谓词的子查询"></a>4.带有EXISTS谓词的子查询</h3><p><strong>带有EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。</strong></p>
<h4 id="例1：-查询所有选修了1号课程的学生姓名"><a href="#例1：-查询所有选修了1号课程的学生姓名" class="headerlink" title="例1： 查询所有选修了1号课程的学生姓名"></a>例1： 查询所有选修了1号课程的学生姓名</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> *</span><br><span class="line">     <span class="keyword">FROM</span> SC</span><br><span class="line">     <span class="keyword">WHERE</span> Sno=Student.Sno <span class="keyword">AND</span> Cno=<span class="string">'1'</span>);</span><br></pre></td></tr></tbody></table></figure></div>
<ul>
<li><strong>本查询涉及Student和SC关系</strong></li>
<li><strong>在Student中依次取每个元组的Sno值，用此值去检查SC表</strong></li>
<li><strong>若SC中存在这样的元组，其Sno值等于此Student.Sno值，并且其Cno= ‘1’，则取此Student.Sname送入结果表</strong></li>
</ul>
<h4 id="例2：查询没有选修1号课程的学生姓名"><a href="#例2：查询没有选修1号课程的学生姓名" class="headerlink" title="例2：查询没有选修1号课程的学生姓名"></a>例2：查询没有选修1号课程的学生姓名</h4><p>直接在<strong>EXISTS</strong>前加<strong>NOT</strong></p>
<p><strong>重难点</strong>：</p>
<h4 id="例3：查询选修了全部课程的学生姓名"><a href="#例3：查询选修了全部课程的学生姓名" class="headerlink" title="例3：查询选修了全部课程的学生姓名"></a>例3：查询选修了全部课程的学生姓名</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> *</span><br><span class="line">     <span class="keyword">FROM</span> Course</span><br><span class="line">     <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> *</span><br><span class="line">         <span class="keyword">FROM</span> SC</span><br><span class="line">         <span class="keyword">WHERE</span> Sno=Student.Sno</span><br><span class="line">            <span class="keyword">AND</span> Cno=Course.Cno));</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>用EXISTS/NOT EXISTS实现全称量词（难点）</strong></p>
<ul>
<li>SQL语言中没有全称量词$\forall$（For all）</li>
<li>可以把带有全称量词的谓词转换为等价的带有存在量词的谓词：$ (\forall x)P = ﹁(\exist x(﹁P))$</li>
</ul>
<h4 id="例4-：查询至少选修了学生201215122选修的全部课程的学生号码"><a href="#例4-：查询至少选修了学生201215122选修的全部课程的学生号码" class="headerlink" title="例4 ：查询至少选修了学生201215122选修的全部课程的学生号码"></a>例4 ：查询至少选修了学生201215122选修的全部课程的学生号码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC SCX</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> *</span><br><span class="line">     <span class="keyword">FROM</span> SC SCY</span><br><span class="line">     <span class="keyword">WHERE</span> SCY.Sno=<span class="string">'201215122'</span> <span class="keyword">AND</span></span><br><span class="line">        <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> *</span><br><span class="line">         <span class="keyword">FROM</span> SC SCZ</span><br><span class="line">         <span class="keyword">WHERE</span> SCZ.Sno=SCX.Sno <span class="keyword">AND</span></span><br><span class="line">         SCZ.Cno=SCY.Cno));</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><strong>不同形式的查询间的替换</strong></p>
<p>一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换</p>
<p>所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带<strong>EXISTS</strong>谓词的子查询等价替换</p>
</body></html>]]></content>
      <categories>
        <category>上课笔记</category>
      </categories>
      <tags>
        <tag>上课笔记</tag>
        <tag>sql语句</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法，由浅入深，最全攻略，笔记。</title>
    <url>/2020/02/24/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="一、markdown简介"><a href="#一、markdown简介" class="headerlink" title="一、markdown简介"></a>一、markdown简介</h1><p>（注：如果对markdown有一定了解。可以略过此处，第一章主要对markdown基础知识做个补充,摘自菜鸟教程<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">此处原文档</a> ）</p>
<h2 id="1-1-markdown背景"><a href="#1-1-markdown背景" class="headerlink" title="1.1 markdown背景"></a>1.1 markdown背景</h2><h3 id="1-markdown是一种轻量级标记语言，她与徐人们使用易读易写的纯文本格式编写文档。"><a href="#1-markdown是一种轻量级标记语言，她与徐人们使用易读易写的纯文本格式编写文档。" class="headerlink" title="1. markdown是一种轻量级标记语言，她与徐人们使用易读易写的纯文本格式编写文档。"></a>1. markdown是一种轻量级标记语言，她与徐人们使用易读易写的纯文本格式编写文档。</h3><h3 id="2-Markdown-语言在-2004-由约翰·格鲁伯（英语：John-Gruber）创建。"><a href="#2-Markdown-语言在-2004-由约翰·格鲁伯（英语：John-Gruber）创建。" class="headerlink" title="2. Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。"></a>2. Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</h3><h3 id="3-Markdown-编写的文档可以导出-HTML-、Word、图像、PDF、Epub-等多种格式的文档。"><a href="#3-Markdown-编写的文档可以导出-HTML-、Word、图像、PDF、Epub-等多种格式的文档。" class="headerlink" title="3. Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。"></a>3. Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</h3><h3 id="4-Markdown-编写的文档后缀为-md-markdown。"><a href="#4-Markdown-编写的文档后缀为-md-markdown。" class="headerlink" title="4. Markdown 编写的文档后缀为 .md, .markdown。"></a>4. Markdown 编写的文档后缀为 .md, .markdown。</h3><h2 id="1-2-markdown应用"><a href="#1-2-markdown应用" class="headerlink" title="1.2 markdown应用"></a>1.2 markdown应用</h2><h3 id="Markdown-能被使用来撰写电子书，如：Gitbook。"><a href="#Markdown-能被使用来撰写电子书，如：Gitbook。" class="headerlink" title="Markdown 能被使用来撰写电子书，如：Gitbook。"></a>Markdown 能被使用来撰写电子书，如：Gitbook。</h3><h3 id="当前许多网站都广泛使用-Markdown-来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack-Exchange、OpenStreetMap-、SourceForge等。"><a href="#当前许多网站都广泛使用-Markdown-来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack-Exchange、OpenStreetMap-、SourceForge等。" class="headerlink" title="当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。"></a>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</h3><h2 id="1-3-编辑器"><a href="#1-3-编辑器" class="headerlink" title="1.3 编辑器"></a>1.3 编辑器</h2><h3 id="编辑器有很多种，基本各大编辑器都可以编辑markdown格式文档。"><a href="#编辑器有很多种，基本各大编辑器都可以编辑markdown格式文档。" class="headerlink" title="编辑器有很多种，基本各大编辑器都可以编辑markdown格式文档。"></a>编辑器有很多种，基本各大编辑器都可以编辑markdown格式文档。</h3><h3 id="比如：Typora，sublime-Text-coderunner-印象笔记，vim等等等。具体的可以百度，都非常好用。"><a href="#比如：Typora，sublime-Text-coderunner-印象笔记，vim等等等。具体的可以百度，都非常好用。" class="headerlink" title="比如：Typora，sublime Text, coderunner,印象笔记，vim等等等。具体的可以百度，都非常好用。"></a>比如：Typora，sublime Text, coderunner,印象笔记，vim等等等。具体的可以百度，都非常好用。</h3><hr>
<h1 id="二、markdown基本操作"><a href="#二、markdown基本操作" class="headerlink" title="二、markdown基本操作"></a>二、markdown基本操作</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>使用#号标记，可以表示1-6级标题，随#个数递增。如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></tbody></table></figure></div>
<p>注：最后一个#与文字间一定要有一个空格。</p>
<p>显示效果：</p>
<p><a href="https://i.loli.net/2020/02/17/wIWVKahMtmTLu4n.png" data-fancybox="group" data-caption="显示效果" class="fancybox"><img alt="显示效果" title="显示效果" data-src="https://i.loli.net/2020/02/17/wIWVKahMtmTLu4n.png" class="lazyload"></a></p>
<h2 id="2-换行"><a href="#2-换行" class="headerlink" title="2.换行"></a>2.换行</h2><p>markdown换行方式有很多种</p>
<ul>
<li>直接在一句话后面敲两个空格</li>
<li>两句话之间加一个空行</li>
<li>如果你在编辑的时候，想让一行文字分成几段在显示的时候换行，就在中间加</li>
</ul>
<p><a href="https://i.loli.net/2020/02/18/UrtqpfeOPlDW5VT.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/02/18/UrtqpfeOPlDW5VT.png" class="lazyload"></a></p>
<p>此点是我想在表格里换行时get到的，也很实用,后面讲到表格我会展示。</p>
<h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h2><p>markdown支持几种字体：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">***粗斜体文本**</span>*</span><br><span class="line"><span class="strong">___粗斜体文本__</span>_</span><br></pre></td></tr></tbody></table></figure></div>
<p>把你想修改的字段直接放在中间即可。显示效果如下：</p>
<p><a href="https://i.loli.net/2020/02/18/JNMP7tG4KdXaxoj.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/02/18/JNMP7tG4KdXaxoj.png" class="lazyload"></a></p>
<h2 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h2><p>markdown中分割线，能是你的文章结构更加清楚</p>
<p>几种分割线的写法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span><span class="emphasis">* *</span></span><br><span class="line"></span><br><span class="line"><span class="strong">*****</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>- -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></tbody></table></figure></div>
<p>这些都可以是分割线。如果你在你自己的博客网站加上美化，他可以看着更舒服哈哈哈。</p>
<h2 id="5-删除线，下划线。"><a href="#5-删除线，下划线。" class="headerlink" title="5.删除线，下划线。"></a>5.删除线，下划线。</h2><p>写法如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">~~删除线~~</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag"><<span class="name">u</span>></span></span>下划线<span class="xml"><span class="tag"><!--<span class="name"-->u</span>></span></span><br></pre></td></tr></tbody></table></figure></div>
<p>显示效果：</p>
<p><a href="https://i.loli.net/2020/02/18/O5K2AyjdYMRsLqN.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/02/18/O5K2AyjdYMRsLqN.png" class="lazyload"></a></p>
<h2 id="6-分点条列"><a href="#6-分点条列" class="headerlink" title="6.分点条列"></a>6.分点条列</h2><ol>
<li>无序</li>
</ol>
<p>markdown可以通过 * - + 开头作为列表标记。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">* </span>第一行</span><br><span class="line"><span class="bullet">* </span>第二行</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一行</span><br><span class="line"><span class="bullet">- </span>第二行</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>第一行</span><br><span class="line"><span class="bullet">+ </span>第二行</span><br></pre></td></tr></tbody></table></figure></div>
<p>显示效果：</p>
<p><a href="https://i.loli.net/2020/02/18/e6z4iBGOrKhySF1.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/02/18/e6z4iBGOrKhySF1.png" class="lazyload"></a></p>
<ol>
<li>有序</li>
</ol>
<p>有序的直接数字后面跟着一个点就可以了，和咱们平时写的一样。</p>
<ol>
<li>嵌套使用</li>
</ol>
<p>有序无序也可以嵌套使用 如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.第一行</span><br><span class="line"><span class="bullet">  - </span>第一点</span><br><span class="line"><span class="bullet">  - </span>第二点</span><br></pre></td></tr></tbody></table></figure></div>
<p>效果：</p>
<p><a href="https://i.loli.net/2020/02/18/wg6JV1rRxzoEvAi.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/02/18/wg6JV1rRxzoEvAi.png" class="lazyload"></a></p>
<h2 id="7-区块"><a href="#7-区块" class="headerlink" title="7.区块"></a>7.区块</h2><p>markdown区块是在段落开头使用 “>”，依然是紧跟空格</p>
<p>写法如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="quote">> markdown</span></span><br><span class="line"><span class="quote">> 基础</span></span><br><span class="line"><span class="quote">> 区块引用</span></span><br></pre></td></tr></tbody></table></figure></div>
<p>效果：</p>
<blockquote>
<p>markdown<br>基础<br>区块引用</p>
</blockquote>
<ol>
<li>区块嵌套</li>
</ol>
<p>通过”>” 个数展示分层差别：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="quote">> markdown</span></span><br><span class="line">>> 基础</span><br><span class="line">>>> 区块引用</span><br></pre></td></tr></tbody></table></figure></div>
<p>效果：</p>
<blockquote>
<p>markdown</p>
<blockquote>
<p>基础</p>
<blockquote>
<p>区块引用</p>
</blockquote>
</blockquote>
</blockquote>
<ol>
<li>区块中使用列表</li>
</ol>
<p>实例如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="quote">> 区块中使用列表</span></span><br><span class="line"><span class="quote">> 1. 第一项</span></span><br><span class="line"><span class="quote">> 2. 第二项</span></span><br><span class="line">>> + 第一项</span><br><span class="line">>> + 第二项</span><br><span class="line">>> + 第三项</span><br></pre></td></tr></tbody></table></figure></div>
<p>效果：</p>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项<blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>
<p>注：在列表中使用区块是同样的道理，这里不再赘述。</p>
<hr>
<h1 id="三、markdown进阶"><a href="#三、markdown进阶" class="headerlink" title="三、markdown进阶"></a>三、markdown进阶</h1><h2 id="1-markdown-插入代码"><a href="#1-markdown-插入代码" class="headerlink" title="1. markdown 插入代码"></a>1. markdown 插入代码</h2><ul>
<li>插入一行代码</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">`int a = 0;`//英文版的数字1左边的那个符号。。。。</span><br></pre></td></tr></tbody></table></figure></div>
<p>效果：</p>
<p><code>int a = 0;</code></p>
<ul>
<li>插入代码块</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">​```紧跟着可以写上用的什么语言，也可以不用写。</span><br><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line"></span><br><span class="line">​```结尾与开头一样</span><br></pre></td></tr></tbody></table></figure></div>
<p>效果：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="2-markdown插入链接"><a href="#2-markdown插入链接" class="headerlink" title="2.markdown插入链接"></a>2.markdown插入链接</h2><p>链接语法如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><链接地址></span><br></pre></td></tr></tbody></table></figure></div>
<p>注意：符号全英文</p>
<p>比如：</p>
<p><code>[这是百度](https://www.baidu.com)</code></p>
<p>效果：</p>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">这是百度</a></p>
<p>记着点完返回阿，或者新建页面打开，嘿嘿嘿</p>
<h2 id="3-markdown插入图片"><a href="#3-markdown插入图片" class="headerlink" title="3.markdown插入图片"></a>3.markdown插入图片</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">![图片描述，可写可不写，但是中括号要有](图片地址，本地链接或者URL地址。)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">比如我此文章的图片：</span><br><span class="line"></span><br><span class="line">![markdown](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1613194509,3683268681&fm=26&gp=0.jpg)</span><br></pre></td></tr></tbody></table></figure></div>
<p>最后会显示出来，我就不做效果拉。</p>
<h2 id="4-markdown表格"><a href="#4-markdown表格" class="headerlink" title="4. markdown表格"></a>4. markdown表格</h2><p>每排单元格要用<kbd> |</kbd> 分开 表头与内容用 <kbd>—-</kbd> 分开</p>
<p>语法如下</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">markdown</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">|  表头   | 表头  | 表头 | 表头 |</span><br><span class="line">| :---  | ---:  | :--: | ---- |</span><br><span class="line">| 单元格  | 单元格 |单元格|单元格|</span><br><span class="line">| 单元格  | 单元格 |单元格|单元格|</span><br></pre></td></tr></tbody></table></figure></div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表头</th>
<th style="text-align:right">表头</th>
<th style="text-align:center">表头</th>
<th>表头</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
<td>单元格</td>
</tr>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
<td>单元格</td>
</tr>
</tbody>
</table>
</div>
<p>加<kbd>:</kbd>可以实现左对齐，右对齐，居中。不加则默认为左对齐</p>
<h2 id="5-markdown支持HTML元素"><a href="#5-markdown支持HTML元素" class="headerlink" title="5.markdown支持HTML元素"></a>5.markdown支持HTML元素</h2><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：</sub></sup></em></i></b></kbd></p><b><i><em>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://i.loli.net/2020/02/24/miegMwcH8aDWYtu.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://i.loli.net/2020/02/24/miegMwcH8aDWYtu.png" class="lazyload"></a></p>
</em></i></b></body></html>]]></content>
      <categories>
        <category>上课笔记</category>
      </categories>
      <tags>
        <tag>上课笔记</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>word中如何加入带√的□ ?</title>
    <url>/2020/02/12/word%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8A%A0%E5%85%A5%E5%B8%A6%E2%88%9A%E7%9A%84%E5%B0%8F%E6%96%B9%E5%9D%97/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="打出有勾的方括号"><a href="#打出有勾的方括号" class="headerlink" title="打出有勾的方括号"></a>打出有勾的方括号</h2><p>输入一个大写R，之后选中，把字体改为：wingdings 2 就OK了，然后自己试了试在这个字体下输入了一些别的字，发现有许多图形，还很不错。</p>
<hr>
<p>于是就百度了一下对照表</p>
<h2 id="如下："><a href="#如下：" class="headerlink" title="如下："></a>如下：</h2><p><a href="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1176238582,3363171188&fm=26&gp=0.jpg" data-fancybox="group" data-caption="对照表" class="fancybox"><img alt="对照表" title="对照表" data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1176238582,3363171188&fm=26&gp=0.jpg" class="lazyload"></a></p>
<p>在这个字体下，对应输入，就会有这么些不同的图标，不错不错，长知识。</p>
</body></html>]]></content>
      <categories>
        <category>Microsoft技能</category>
      </categories>
      <tags>
        <tag>word技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>UIKit与swiftUI 交互</title>
    <url>/2020/02/09/swiftui%E4%B8%8Euikit%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="UIKit与swiftUI-交互"><a href="#UIKit与swiftUI-交互" class="headerlink" title="UIKit与swiftUI 交互"></a>UIKit与swiftUI 交互</h1><p>运用swiftUI写界面非常迅速且酷炫。大大减少了曾经在UIKit中的代码量。<br>不过有时候可能你还会需要用到UIKit，但是你又想用swiftUI做界面，此时就考虑到二者交互的问题了。</p>
<h2 id="UIViewControllerRepresentable"><a href="#UIViewControllerRepresentable" class="headerlink" title="UIViewControllerRepresentable"></a>UIViewControllerRepresentable</h2><p><strong>在swiftUI中提供了一个UIViewControllerRepresentable协议</strong><br><strong>我们可以用它作为UIKit 与swiftUI的桥接</strong><br><a href="https://img-blog.csdnimg.cn/20200113121716232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200113121716232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h1 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h1><h2 id="你依然可以像往常一样，新建一个swift文件，把他命名为viewController-然后导入UiKit-，然后再让它继承UIViewController-重写父类的viewDidLoad-方法，你也可以往里面随便添点东西，为后面验证做准备，just-like-this"><a href="#你依然可以像往常一样，新建一个swift文件，把他命名为viewController-然后导入UiKit-，然后再让它继承UIViewController-重写父类的viewDidLoad-方法，你也可以往里面随便添点东西，为后面验证做准备，just-like-this" class="headerlink" title="你依然可以像往常一样，新建一个swift文件，把他命名为viewController 然后导入UiKit ，然后再让它继承UIViewController 重写父类的viewDidLoad()方法，你也可以往里面随便添点东西，为后面验证做准备，just like this.."></a>你依然可以像往常一样，新建一个swift文件，把他命名为viewController 然后导入UiKit ，然后再让它继承UIViewController 重写父类的viewDidLoad()方法，你也可以往里面随便添点东西，为后面验证做准备，just like this..<a href="https://img-blog.csdnimg.cn/20200113122152672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200113122152672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></h2><h1 id="第二步-桥接"><a href="#第二步-桥接" class="headerlink" title="第二步 桥接"></a>第二步 桥接</h1><h2 id="第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController-他需要遵循并实现UIViewControllerRepresentable这个协议"><a href="#第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController-他需要遵循并实现UIViewControllerRepresentable这个协议" class="headerlink" title="第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController 他需要遵循并实现UIViewControllerRepresentable这个协议"></a>第二步就是在你的swiftUI文件中写一个结构体连接你刚创建的viewController 他需要遵循并实现UIViewControllerRepresentable这个协议</h2><h1 id="第三步-应用"><a href="#第三步-应用" class="headerlink" title="第三步 应用"></a>第三步 应用</h1><h2 id="接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了"><a href="#接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了" class="headerlink" title="接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了"></a>接下来直接在你swiftUI中结构体中调用第二步的结构体就OK了<a href="https://img-blog.csdnimg.cn/20200113125213490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="第二步与第三步" class="fancybox"><img alt="第二步与第三步" title="第二步与第三步" data-src="https://img-blog.csdnimg.cn/20200113125213490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></h2><h1 id="显示效果如图"><a href="#显示效果如图" class="headerlink" title="显示效果如图"></a>显示效果如图</h1><p><a href="https://img-blog.csdnimg.cn/20200113130421611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200113130421611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h1 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h1><p>viewController.swift 文件中：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">viewController</span>: <span class="title">UIViewController</span></span>{</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = .brown</span><br><span class="line">        <span class="keyword">let</span> viewDemo = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">        viewDemo.backgroundColor = .green</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(viewDemo)</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>ConventView.swift 文件中</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//UIKit 桥接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UIBridging</span>: <span class="title">UIViewControllerRepresentable</span> </span>{</span><br><span class="line">    <span class="comment">//这个UIViewControllerType你要接哪个就是哪个，在这里就是viewController</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">UIViewControllerType</span> = viewController</span><br><span class="line">    <span class="comment">//必须实现的方法，当swiftUI要显示view时，会调用这个方法。返回值就是当前需要显示的类</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIViewController</span><span class="params">(context: UIViewControllerRepresentableContext<uibridging>)</uibridging></span></span> -> <span class="type">UIBridging</span>.<span class="type">UIViewControllerType</span> {</span><br><span class="line">        <span class="keyword">return</span> viewController()</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//更新UIViewController时会调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIViewController</span><span class="params">(<span class="number">_</span> uiViewController: viewController, context: UIViewControllerRepresentableContext<uibridging>)</uibridging></span></span> {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span></span>{</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">UIBridging</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView_Previews</span>: <span class="title">PreviewProvider</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">ContentView</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些"><a href="#注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些" class="headerlink" title="注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些"></a>注：你也可以写在一个文件中，但后期为了看着方便，简洁，还是分开写比较好一些</h2></body></html>]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>swiftUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeblocks中文乱码解决方法</title>
    <url>/2020/02/07/Codeblocks%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><p>Codeblocks中文乱码解决方法：</p>
<p>特别提示：出现中文乱码情况才执行以下操作，未出现请勿随意修改！！！！</p>
<p>打开Codeblocks -> 设置 -> 编辑器：</p>
<p><a href="https://img-blog.csdnimg.cn/20191205172416635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191205172416635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>然后点击 Encoding settings -> 选择编码 -> 选择UTF-8 -> 确定：</p>
<p><a href="https://img-blog.csdnimg.cn/20191205172454640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191205172454640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p><a href="https://img-blog.csdnimg.cn/20191205172512827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191205172512827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>点击设置 -> 编译器：</p>
<p><a href="https://img-blog.csdnimg.cn/20191205172528406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191205172528406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>点击Other compiler options->在空白处输入</p>
<p> -finput-charset=UTF-8</p>
<p>-fexec-charset=GBK</p>
<p>点击确定 -> 随意修改下代码 ->重新生成。</p>
<p><a href="https://img-blog.csdnimg.cn/2019120517254235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019120517254235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>即可解决乱码问题。</p>
</body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>mac与windows兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac修改键盘之 将 caps lock修改为esc</title>
    <url>/2020/02/05/Mac%E4%BF%AE%E6%94%B9%E9%94%AE%E7%9B%98%E4%B9%8B%E5%B0%86%E5%A4%A7%E5%B0%8F%E5%86%99%E9%94%81%E5%AE%9A%E4%BF%AE%E6%94%B9esc/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。"><a href="#想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。" class="headerlink" title="想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。"></a>想必进来的都是vim重度患者了，在vim里需要经常使用esc键。而他的位置真的事提高效率一大绊脚石之一。</h3><h3 id="大多数的人都是将caps-lock-修改为esc。"><a href="#大多数的人都是将caps-lock-修改为esc。" class="headerlink" title="大多数的人都是将caps lock 修改为esc。"></a>大多数的人都是将caps lock 修改为esc。</h3><p>因为caps lock 处在了最重要的位置却几乎不怎么使用他，如果用大写直接按住shift就可以了。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>之前在网上查到了关于此类的问题，说需要下载一个第三方软件，我推荐一个非常简单的方法，就在mac的设置里：</p>
<h4 id="找到系统偏好设置———-gt-键盘———-gt-左下角有一个修饰键"><a href="#找到系统偏好设置———-gt-键盘———-gt-左下角有一个修饰键" class="headerlink" title="找到系统偏好设置———>键盘———->左下角有一个修饰键"></a>找到系统偏好设置———>键盘———->左下角有一个修饰键</h4><p><a href="https://img-blog.csdnimg.cn/20200119094846166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119094846166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a><br>把第一个改成Escape就好啦</p>
<h1 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h1><p>实际上如图所示，mac已经提供了部分功能的修改，如果还想修改别的键，直接修改就好了</p>
</body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>C指针问题之不同类型指针之间的区别</title>
    <url>/2020/02/02/C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E4%B9%8B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="会想这样的一个问题："><a href="#会想这样的一个问题：" class="headerlink" title="会想这样的一个问题："></a>会想这样的一个问题：</h1><h3 id="指针就是地址吧，那么指向int-的指针也好，指向double的指针也好，他们有什么不同么"><a href="#指针就是地址吧，那么指向int-的指针也好，指向double的指针也好，他们有什么不同么" class="headerlink" title="== 指针就是地址吧，那么指向int 的指针也好，指向double的指针也好，他们有什么不同么=="></a>== 指针就是地址吧，那么指向int 的指针也好，指向double的指针也好，他们有什么不同么==</h3><p>emmmm<br>貌似也有一定道理。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>既然我们无法从正面解释，那我们就先设定一个“万能指针”<br>看我接下来这段操作：</p>
<p><a href="https://img-blog.csdnimg.cn/20200119212651514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119212651514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>在这里我创建了一个“可以指向任何类型的指针类型”——void*类型</p>
<p>但是当我运行的时候，出现了一个错误：</p>
<p><a href="https://img-blog.csdnimg.cn/20200119212816978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119212816978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>仔细想一下，如果仅仅知道了地址，但是不知道保存的数据类型，也是无法取出值的。<br>也就是说，上边的错误和下边的错误是一样的</p>
<p><a href="https://img-blog.csdnimg.cn/20200119213119242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119213119242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>也会报同样的错误。</p>
<p>如果我们把第一个做法中printf函数稍作更改</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*(<span class="keyword">int</span>*)hoge_p);</span><br></pre></td></tr></tbody></table></figure></div>
<p>成功！</p>
<p>因此，与其写成这样，还不如刚开始就定义他的类型</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *hoge_p;</span><br></pre></td></tr></tbody></table></figure></div>
<p>这样编译器会记住 hoge_p是指向int的指针<br>这也就是为什么指针要定义他的类型。</p>
<p>关于这一点，还有一个地方需要用到他的类型：<br>==指针运算==</p>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>书写如下代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> hoge;</span><br><span class="line">	<span class="keyword">int</span>* hoge_p;</span><br><span class="line">	hoge_p = &hoge;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hoge_p 的初始地址为：%p\n"</span>,hoge_p);</span><br><span class="line">	hoge_p++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hoge_p 加一后：%p\n"</span>,hoge_p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hoge_p 加一之后再加三后：%p\n"</span>,hoge_p + <span class="number">3</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>发现运行结果：</p>
<p><a href="https://img-blog.csdnimg.cn/20200119214650997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200119214650997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>我们知道c语言地址是以16进制的方式存储的。</p>
<p>发现：</p>
<h4 id="第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12"><a href="#第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12" class="headerlink" title="第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12."></a>第一个地址与第二个地址的值相差4，第二个与第三个地址的值相差12.</h4><p>不难看出：：</p>
<h2 id="对指针加N，指针前进“当前指针指向的数据类型的长度×N”"><a href="#对指针加N，指针前进“当前指针指向的数据类型的长度×N”" class="headerlink" title="对指针加N，指针前进“当前指针指向的数据类型的长度×N”"></a>对指针加N，指针前进“当前指针指向的数据类型的长度×N”</h2></body></html>]]></content>
      <categories>
        <category>征服C指针</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上自定义各个应用快捷键</title>
    <url>/2020/02/01/Mac%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%84%E4%B8%AA%E5%BA%94%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="进入系统偏好设置"><a href="#进入系统偏好设置" class="headerlink" title="进入系统偏好设置"></a>进入系统偏好设置</h1><h2 id="键盘选项"><a href="#键盘选项" class="headerlink" title="键盘选项"></a>键盘选项</h2><h3 id="快捷键："><a href="#快捷键：" class="headerlink" title="快捷键："></a>快捷键：</h3><p><a href="https://img-blog.csdnimg.cn/20200121123450810.png" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200121123450810.png" class="lazyload"></a></p>
<h3 id="选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。"><a href="#选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。" class="headerlink" title="选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。"></a>选择自己要添加的应用，在选择要改的功能名称，然后输入自己想要的快捷键。</h3><p><a href="https://img-blog.csdnimg.cn/20200121123525851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200121123525851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<p>点击添加，完成！</p>
</body></html>]]></content>
      <categories>
        <category>Mac骚操作</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>swift之基本运算符</title>
    <url>/2020/01/30/swift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="本章大致介绍一些swift特别的运算符"><a href="#本章大致介绍一些swift特别的运算符" class="headerlink" title="本章大致介绍一些swift特别的运算符"></a><strong><em>本章大致介绍一些swift特别的运算符</em></strong></h2><h1 id="元组比较"><a href="#元组比较" class="headerlink" title="元组比较"></a>元组比较</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">元组比较：</span></span><br><span class="line"><span class="comment">1.从左到右比较，一旦比出结果，即大于或小于，就是整体的比较结果</span></span><br><span class="line"><span class="comment">2.如果每个对应的元祖相等，则整体的结果就是相等</span></span><br><span class="line"><span class="comment">3.要比较7个或者更多的元素的元祖，必须实现比较运算符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>,<span class="string">"zebra"</span>)<(<span class="number">2</span>,<span class="string">"apple"</span>){</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"the second win"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="number">3</span>,<span class="string">"apple"</span>)<(<span class="number">3</span>,<span class="string">"bird"</span>){</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"the second win"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="number">4</span>,<span class="string">"dog"</span>) == (<span class="number">4</span>,<span class="string">"dog"</span>){</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"sample"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h1 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a>三元条件运算符</h1><p>与C语言中差不太多，直接上例子：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//三元条件运算符</span></span><br><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight = contentHeight + (hasHeader ? <span class="number">50</span> : <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(rowHeight)</span><br></pre></td></tr></tbody></table></figure></div>
<h1 id="关于-与-重点"><a href="#关于-与-重点" class="headerlink" title="关于 ? 与 !  //重点"></a>关于 ? 与 !  //重点</h1><p>swift语言中，如果不对变量进行初始化是不会自动给他一个初值的<a href="https://img-blog.csdnimg.cn/20200112143559495.png" data-fancybox="group" data-caption="此处报错" class="fancybox"><img alt="此处报错" title="此处报错" data-src="https://img-blog.csdnimg.cn/20200112143559495.png" class="lazyload"></a><br>此处报错的原因就是未初始化number就对他进行了使用</p>
<p>swift中有一种可选类型。（Optionals）</p>
<h4 id="？"><a href="#？" class="headerlink" title="？"></a>？</h4><p>在定义变量时添加一个问号。以为此变量为可选类型，如果后面，给该变量赋值x。那么他就是x，如果没有赋值，他就是nil。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int?</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt)</span><br><span class="line"><span class="comment">// 此时结果是nil</span></span><br></pre></td></tr></tbody></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int?</span></span><br><span class="line">optionalInt = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt)</span><br><span class="line"><span class="comment">//此时输出是Optional(1)</span></span><br></pre></td></tr></tbody></table></figure></div>
<p>但是现在会出现警告，就是虽然现在有值，（不管是不是nil都认为有值）。但是她现在是可选类型，应给他确定类型。</p>
<h4 id><a href="#" class="headerlink" title="!"></a>!</h4><p>此时 ！就是用来强制解析：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int?</span></span><br><span class="line">optionalInt = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt!)</span><br><span class="line"><span class="comment">//此时输出是1</span></span><br></pre></td></tr></tbody></table></figure></div>
<p>此时optionalInt 是Int 类型。<br>所以有时候我们可以直接这么写：<br></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">swift</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt : <span class="type">Int!</span></span><br><span class="line">optionalInt = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(optionalInt)</span><br><span class="line"><span class="comment">//此时输出是1</span></span><br></pre></td></tr></tbody></table></figure></div><br>==注：使用!来获取一个不存在的可选值会导致运行时错误。使用!来强制解析值之前，一定要确定可选包含一个非nil的值。==<br>也就是说如果没有第二句赋值，此程序会崩掉。<br>所以使用！时要注意这点<p></p>
</body></html>]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C指针——和指针的第一次亲密接触</title>
    <url>/2020/01/30/%E5%85%B3%E4%BA%8EC%E6%8C%87%E9%92%88%E2%80%94%E2%80%94%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="先看代码："><a href="#先看代码：" class="headerlink" title="先看代码："></a>先看代码：</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出每个变量的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a的地址是 %p\n"</span>,&a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b的地址是 %p\n"</span>,&b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c的地址是 %p\n"</span>,&c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将a的地址赋予c*/</span></span><br><span class="line">    c = &a;<span class="comment">//此处需用到  ”&“来得到a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c修改后的地址为 %p\n"</span>,c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c输出a的内容*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*c ---->%d\n"</span>,*c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c修改a的内容*/</span></span><br><span class="line">    *c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a---->%d\n"</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="然后我们看运行结果"><a href="#然后我们看运行结果" class="headerlink" title="然后我们看运行结果"></a>然后我们看运行结果</h2><p><a href="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h2 id="我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c"><a href="#我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c" class="headerlink" title="我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c"></a>我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c</h2><p>==我们暂且先将c理解为指向int 的指针==</p>
<h2 id="再看初始化完后内存中保存的样子"><a href="#再看初始化完后内存中保存的样子" class="headerlink" title="再看初始化完后内存中保存的样子"></a>再看初始化完后内存中保存的样子<a href="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></h2><p>在c语言中，会存在 int类型，double类型，等。。同样，c语言中也存在指针类型这样的类型。<br>指针类型并不是单独存在的，而是由其他类型派生出来的。。</p>
<p>==由引用类型T派生的指针类型有时候称为’（指向）T的指针‘==</p>
<p>因为指针类型是类型，所以他也像其他类型一样，有“指针类型的值和指针类型变量”，但有时，我们将“指针类型”，“指针类型变量”，“指针类型的值”简单统称为—-指针</p>
<p>因此 c就是一个指针类型变量——-指向int的指针，但此时并为对它赋值。</p>
<p>接下来我们将a的地址赋予了c，此时c的值就是a的地址<a href="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h2 id="接下来："><a href="#接下来：" class="headerlink" title="接下来："></a>接下来：</h2><p>在指针前面加<em>，可以表示指针指向的变量，因为现在c指向a，所以</em>c就等同于a。同理，修改*c就相当于修改了a的值。</p>
<p>==这是对后两行输出做的解释==</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>如果说c是 指向int的指针，但我们声明变量时一般要遵循：</p>
<h2 id="类型-变量名"><a href="#类型-变量名" class="headerlink" title="类型 变量名"></a>类型 变量名</h2><p>因此，我们似乎声明了一个名为*c的变量。</p>
<p>所以我们可以写成 ==int* c==的形式。这样更符合  ==类型 变量名==  的形式。</p>
<p>但之后就会出现问题：<br>数组也是C语言的一种类型。。如果按上述所说的话。<br>C语言声明数组时应该是：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<p>很明显，会报错。这就产生了矛盾。。</p>
<p>反而，Java中可以这么写，但是Java为了让C程序员更好的转向Java。也兼容了c语言定义数组的写法。。</p>
<p>在这里需要插一句：</p>
<h2 id="C语言的语法本来就是不自然的，奇怪的而又变态的。"><a href="#C语言的语法本来就是不自然的，奇怪的而又变态的。" class="headerlink" title="C语言的语法本来就是不自然的，奇怪的而又变态的。"></a>C语言的语法本来就是不自然的，奇怪的而又变态的。</h2><p>之后我会出一篇关于C语法的博客专门研究这“变态的”c语法。。。</p>
<p>欢迎吐槽评论</p>
</body></html>]]></content>
      <categories>
        <category>征服C指针</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6-1 邻接矩阵存储图的深度优先遍历 (20 分)</title>
    <url>/2020/01/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><blockquote>
<p>试实现邻接矩阵存储图的深度优先遍历。</p>
</blockquote>
<p>函数接口定义：<br>void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );<br>其中MGraph是邻接矩阵存储的图，定义如下：</p>
<p>typedef struct GNode <em>PtrToGNode;<br>struct GNode{<br>    int Nv;  /</em> 顶点数 <em>/<br>    int Ne;  /</em> 边数   <em>/<br>    WeightType G[MaxVertexNum][MaxVertexNum]; /</em> 邻接矩阵 <em>/<br>};<br>typedef PtrToGNode MGraph; /</em> 以邻接矩阵存储的图类型 */<br>函数DFS应从第V个顶点出发递归地深度优先遍历图Graph，遍历时用裁判定义的函数Visit访问每个顶点。当访问邻接点时，要求按序号递增的顺序。题目保证V是图中的合法顶点。</p>
<p>裁判测试程序样例：</p>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdio.h></stdio.h></h1><p>typedef enum {false, true} bool;</p>
<h1 id="define-MaxVertexNum-10-最大顶点数设为10"><a href="#define-MaxVertexNum-10-最大顶点数设为10" class="headerlink" title="define MaxVertexNum 10  / 最大顶点数设为10 /"></a>define MaxVertexNum 10  /<em> 最大顶点数设为10 </em>/</h1><h1 id="define-INFINITY-65535-∞设为双字节无符号整数的最大值65535"><a href="#define-INFINITY-65535-∞设为双字节无符号整数的最大值65535" class="headerlink" title="define INFINITY 65535   / ∞设为双字节无符号整数的最大值65535/"></a>define INFINITY 65535   /<em> ∞设为双字节无符号整数的最大值65535</em>/</h1><p>typedef int Vertex;      /<em> 用顶点下标表示顶点,为整型 </em>/<br>typedef int WeightType;  /<em> 边的权值设为整型 </em>/</p>
<p>typedef struct GNode <em>PtrToGNode;<br>struct GNode{<br>    int Nv;  /</em> 顶点数 <em>/<br>    int Ne;  /</em> 边数   <em>/<br>    WeightType G[MaxVertexNum][MaxVertexNum]; /</em> 邻接矩阵 <em>/<br>};<br>typedef PtrToGNode MGraph; /</em> 以邻接矩阵存储的图类型 <em>/<br>bool Visited[MaxVertexNum]; /</em> 顶点的访问标记 */</p>
<p>MGraph CreateGraph(); /<em> 创建图并且将Visited初始化为false；裁判实现，细节不表 </em>/</p>
<p>void Visit( Vertex V )<br>{<br>    printf(“ %d”, V);<br>}</p>
<p>void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );</p>
<p>int main()<br>{<br>    MGraph G;<br>    Vertex V;</p>
<pre><code>G = CreateGraph();
scanf("%d", &V);
printf("DFS from %d:", V);
DFS(G, V, Visit);

return 0;
</code></pre><p>}</p>
<p>/<em> 你的代码将被嵌在这里 </em>/<br>输入样例：给定图如下</p>
<p>5<br>输出样例：<br>DFS from 5: 5 1 3 0 2 4 6<br>作者: DS课程组<br>单位: 浙江大学<br>时间限制: 400 ms<br>内存限制: 64 MB</p>
<h2 id="很明显这个用递归就可以了"><a href="#很明显这个用递归就可以了" class="headerlink" title="很明显这个用递归就可以了"></a>很明显这个用递归就可以了</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">( MGraph Graph, Vertex V, <span class="keyword">void</span> (*Visit)(Vertex) )</span></span>{</span><br><span class="line">    Visited[V] = <span class="literal">true</span>;</span><br><span class="line">    Visit(V);</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<maxvertexnum; i++) {< span><br><span class="line">        <span class="keyword">if</span> (Graph->G[V][i] == <span class="number">1</span> && !Visited[i]) {</span><br><span class="line">            DFS(Graph,i,Visit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></maxvertexnum;></span></pre></td></tr></tbody></table></figure></div>
<p>根据提要求访问过的节点需要true<br>所以在此访问还应判断该节点是不是false</p>
</body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔非递归实现 C语言版</title>
    <url>/2020/01/21/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0c%E8%AF%AD%E8%A8%80%E7%89%88/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="汉诺塔非递归实现-C语言版"><a href="#汉诺塔非递归实现-C语言版" class="headerlink" title="汉诺塔非递归实现 C语言版"></a><strong><em>汉诺塔非递归实现 C语言版</em></strong></h1><p>我上一篇博客是汉诺塔C语言递归实现，非递归和递归想法一样。这里不再赘述，直接链接转到：</p>
<p><a href="https://blog.csdn.net/VistorsYan/article/details/102765478" target="_blank" rel="noopener">汉诺塔递归实现 C语言版</a></p>
<p>   递归实现固然好理解，但是n的值越大，空间和时间上都是极大的消耗，最终可能导致程序直接崩溃。<br>在以后的做题或者是面试中，不推荐用递归方法做，所以要写出对应的非递归方法。</p>
<p>  某次上课无意间听到老师说了这样一句话：任何递归法都可以用循环的方法进行非递归实现，然后回头找了找汉诺塔非递归的资料，整理整理，搞出了一个c实现的非递归方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#include<stdio.h></stdio.h></span></span><br><span class="line"><span class="comment">#include <stdlib.h></stdlib.h></span></span><br><span class="line"><span class="comment">#define MaxSize 100</span></span><br><span class="line">typedef struct{</span><br><span class="line">     int N;</span><br><span class="line">     char A;        //起始柱</span><br><span class="line">     char B;        //借助柱</span><br><span class="line">     char C;        //目标柱</span><br><span class="line">}ElementType;</span><br><span class="line">typedef struct {</span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    int top;</span><br><span class="line">}Stack;//汉诺塔问题的结构类型</span><br><span class="line">void Push(Stack *PtrS, ElementType item){</span><br><span class="line">     //入栈操作</span><br><span class="line">     <span class="keyword">if</span> (PtrS->top == MaxSize)</span><br><span class="line">     {</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"The stack is full!\n"</span>);</span><br><span class="line">         <span class="built_in">return</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     {</span><br><span class="line">         PtrS->Data[++(PtrS->top)] = item;</span><br><span class="line">         <span class="built_in">return</span>;</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line">ElementType Pop(Stack *PtrS){</span><br><span class="line">    <span class="keyword">if</span> (PtrS->top == -1)</span><br><span class="line">      {</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"The stack is empty!\n"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(1);   //直接终止程序，一般不会出现这个错误</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">          PtrS->top--;</span><br><span class="line">         <span class="built_in">return</span> (PtrS->Data[PtrS->top + 1]);        //或者是<span class="built_in">return</span> PtrS->Data[PtrS->top--];</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line">//借助栈的非递归实现</span><br><span class="line"> void Hanoi(int n){</span><br><span class="line">    ElementType P, toPush;</span><br><span class="line">    Stack S;</span><br><span class="line"></span><br><span class="line">    P.N = n; P.A = <span class="string">'a'</span>; P.B = <span class="string">'b'</span>; P.C = <span class="string">'c'</span>;</span><br><span class="line">    S.top = -1;</span><br><span class="line"></span><br><span class="line">     Push(&S, P);</span><br><span class="line">     <span class="keyword">while</span> (S.top != -1)        //当堆栈不为空时</span><br><span class="line">     {</span><br><span class="line">         P = Pop(&S);//出栈</span><br><span class="line">         <span class="keyword">if</span> (P.N == 1)//当只剩一个盘子时，直接由当前柱移动到目的柱</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%c -> %c\n"</span>, P.A, P.C);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         {</span><br><span class="line">             toPush.N = P.N - 1;</span><br><span class="line">             toPush.A = P.B; toPush.B = P.A; toPush.C = P.C;</span><br><span class="line">             Push(&S, toPush);        //将第三步(n - 1, b, a, c)入栈</span><br><span class="line">             toPush.N = 1;</span><br><span class="line">             toPush.A = P.A; toPush.B = P.B; toPush.C = P.C;</span><br><span class="line">             Push(&S, toPush);        //将第二步1, a, b, c)入栈</span><br><span class="line">             toPush.N = P.N - 1;</span><br><span class="line">             toPush.A = P.A; toPush.B = P.C; toPush.C = P.B;</span><br><span class="line">             Push(&S, toPush);        //将第一步(n - 1, a, c, b)入栈</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line"> }</span><br><span class="line">int <span class="function"><span class="title">main</span></span>(){</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">"%d"</span>, &n);</span><br><span class="line">    <span class="keyword">if</span> (n <= 0)<span class="built_in">return</span> 0;</span><br><span class="line">    <span class="keyword">else</span> Hanoi(n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>还是三个步骤：<br>1.将n-1个盘子由a柱借助c柱移动到b柱<br>2.将最下面的盘子由a柱直接移动到c柱<br>3.将那n-1个盘子在由b柱借助a柱移动到c柱</p>
<p>因为这个是出栈时的操作，所以入栈时要到着写</p>
<h2 id="简要解释一下（因为跟递归思路差不多）"><a href="#简要解释一下（因为跟递归思路差不多）" class="headerlink" title="简要解释一下（因为跟递归思路差不多）"></a>简要解释一下（因为跟递归思路差不多）</h2><p>如果n不等于一时，就意味着，以上的n-1个盘子，都要做上述所说的三个步骤，知道n等于1时，直接移动到目的柱。<br>因此，移动次数最多的是最上边的那个盘子，移动次数最少的是最下面的那个盘子，只需要移动一次</p>
<p>利用结构体数组更便于理解。</p>
<p>本文为原创，如有问题欢迎评论区留言。</p>
</body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>2-5 修理牧场 (35分) 哈夫曼树例题 c与c++鸳鸯解法 详细解释</title>
    <url>/2020/01/20/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91--%E4%BF%AE%E7%90%86%E7%89%A7%E5%9C%BA/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><p>农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数Li个长度单位，于是他购买了一条很长的、能锯成N块的木头，即该木头的长度是Li​​的总和。</p>
<p>但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。</p>
<p>请编写程序帮助农夫计算将木头锯成N块的最少花费。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入首先给出正整数N（≤10000​​ ），表示要将木头锯成N块。第二行给出N个正整数（≤50），表示每段木块的长度。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>输出一个整数，即将木头锯成N块的最少花费。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><p>8<br>4 5 1 2 1 3 1 1</p>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><p>49</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。"><a href="#构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。" class="headerlink" title="构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。"></a>构造最优二叉树，将除叶节点外所有的节点权值加和。即为所求。</h2><p>实际上是没必要构造一颗树的，运用他的原理即可</p>
<p>其实这两个解法差不多，但是c++更加的简单易于理解，在时间上也是很短的。c相对而言就比较暴力了。相当于对c++解法的底层解释。注重基础。<br><code>
</code></p>
<h2 id="c-解法"><a href="#c-解法" class="headerlink" title="c++解法"></a>c++解法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><queue></queue></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue<<span class="keyword">int</span>,<span class="built_in">vector</span><<span class="keyword">int</span>>,greater<<span class="keyword">int</span>> > Q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> x,n,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<n;i++){< span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&x);</span><br><span class="line">        Q.push(x);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(Q.size()><span class="number">1</span>){</span><br><span class="line">        <span class="keyword">int</span> a=Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">int</span> b=Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        Q.push(a+b);</span><br><span class="line">        sum+=a+b;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></n;i++){<></span></pre></td></tr></tbody></table></figure></div>
<p>在这里解释一下这句话<br></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">priority_queue<<span class="keyword">int</span>,<span class="built_in">vector</span><<span class="keyword">int</span>>,greater<<span class="keyword">int</span>> > Q;</span><br></pre></td></tr></tbody></table></figure></div><br>priority_queue<type, container, functional>，其中Type 为数据类型，Container为保存数据的容器，Functional 为元素比较方式。<br>Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。<br>greater 可以实现由底部到顶部大到小实现。<br>所以这道题的步骤就是，<br>push出两个最小值并相加，将相加的值加到sum并放回Q中，然后会重新排列大小。<br>以此类推<p></p>
<p><a href="https://img-blog.csdnimg.cn/20191207174941948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191207174941948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a><br>不仅代码量很少，时间也是很短的，考试的时候可以使用，平时练习不建议，有点投机取巧。练习还是用c一步步实现他的每一个步骤。</p>
<h2 id="c解法"><a href="#c解法" class="headerlink" title="c解法"></a>c解法</h2><p>用c语言其实就是对c++的具体实现，（可能我这个不是最好的解法。）但是每次取每次放都需要重新排序，这将是一件很累的事情。所以干脆就不排序了，直接放在那，取的时候再去判断最小值。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10010</span>],n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = Max+<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++)< span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span>>a[i]) <span class="built_in">min</span> = a[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++)< span><br><span class="line">        <span class="keyword">if</span> (a[i] == x) {</span><br><span class="line">            a[i] = Max;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++)< span><br><span class="line">        <span class="keyword">if</span> (a[i] == Max) {</span><br><span class="line">            a[i] = x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i,sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++)< span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&a[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i<n; i++) {< span><br><span class="line">        <span class="keyword">int</span> x = findMin();</span><br><span class="line">        Delete(x);</span><br><span class="line">        <span class="keyword">int</span> y = findMin();</span><br><span class="line">        Delete(y);</span><br><span class="line">        add(x+y);</span><br><span class="line">        sum2+=x+y;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum2);</span><br><span class="line">}</span><br></n;></span></n;></span></n;></span></n;></span></n;></span></pre></td></tr></tbody></table></figure></div>
<p>这里注明一下：删除其实就是把现在这个数组里这个值（不一定是之前取的那个数）给赋值为非常大，这样下次寻找最小值就不会找到他。<br>如果有添加，那么之前一定有删除，直接把添加的值放在删除的值的地方就行了。<br>Max一定要特别大，要不然，最大值测试用例时，x+y的值甚至会大过Max，这样就出错了。<br>这个实现就很耗时了，算是锻炼思维把。<br><a href="https://img-blog.csdnimg.cn/20191207180030125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191207180030125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h1 id="如果有更好的解法，或者是有什么问题的话，欢迎留言。"><a href="#如果有更好的解法，或者是有什么问题的话，欢迎留言。" class="headerlink" title="如果有更好的解法，或者是有什么问题的话，欢迎留言。"></a>如果有更好的解法，或者是有什么问题的话，欢迎留言。</h1></type,></body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA 树种统计  c语言-------二叉搜索树 详细解释</title>
    <url>/2020/01/20/%E6%A0%91%E7%A7%8D%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="树种统计"><a href="#树种统计" class="headerlink" title="树种统计"></a>树种统计</h1><h2 id="这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。"><a href="#这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。" class="headerlink" title="这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。"></a>这题乍一瞅写个树种，但是再一看貌似跟树没啥关系啊。</h2><p>随着卫星成像技术的应用，自然资源研究机构可以识别每一棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。</p>
<p>输入格式:<br>输入首先给出正整数N（≤10<br>​5<br>​​ ），随后N行，每行给出卫星观测到的一棵树的种类名称。种类名称由不超过30个英文字母和空格组成（大小写不区分）。</p>
<p>输出格式:<br>按字典序递增输出各种树的种类名称及其所占总数的百分比，其间以空格分隔，保留小数点后4位。</p>
<h2 id="第一眼直观感受是用数组常规排序？？？-但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。"><a href="#第一眼直观感受是用数组常规排序？？？-但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。" class="headerlink" title="第一眼直观感受是用数组常规排序？？？ 但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。"></a>第一眼直观感受是用数组常规排序？？？ 但是看了一眼给的案例，这么老些，而且N是小于等于10的五次方。。用数组常规排序肯定超时。</h2><h2 id="这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O-logN-。根据二维图像，可以想象数据量越大，O-logN-会越来越趋近与O-1"><a href="#这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O-logN-。根据二维图像，可以想象数据量越大，O-logN-会越来越趋近与O-1" class="headerlink" title="这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O(logN)。根据二维图像，可以想象数据量越大，O(logN)会越来越趋近与O(1)"></a><strong><em>这么大的数据量要想排序并输出只能想到的是二分法。因为二分法时间复杂度O(logN)。根据二维图像，可以想象数据量越大，O(logN)会越来越趋近与O(1)</em></strong></h2><h2 id="在回归这道题，数组里的二分法是去查找元素。。-而这道题是把元素按顺序输出，所以还是不行。。。。"><a href="#在回归这道题，数组里的二分法是去查找元素。。-而这道题是把元素按顺序输出，所以还是不行。。。。" class="headerlink" title="在回归这道题，数组里的二分法是去查找元素。。 而这道题是把元素按顺序输出，所以还是不行。。。。"></a>在回归这道题，数组里的二分法是去查找元素。。 而这道题是把元素按顺序输出，所以还是不行。。。。</h2><p>最后想了想二分法在树里的应用</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>在输入时就开始构造二叉搜索树。。</p>
<p>然后中序遍历输出就可以了。。。<br>左中右 正好是有小到大。。<br>至于后面那个频率，加个计数器，最后除以总数就可以了。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 思路：已二叉搜索树的方式保存输入的名称，并赋予一个计数器。然后中序遍历输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><string.h></string.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>{</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">31</span>];</span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">    <span class="keyword">int</span> k;<span class="comment">//计数器</span></span><br><span class="line">}tree[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InVisit</span><span class="params">(struct TreeNode Tree,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (Tree.left == Null && Tree.right == Null) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %.4f%%\n"</span>,Tree.data,Tree.k/(<span class="keyword">double</span>)n*<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (Tree.left!=Null) {</span><br><span class="line">        InVisit(tree[Tree.left],n);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %.4f%%\n"</span>,Tree.data,Tree.k/(<span class="keyword">double</span>)n*<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (Tree.right!=Null) {</span><br><span class="line">        InVisit(tree[Tree.right],n);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n,i,temp = <span class="number">0</span>,flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++) {< span><br><span class="line">        tree[i].k = <span class="number">0</span>;</span><br><span class="line">        tree[i].left = Null;</span><br><span class="line">        tree[i].right = Null;</span><br><span class="line">    }</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i<n; i++) {< span><br><span class="line">        gets(tree[i].data);</span><br><span class="line">        <span class="comment">//二叉搜索树插入 数组保存法</span></span><br><span class="line">        <span class="keyword">while</span> (flag) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tree[i].data, tree[temp].data)<<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (tree[temp].left!=Null) {</span><br><span class="line">            temp = tree[temp].left;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                tree[temp].left = i;</span><br><span class="line">                tree[i].k++;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tree[i].data, tree[temp].data)><span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span> (tree[temp].right!=Null) {</span><br><span class="line">                temp = tree[temp].right;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                tree[temp].right = i;</span><br><span class="line">                tree[i].k++;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            tree[temp].k++;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    InVisit(tree[<span class="number">0</span>],n);</span><br><span class="line">}</span><br></n;></span></n;></span></pre></td></tr></tbody></table></figure></div>
<p>这里我用的数组的方法保存树<br>当然也可以用链表储存，但是链表消耗内存过大。。。个人不太建议。</p>
</body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>LeeCode第二题常见报错</title>
    <url>/2020/01/19/leeCode%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%981/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><hr>
<h2 id="LeeCode第二题"><a href="#LeeCode第二题" class="headerlink" title="LeeCode第二题"></a>LeeCode第二题</h2><p>两数相加 c语言实现报错解决</p>
<hr>
<p>runtime error: member access within misaligned address 0xbebebebebebebebe for type ‘struct ListNode’, which requires 8 byte alignment (ListNode.c)<br>0xbebebebebebebebe: note: pointer points here</p>
<memory cannot be printed>

<p>*</p>
<p>同样的思路，用Java实现可以运行，但是c语言却频频出现了上述所说的错误。困扰了我许多天，最后参考了一下csdn上大佬的想法，然后仔细在读这个错误，原因在你申请一个节点空间时，它的next指针也诞生出来了，注意这句note: pointer points here<br>说明有指针，但是你没有让他指向一个地址。所以出现这个错误，所以在你申请一个节点空间后，紧跟着把它的next赋值为空就可以了。</p>
<p>*<br>顺便呈上我的代码吧，思路就不多解释了，比较容易懂</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){</span><br><span class="line">    struct ListNode *p1,*p2,*p ,*h;</span><br><span class="line">    struct ListNode *head = malloc(sizeof(struct ListNode));</span><br><span class="line">    p1 = l1;</span><br><span class="line">    p2 = l2;</span><br><span class="line">    p = head;</span><br><span class="line"></span><br><span class="line">    int t = 0;</span><br><span class="line">    <span class="keyword">while</span> (p1||p2) {</span><br><span class="line">        int x = (p1!=NULL) ? p1->val:0;</span><br><span class="line">        int y = (p2!=NULL) ? p2->val:0;</span><br><span class="line">        int sum = x + y +t;</span><br><span class="line">        t = sum/10;</span><br><span class="line">        h = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">        h->next = NULL;//赋值为空</span><br><span class="line">        p->next = h;</span><br><span class="line">        p = p->next;</span><br><span class="line">        h->val = sum%10;</span><br><span class="line">        <span class="keyword">if</span> (p1) p1 = p1->next;</span><br><span class="line">        <span class="keyword">if</span> (p2) p2 = p2->next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (t>0) {</span><br><span class="line">        p->next = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">        p = p->next;</span><br><span class="line">        p->next = NULL;</span><br><span class="line">        p->val = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">return</span> head->next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>运行时间比较菜，如果有什么可以改进的话，或者更好的方法欢迎留言！！</p>
</memory></body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeeCode</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔递归实现c语言版</title>
    <url>/2020/01/19/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0c%E8%AF%AD%E8%A8%80%E7%89%88/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="汉诺塔问题-递归实现法"><a href="#汉诺塔问题-递归实现法" class="headerlink" title="汉诺塔问题 递归实现法"></a><strong><em>汉诺塔问题 递归实现法</em></strong></h2><p><strong>话不多说直接上代码</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#include <stdio.h></stdio.h></span></span><br><span class="line">void Move(int n ,char from ,char to){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c -> %c\n"</span>,from,to);</span><br><span class="line">}</span><br><span class="line">void hanoi(int n ,char from,char depend,char to){</span><br><span class="line">    <span class="keyword">if</span> (n == 1) {</span><br><span class="line">        //当剩一个盘子的时候，直接移动到目的柱</span><br><span class="line">        Move(1, from, to);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        hanoi(n-1,from,to,depend);//将初始柱的前n-1个盘子借助目的塔移动到借用柱上</span><br><span class="line">        Move(n,from,to);              //将剩下的一个盘子移动到目的柱上</span><br><span class="line">        hanoi(n-1,depend,from,to);//将b柱n-1个盘子移动到借用a柱移动到c上</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() {</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&n);</span><br><span class="line">    char x = <span class="string">'A'</span>,y = <span class="string">'B'</span>,z = <span class="string">'C'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"盘子移动情况如下：\n"</span>);</span><br><span class="line">    hanoi(n, x, y, z);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>思路：<br>不管多少个盘子（一个盘子的时候除外），全部都看作是两个盘子<br>即 最下面的那一个，和其上面的(n-1)个。<br>这样两个盘子的时候，移动就非常简单了。</p>
<p><strong>总共有三步：</strong><br>1.将第一个(也就是n-1)个盘子借助C柱从A柱移动到B柱。<br>2.将最下面的那一个盘子直接从A柱移动到C柱。<br>3.最后将B柱的那些(n-1)个盘子借助A柱移动到C柱。</p>
<p>所以在入口参数的时候需要，起始柱，借助柱（有点绕口），目的柱。</p>
<p>刚开始可能有些看不太懂，可以先输入几个简单的数，用断点调试，看一下他的移动过程。<br>递归函数的终点就是只剩一个盘子的时候，直接移动到目的柱。</p>
<p><strong><em>如果明白了就不用看我下面的废话了</em></strong></p>
<p>假设有64个盘子，那么问题就成了移动63和最下面的盘子。分成了两组去完成我上述说的那三步。<br>接着63个盘子去做第一步时就已经开始了递归。<br>递归到下一级时，就意味着再把63个盘子看成一个整体。分成两部分，最下面的一块和上面的62块。去完成这件事，以此类推，直到第一块。<br>因为只有前62块都完成移动，才可以移动到第六十三块。</p>
<p>不要去想着这个过程，很容易绕晕的，只需要知道这个函数的功能就是移动盘子。</p>
<p><strong><em>下篇博客写汉诺塔非递归算法，c语言实现。 </em></strong></p>
<blockquote>
<p>参考博客<br><a href="https://blog.csdn.net/csshuke/article/details/82630311" target="_blank" rel="noopener">https://blog.csdn.net/csshuke/article/details/82630311</a></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C指针----和指针的第一次亲密接触</title>
    <url>/2020/01/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="先看代码："><a href="#先看代码：" class="headerlink" title="先看代码："></a>先看代码：</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出每个变量的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a的地址是 %p\n"</span>,&a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b的地址是 %p\n"</span>,&b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c的地址是 %p\n"</span>,&c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将a的地址赋予c*/</span></span><br><span class="line">    c = &a;<span class="comment">//此处需用到  ”&“来得到a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c修改后的地址为 %p\n"</span>,c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c输出a的内容*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*c ---->%d\n"</span>,*c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过c修改a的内容*/</span></span><br><span class="line">    *c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a---->%d\n"</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="然后我们看运行结果"><a href="#然后我们看运行结果" class="headerlink" title="然后我们看运行结果"></a>然后我们看运行结果</h2><p><a href="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200115085336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h2 id="我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c"><a href="#我们首先声明了int型变量-a-b-然后声明了”指向int-的指针“类型的变量c" class="headerlink" title="我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c"></a>我们首先声明了int型变量 a,b 然后声明了”指向int 的指针“类型的变量c</h2><p>==我们暂且先将c理解为指向int 的指针==</p>
<h2 id="再看初始化完后内存中保存的样子"><a href="#再看初始化完后内存中保存的样子" class="headerlink" title="再看初始化完后内存中保存的样子"></a>再看初始化完后内存中保存的样子<a href="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200115090658778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></h2><p>在c语言中，会存在 int类型，double类型，等。。同样，c语言中也存在指针类型这样的类型。<br>指针类型并不是单独存在的，而是由其他类型派生出来的。。</p>
<p>==由引用类型T派生的指针类型有时候称为’（指向）T的指针‘==</p>
<p>因为指针类型是类型，所以他也像其他类型一样，有“指针类型的值和指针类型变量”，但有时，我们将“指针类型”，“指针类型变量”，“指针类型的值”简单统称为—-指针</p>
<p>因此 c就是一个指针类型变量——-指向int的指针，但此时并为对它赋值。</p>
<p>接下来我们将a的地址赋予了c，此时c的值就是a的地址<a href="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2020011509233464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Zpc3RvcnNZYW4=,size_16,color_FFFFFF,t_70" class="lazyload"></a></p>
<h2 id="接下来："><a href="#接下来：" class="headerlink" title="接下来："></a>接下来：</h2><p>在指针前面加<em>，可以表示指针指向的变量，因为现在c指向a，所以</em>c就等同于a。同理，修改*c就相当于修改了a的值。</p>
<p>==这是对后两行输出做的解释==</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>如果说c是 指向int的指针，但我们声明变量时一般要遵循：</p>
<h2 id="类型-变量名"><a href="#类型-变量名" class="headerlink" title="类型 变量名"></a>类型 变量名</h2><p>因此，我们似乎声明了一个名为*c的变量。</p>
<p>所以我们可以写成 ==int* c==的形式。这样更符合  ==类型 变量名==  的形式。</p>
<p>但之后就会出现问题：<br>数组也是C语言的一种类型。。如果按上述所说的话。<br>C语言声明数组时应该是：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span>;</span><br></pre></td></tr></tbody></table></figure></div>
<p>很明显，会报错。这就产生了矛盾。。</p>
<p>反而，Java中可以这么写，但是Java为了让C程序员更好的转向Java。也兼容了c语言定义数组的写法。。</p>
<p>在这里需要插一句：</p>
<h2 id="C语言的语法本来就是不自然的，奇怪的而又变态的。"><a href="#C语言的语法本来就是不自然的，奇怪的而又变态的。" class="headerlink" title="C语言的语法本来就是不自然的，奇怪的而又变态的。"></a>C语言的语法本来就是不自然的，奇怪的而又变态的。</h2><p>之后我会出一篇关于C语法的博客专门研究这“变态的”c语法。。。</p>
<p>欢迎吐槽评论</p>
</body></html>]]></content>
      <categories>
        <category>征服C指针</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
</search>
